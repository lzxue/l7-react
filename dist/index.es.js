import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';

function loadScript(src) {
  return new Promise(function (resolve, reject) {
    try {
      var script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    } catch (err) {
      reject(err);
    }
  });
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var AMapProvider = function (_React$PureComponent) {
  inherits(AMapProvider, _React$PureComponent);

  function AMapProvider() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, AMapProvider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AMapProvider.__proto__ || Object.getPrototypeOf(AMapProvider)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      loaded: null
    }, _this.getChildContext = function () {
      return {
        AMap: _this.state.AMap
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(AMapProvider, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.loadAMap().then(function () {
        _this2.setState({ loaded: true });
      }).catch(function (err) {
        throw err;
      });
    }
  }, {
    key: 'loadAMap',
    value: function loadAMap() {
      var _props = this.props,
          token = _props.token,
          version = _props.version,
          plugin = _props.plugin;

      return loadScript('https://webapi.amap.com/maps?v=' + version + '&key=' + token + '&plugin=' + plugin);
    }
  }, {
    key: 'render',
    value: function render() {
      return this.state.loaded ? this.props.children : null;
    }
  }]);
  return AMapProvider;
}(React.PureComponent);

AMapProvider.propTypes = {
  children: PropTypes.object,
  token: PropTypes.string,
  plugin: PropTypes.string,
  version: PropTypes.string
};
AMapProvider.defaultProps = {
  plugin: 'Map3D',
  version: '1.4.15'
};
AMapProvider.childContextTypes = {
  AMap: PropTypes.object
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var L7 = createCommonjsModule(function (module, exports) {
(function (global, factory) {
module.exports = factory();
}(commonjsGlobal, function () {
/* eslint-disable */

var shared, worker, L7;
// define gets called three times: one for each chunk. we rely on the order
// they're imported to know which is which
function define(_, chunk) {
if (!shared) {
    shared = chunk;
} else if (!worker) {
    worker = chunk;
} else {
    var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);';

    var sharedChunk = {};
    shared(sharedChunk);
    L7 = chunk(sharedChunk);
    L7.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
}
}


define(['exports'], function (exports) {
function unwrapExports$$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule$$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var EventEmitter = createCommonjsModule$$1(function (module) {
(function (exports) {

    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var originalGlobalValue = exports.EventEmitter;

    /**
     * Finds the index of the listener for the event in its storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        }
        else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    function isValidListener (listener) {
        if (typeof listener === 'function' || listener instanceof RegExp) {
            return true
        } else if (listener && typeof listener === 'object') {
            return isValidListener(listener.listener)
        } else {
            return false
        }
    }

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        if (!isValidListener(listener)) {
            throw new TypeError('listener must be a function');
        }

        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of its properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    }
                    else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        }
        else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        }
        else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        }
        else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listenersMap = this.getListenersAsObject(evt);
        var listeners;
        var listener;
        var i;
        var key;
        var response;

        for (key in listenersMap) {
            if (listenersMap.hasOwnProperty(key)) {
                listeners = listenersMap[key].slice(0);

                for (i = 0; i < listeners.length; i++) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        }
        else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };

    // Expose the class either via AMD, CommonJS or the global object
    if ( module.exports){
        module.exports = EventEmitter;
    }
    else {
        exports.EventEmitter = EventEmitter;
    }
}(typeof window !== 'undefined' ? window : this || {}));
});

// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

if ( Number.isInteger === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

	Number.isInteger = function ( value ) {

		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

	};

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( 'name' in Function.prototype === false ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	( function () {

		Object.assign = function ( target ) {
			var arguments$1 = arguments;


			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments$1[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	} )();

}

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

}

Object.assign( Vector4.prototype, {

	isVector4: true,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) { s = 1; }

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector4();
				max = new Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: ( function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		var lut = [];

		for ( var i = 0; i < 256; i ++ ) {

			lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

		}

		return function generateUUID() {

			var d0 = Math.random() * 0xffffffff | 0;
			var d1 = Math.random() * 0xffffffff | 0;
			var d2 = Math.random() * 0xffffffff | 0;
			var d3 = Math.random() * 0xffffffff | 0;
			var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
				lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
				lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
				lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

			// .toUpperCase() here flattens concatenated strings to save heap memory space.
			return uuid.toUpperCase();

		};

	} )(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) { return 0; }
		if ( x >= max ) { return 1; }

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) { return 0; }
		if ( x >= max ) { return 1; }

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix4.prototype, {

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	},

	extractRotation: function () {

		var v1 = new Vector3();

		return function extractRotation( m ) {

			// this method does not support reflection matrices

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function () {

		var zero = new Vector3( 0, 0, 0 );
		var one = new Vector3( 1, 1, 1 );

		return function makeRotationFromQuaternion( q ) {

			return this.compose( zero, q, one );

		};

	}(),

	lookAt: function () {

		var x = new Vector3();
		var y = new Vector3();
		var z = new Vector3();

		return function lookAt( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target );

			if ( z.lengthSq() === 0 ) {

				// eye and target are in the same position

				z.z = 1;

			}

			z.normalize();
			x.crossVectors( up, z );

			if ( x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					z.x += 0.0001;

				} else {

					z.z += 0.0001;

				}

				z.normalize();
				x.crossVectors( up, z );

			}

			x.normalize();
			y.crossVectors( z, x );

			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToBufferAttribute: function () {

		var v1 = new Vector3();

		return function applyToBufferAttribute( attribute ) {

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix4( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,	y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

	        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
	        te[ 1 ] = ( xy + wz ) * sx;
	        te[ 2 ] = ( xz - wy ) * sx;
	        te[ 3 ] = 0;

	        te[ 4 ] = ( xy - wz ) * sy;
	        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
	        te[ 6 ] = ( yz + wx ) * sy;
	        te[ 7 ] = 0;

	        te[ 8 ] = ( xz + wy ) * sz;
	        te[ 9 ] = ( yz - wx ) * sz;
	        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
	        te[ 11 ] = 0;

	        te[ 12 ] = position.x;
	        te[ 13 ] = position.y;
	        te[ 14 ] = position.z;
	        te[ 15 ] = 1;

	        return this;

	},

	decompose: function () {

		var vector = new Vector3();
		var matrix = new Matrix4();

		return function decompose( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) { sx = - sx; }

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			matrix.copy( this );

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) { return false; }

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this.onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this.onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this.onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this.onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	isQuaternion: true,

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) { this.onChangeCallback(); }

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// assumes direction vectors vFrom and vTo are normalized

		var v1 = new Vector3();
		var r;

		var EPS = 0.000001;

		return function setFromUnitVectors( vFrom, vTo ) {

			if ( v1 === undefined ) { v1 = new Vector3(); }

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			return this.normalize();

		};

	}(),

	angleTo: function ( q ) {

		return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

	},

	rotateTowards: function ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) { return this; }

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	},

	inverse: function () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) { return this; }
		if ( t === 1 ) { return this.copy( qb ); }

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			return this.normalize();

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion = new Quaternion();

		return function applyEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

		};

	}(),

	applyAxisAngle: function () {

		var quaternion = new Quaternion();

		return function applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	},

	unproject: function () {

		var matrix = new Matrix4();

		return function unproject( camera ) {

			return this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min = new Vector3();
		var max = new Vector3();

		return function clampScalar( minVal, maxVal ) {

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( vector ) {

		var scalar = vector.dot( this ) / vector.lengthSq();

		return this.copy( vector ).multiplyScalar( scalar );

	},

	projectOnPlane: function () {

		var v1 = new Vector3();

		return function projectOnPlane( planeNormal ) {

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1 = new Vector3();

		return function reflect( normal ) {

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	},

	setFromSphericalCoords: function ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	},

	setFromCylindricalCoords: function ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

}

Object.defineProperties( Vector2.prototype, {

	"width": {

		get: function () {

			return this.x;

		},

		set: function ( value ) {

			this.x = value;

		}

	},

	"height": {

		get: function () {

			return this.y;

		},

		set: function ( value ) {

			this.y = value;

		}

	}

} );

Object.assign( Vector2.prototype, {

	isVector2: true,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min = new Vector2();
		var max = new Vector2();

		return function clampScalar( minVal, maxVal ) {

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	cross: function ( v ) {

		return this.x * v.y - this.y * v.x;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( this.y, this.x );

		if ( angle < 0 ) { angle += 2 * Math.PI; }

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

function Color( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

}

Object.assign( Color.prototype, {

	isColor: true,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) { t += 1; }
			if ( t > 1 ) { t -= 1; }
			if ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }
			if ( t < 1 / 2 ) { return q; }
			if ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }
			return p;

		}

		return function setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = _Math.euclideanModulo( h, 1 );
			s = _Math.clamp( s, 0, 1 );
			l = _Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) { return; }

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function ( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	},

	convertLinearToGamma: function ( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	},

	copySRGBToLinear: function () {

		function SRGBToLinear( c ) {

			return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

		}

		return function copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		};

	}(),

	copyLinearToSRGB: function () {

		function LinearToSRGB( c ) {

			return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

		}

		return function copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		};

	}(),

	convertSRGBToLinear: function () {

		this.copySRGBToLinear( this );

		return this;

	},

	convertLinearToSRGB: function () {

		this.copyLinearToSRGB( this );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function () {

		var hsl = {};

		return function ( h, s, l ) {

			this.getHSL( hsl );

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		};

	}(),

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	sub: function ( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	lerpHSL: function () {

		var hslA = { h: 0, s: 0, l: 0 };
		var hslB = { h: 0, s: 0, l: 0 };

		return function lerpHSL( color, alpha ) {

			this.getHSL( hslA );
			color.getHSL( hslB );

			var h = _Math.lerp( hslA.h, hslB.h, alpha );
			var s = _Math.lerp( hslA.s, hslB.s, alpha );
			var l = _Math.lerp( hslA.l, hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		};

	}(),

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	},

	toJSON: function () {

		return this.getHex();

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) { this.version ++; }

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.itemSize : 0;
		this.array = array;

		return this;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) { offset = 0; }

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

var REVISION = '101';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;

var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) { this._listeners = {}; }

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) { return false; }

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) { return; }

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) { return; }

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = listenerArray.slice( 0 );

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Object.defineProperties( Euler.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this.onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this.onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this.onChangeCallback();

		}

	},

	order: {

		get: function () {

			return this._order;

		},

		set: function ( value ) {

			this._order = value;
			this.onChangeCallback();

		}

	}

} );

Object.assign( Euler.prototype, {

	isEuler: true,

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = _Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) { this.onChangeCallback(); }

		return this;

	},

	setFromQuaternion: function () {

		var matrix = new Matrix4();

		return function setFromQuaternion( q, order, update ) {

			matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( matrix, order, update );

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new Quaternion();

		return function reorder( newOrder ) {

			q.setFromEuler( this );

			return this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1 | 0;

}

Object.assign( Layers.prototype, {

	set: function ( channel ) {

		this.mask = 1 << channel | 0;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel | 0;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel | 0;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix3.prototype, {

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToBufferAttribute: function () {

		var v1 = new Vector3();

		return function applyToBufferAttribute( attribute ) {

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix3( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	multiply: function ( m ) {

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix && matrix.isMatrix4 ) {

			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

		var c = Math.cos( rotation );
		var s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

	},

	scale: function ( sx, sy ) {

		var te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	},

	rotate: function ( theta ) {

		var c = Math.cos( theta );
		var s = Math.sin( theta );

		var te = this.elements;

		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	},

	translate: function ( tx, ty ) {

		var te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) { return false; }

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) { offset = 0; }

		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) { array = []; }
		if ( offset === undefined ) { offset = 0; }

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId = 0;

function Object3D() {

	Object.defineProperty( this, 'id', { value: object3DId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new Quaternion();

		return function rotateOnAxis( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateOnWorldAxis: function () {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		var q1 = new Quaternion();

		return function rotateOnWorldAxis( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function rotateX( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function rotateY( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function rotateZ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new Vector3();

		return function translateOnAxis( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function translateX( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function translateY( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function translateZ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new Matrix4();

		return function worldToLocal( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This method does not support objects having non-uniformly-scaled parent(s)

		var q1 = new Quaternion();
		var m1 = new Matrix4();
		var target = new Vector3();
		var position = new Vector3();

		return function lookAt( x, y, z ) {

			if ( x.isVector3 ) {

				target.copy( x );

			} else {

				target.set( x, y, z );

			}

			var parent = this.parent;

			this.updateWorldMatrix( true, false );

			position.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				m1.lookAt( position, target, this.up );

			} else {

				m1.lookAt( target, position, this.up );

			}

			this.quaternion.setFromRotationMatrix( m1 );

			if ( parent ) {

				m1.extractRotation( parent.matrixWorld );
				q1.setFromRotationMatrix( m1 );
				this.quaternion.premultiply( q1.inverse() );

			}

		};

	}(),

	add: function ( object ) {
		var arguments$1 = arguments;


		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments$1[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {
		var arguments$1 = arguments;


		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments$1[ i ] );

			}

			return this;

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) { return this; }

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new Vector3();
		var scale = new Vector3();

		return function getWorldQuaternion( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
				target = new Quaternion();

			}

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, target, scale );

			return target;

		};

	}(),

	getWorldScale: function () {

		var position = new Vector3();
		var quaternion = new Quaternion();

		return function getWorldScale( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, target );

			return target;

		};

	}(),

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) { return; }

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) { object.name = this.name; }
		if ( this.castShadow === true ) { object.castShadow = true; }
		if ( this.receiveShadow === true ) { object.receiveShadow = true; }
		if ( this.visible === false ) { object.visible = false; }
		if ( this.frustumCulled === false ) { object.frustumCulled = false; }
		if ( this.renderOrder !== 0 ) { object.renderOrder = this.renderOrder; }
		if ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) { object.matrixAutoUpdate = false; }

		// object specific properties

		if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) { object.drawMode = this.drawMode; }

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			var parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				var shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( var i = 0, l = shapes.length; i < l; i ++ ) {

						var shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				var uuids = [];

				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			var shapes = extractFromCache( meta.shapes );

			if ( geometries.length > 0 ) { output.geometries = geometries; }
			if ( materials.length > 0 ) { output.materials = materials; }
			if ( textures.length > 0 ) { output.textures = textures; }
			if ( images.length > 0 ) { output.images = images; }
			if ( shapes.length > 0 ) { output.shapes = shapes; }

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) { recursive = true; }

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {

	Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

}

Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Scene,

	isScene: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		if ( source.background !== null ) { this.background = source.background.clone(); }
		if ( source.fog !== null ) { this.fog = source.fog.clone(); }
		if ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }
		if ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }

		return data;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var _canvas;

var ImageUtils = {

	getDataURL: function ( image ) {

		var canvas;

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		} else if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) { _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); }

			_canvas.width = image.width;
			_canvas.height = image.height;

			var context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId = 0;

function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : RGBAFormat;
	this.type = type !== undefined ? type : UnsignedByteType;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );
	this.center = new Vector2( 0, 0 );
	this.rotation = 0;

	this.matrixAutoUpdate = true;
	this.matrix = new Matrix3();

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Texture,

	isTexture: true,

	updateMatrix: function () {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		var output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = _Math.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				var url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( var i = 0, l = image.length; i < l; i ++ ) {

						url.push( ImageUtils.getDataURL( image[ i ] ) );

					}

				} else {

					// process single image

					url = ImageUtils.getDataURL( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) { return uv; }

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

} );

Object.defineProperty( Texture.prototype, "needsUpdate", {

	set: function ( value ) {

		if ( value === true ) { this.version ++; }

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

}

Object.assign( Box3.prototype, {

	isBox3: true,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) { minX = x; }
			if ( y < minY ) { minY = y; }
			if ( z < minZ ) { minZ = z; }

			if ( x > maxX ) { maxX = x; }
			if ( y > maxY ) { maxY = y; }
			if ( z > maxZ ) { maxZ = z; }

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromBufferAttribute: function ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) { minX = x; }
			if ( y < minY ) { minY = y; }
			if ( z < minZ ) { minZ = z; }

			if ( x > maxX ) { maxX = x; }
			if ( y > maxY ) { maxY = y; }
			if ( z > maxZ ) { maxZ = z; }

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector3();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function ( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	expandByObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var scope, i, l;

		var v1 = new Vector3();

		function traverse( node ) {

			var geometry = node.geometry;

			if ( geometry !== undefined ) {

				if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;

					for ( i = 0, l = vertices.length; i < l; i ++ ) {

						v1.copy( vertices[ i ] );
						v1.applyMatrix4( node.matrixWorld );

						scope.expandByPoint( v1 );

					}

				} else if ( geometry.isBufferGeometry ) {

					var attribute = geometry.attributes.position;

					if ( attribute !== undefined ) {

						for ( i = 0, l = attribute.count; i < l; i ++ ) {

							v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			}

		}

		return function expandByObject( object ) {

			scope = this;

			object.updateMatrixWorld( true );

			object.traverse( traverse );

			return this;

		};

	}(),

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	},

	getParameter: function ( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	},

	intersectsSphere: ( function () {

		var closestPoint = new Vector3();

		return function intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, closestPoint );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		};

	} )(),

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	},

	intersectsTriangle: ( function () {

		// triangle centered vertices
		var v0 = new Vector3();
		var v1 = new Vector3();
		var v2 = new Vector3();

		// triangle edge vectors
		var f0 = new Vector3();
		var f1 = new Vector3();
		var f2 = new Vector3();

		var testAxis = new Vector3();

		var center = new Vector3();
		var extents = new Vector3();

		var triangleNormal = new Vector3();

		function satForAxes( axes ) {

			var i, j;

			for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

				testAxis.fromArray( axes, i );
				// project the aabb onto the seperating axis
				var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
				// project all 3 vertices of the triangle onto the seperating axis
				var p0 = v0.dot( testAxis );
				var p1 = v1.dot( testAxis );
				var p2 = v2.dot( testAxis );
				// actual test, basically see if either of the most extreme of the triangle points intersects r
				if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

					// points of the projected triangle are outside the projected half-length of the aabb
					// the axis is seperating and we can exit
					return false;

				}

			}

			return true;

		}

		return function intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( center );
			extents.subVectors( this.max, center );

			// translate triangle to aabb origin
			v0.subVectors( triangle.a, center );
			v1.subVectors( triangle.b, center );
			v2.subVectors( triangle.c, center );

			// compute edge vectors for triangle
			f0.subVectors( v1, v0 );
			f1.subVectors( v2, v1 );
			f2.subVectors( v0, v2 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			var axes = [
				0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
				f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
				- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
			];
			if ( ! satForAxes( axes ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			triangleNormal.crossVectors( f0, f1 );
			axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
			return satForAxes( axes );

		};

	} )(),

	clampPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector3();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new Vector3();

		return function getBoundingSphere( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' );
				target = new Sphere();

			}

			this.getCenter( target.center );

			target.radius = this.getSize( v1 ).length() * 0.5;

			return target;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) { this.makeEmpty(); }

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3()
		];

		return function applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) { return this; }

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere( center, radius ) {

	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

}

Object.assign( Sphere.prototype, {

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new Box3();

		return function setFromPoints( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).getCenter( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	},

	clampPoint: function ( point, target ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	},

	getBoundingBox: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

} );

/**
 * @author bhouston / http://clara.io
 */

function Plane( normal, constant ) {

	// normal is assumed to be normalized

	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

}

Object.assign( Plane.prototype, {

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function setFromCoplanarPoints( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	},

	intersectLine: function () {

		var v1 = new Vector3();

		return function intersectLine( line, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new Vector3();
		var m1 = new Matrix3();

		return function applyMatrix4( matrix, optionalNormalMatrix ) {

			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()

	];

}

Object.assign( Frustum.prototype, {

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new Sphere();

		return function intersectsObject( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				{ geometry.computeBoundingSphere(); }

			sphere.copy( geometry.boundingSphere )
				.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSprite: function () {

		var sphere = new Sphere();

		return function intersectsSprite( sprite ) {

			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p = new Vector3();

		return function intersectsBox( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				var plane = planes[ i ];

				// corner at max distance

				p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( p ) < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),

	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

} );

var alphamap_fragment = /* glsl */"\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

var alphamap_pars_fragment = /* glsl */"\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";

var alphatest_fragment = /* glsl */"\n#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

var aomap_fragment = /* glsl */"\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n";

var aomap_pars_fragment = /* glsl */"\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n";

var begin_vertex = /* glsl */"\nvec3 transformed = vec3( position );\n";

var beginnormal_vertex = /* glsl */"\nvec3 objectNormal = vec3( normal );\n";

var bsdfs = /* glsl */"\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t// but who must be converted to luminous irradiance for surface lighting calculation\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\tif( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n#else\n\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n\treturn specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agüera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\n\t// Paper incorrect indicates coefficient is PI/21, and will\n\t// be corrected to 1/21 in future updates.\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

var bumpmap_pars_fragment = /* glsl */"\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n";

var clipping_planes_fragment = /* glsl */"\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n";

var clipping_planes_pars_fragment = /* glsl */"\n#if NUM_CLIPPING_PLANES > 0\n\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";

var clipping_planes_pars_vertex = /* glsl */"\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n";

var clipping_planes_vertex = /* glsl */"\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

var color_fragment = /* glsl */"\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n";

var color_pars_fragment = /* glsl */"\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";

var color_pars_vertex = /* glsl */"\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";

var color_vertex = /* glsl */"\n#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif\n";

var common = /* glsl */"\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n";

var cube_uv_reflection_fragment = /* glsl */"\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\t// float powScale = exp2(roughnessLevel + mipLevel);\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\n\tfloat rcpPowScale = 1.0 / powScale;\n\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\n\t// round to nearest mipmap if we are not interpolating.\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\n\t// Tri linear interpolation.\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n\tvec4 result = mix(color10, color20, t);\n\n\treturn vec4(result.rgb, 1.0);\n}\n\n#endif\n";

var defaultnormal_vertex = /* glsl */"\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n";

var displacementmap_pars_vertex = /* glsl */"\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n";

var displacementmap_vertex = /* glsl */"\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

var emissivemap_fragment = /* glsl */"\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";

var emissivemap_pars_fragment = /* glsl */"\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n";

var encodings_fragment = /* glsl */"\n  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

var encodings_pars_fragment = /* glsl */"\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n";

var envmap_fragment = /* glsl */"\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\tenvColor = envMapTexelToLinear( envColor );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";

var envmap_pars_fragment = /* glsl */"\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n";

var envmap_pars_vertex = /* glsl */"\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n";

var envmap_vertex = /* glsl */"\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n";

var fog_vertex = /* glsl */"\n#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n";

var fog_pars_vertex = /* glsl */"\n#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n";

var fog_fragment = /* glsl */"\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";

var fog_pars_fragment = /* glsl */"\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n";

var gradientmap_pars_fragment = /* glsl */"\n#ifdef TOON\n\n\tuniform sampler2D gradientMap;\n\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t\t// dotNL will be from -1.0 to 1.0\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t\t#ifdef USE_GRADIENTMAP\n\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t\t#else\n\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t\t#endif\n\n\n\t}\n\n#endif\n";

var lightmap_fragment = /* glsl */"\n#ifdef USE_LIGHTMAP\n\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";

var lightmap_pars_fragment = /* glsl */"\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n";

var lights_lambert_vertex = /* glsl */"\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\t// TODO (abelnation): implement\n\n\t}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\n#endif\n";

var lights_pars_begin = /* glsl */"\nuniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n";

var envmap_physical_pars_fragment = /* glsl */"\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n";

var lights_phong_fragment = /* glsl */"\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

var lights_phong_pars_fragment = /* glsl */"\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t#ifdef TOON\n\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#else\n\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\n\t#endif\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n";

var lights_physical_fragment = /* glsl */"\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

var lights_physical_pars_fragment = /* glsl */"\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t// Defer to the IndirectSpecular function to compute\n\t// the indirectDiffuse if energy preservation is enabled.\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#endif\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\n\t// Both indirect specular and diffuse light accumulate here\n\t// if energy preservation enabled, and PMREM provided.\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\t\t// The multiscattering paper uses the below formula for calculating diffuse \n\t\t// for dielectrics, but this is already handled when initially computing the \n\t\t// specular and diffuse color, so we can just use the diffuseColor directly.\n\t\t//vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\tvec3 diffuse = material.diffuseColor;\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n\t#else\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n\t#endif\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";

var lights_fragment_begin = /* glsl */"\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n";

var lights_fragment_maps = /* glsl */"\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tirradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n\n#endif\n";

var lights_fragment_end = /* glsl */"\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";

var logdepthbuf_fragment = /* glsl */"\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n";

var logdepthbuf_pars_fragment = /* glsl */"\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\n#endif\n";

var logdepthbuf_pars_vertex = /* glsl */"\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n";

var logdepthbuf_vertex = /* glsl */"\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n\t#else\n\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\tgl_Position.z *= gl_Position.w;\n\n\t#endif\n\n#endif\n";

var map_fragment = /* glsl */"\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n";

var map_pars_fragment = /* glsl */"\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n";

var map_particle_fragment = /* glsl */"\n#ifdef USE_MAP\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";

var map_particle_pars_fragment = /* glsl */"\n#ifdef USE_MAP\n\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n\n#endif\n";

var metalnessmap_fragment = /* glsl */"\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n";

var metalnessmap_pars_fragment = /* glsl */"\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n";

var morphnormal_vertex = /* glsl */"\n#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

var morphtarget_pars_vertex = /* glsl */"\n#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n";

var morphtarget_vertex = /* glsl */"\n#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n";

var normal_fragment_begin = /* glsl */"\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n#endif\n";

var normal_fragment_maps = /* glsl */"\n#ifdef USE_NORMALMAP\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t\t#ifdef FLIP_SIDED\n\n\t\t\tnormal = - normal;\n\n\t\t#endif\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tnormal = normalize( normalMatrix * normal );\n\n\t#else // tangent-space normal map\n\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";

var normalmap_pars_fragment = /* glsl */"\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tuniform mat3 normalMatrix;\n\n\t#else\n\n\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t\treturn normalize( tsn * mapN );\n\n\t\t}\n\n\t#endif\n\n#endif\n";

var packing = /* glsl */"\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

var premultiplied_alpha_fragment = /* glsl */"\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";

var project_vertex = /* glsl */"\nvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n";

var dithering_fragment = /* glsl */"\n#if defined( DITHERING )\n\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n";

var dithering_pars_fragment = /* glsl */"\n#if defined( DITHERING )\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n";

var roughnessmap_fragment = /* glsl */"\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n";

var roughnessmap_pars_fragment = /* glsl */"\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n";

var shadowmap_pars_fragment = /* glsl */"\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n";

var shadowmap_pars_vertex = /* glsl */"\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n";

var shadowmap_vertex = /* glsl */"\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n";

var shadowmask_pars_fragment = /* glsl */"\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n";

var skinbase_vertex = /* glsl */"\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n";

var skinning_pars_vertex = /* glsl */"\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";

var skinning_vertex = /* glsl */"\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n";

var skinnormal_vertex = /* glsl */"\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

var specularmap_fragment = /* glsl */"\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n";

var specularmap_pars_fragment = /* glsl */"\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n";

var tonemapping_fragment = /* glsl */"\n#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";

var tonemapping_pars_fragment = /* glsl */"\n#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}\n";

var uv_pars_fragment = /* glsl */"\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n";

var uv_pars_vertex = /* glsl */"\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n\n#endif\n";

var uv_vertex = /* glsl */"\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n";

var uv2_pars_fragment = /* glsl */"\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n";

var uv2_pars_vertex = /* glsl */"\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif\n";

var uv2_vertex = /* glsl */"\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif\n";

var worldpos_vertex = /* glsl */"\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n";

var background_frag = /* glsl */"\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n";

var background_vert = /* glsl */"\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n";

var cube_frag = /* glsl */"\nuniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\nvoid main() {\n\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n";

var cube_vert = /* glsl */"\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n";

var depth_frag = /* glsl */"\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\n\t#endif\n\n}\n";

var depth_vert = /* glsl */"\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n";

var distanceRGBA_frag = /* glsl */"\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n";

var distanceRGBA_vert = /* glsl */"\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n";

var equirect_frag = /* glsl */"\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n";

var equirect_vert = /* glsl */"\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n";

var linedashed_frag = /* glsl */"\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

var linedashed_vert = /* glsl */"\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\n\tvLineDistance = scale * lineDistance;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n";

var meshbasic_frag = /* glsl */"\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

var meshbasic_vert = /* glsl */"\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

var meshlambert_frag = /* glsl */"\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

var meshlambert_vert = /* glsl */"\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

var meshmatcap_frag = /* glsl */"\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

var meshmatcap_vert = /* glsl */"\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\tvNormal = normalize( transformedNormal );\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n";

var meshphong_frag = /* glsl */"\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n";

var meshphong_vert = /* glsl */"\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

var meshphysical_frag = /* glsl */"\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n";

var meshphysical_vert = /* glsl */"\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

var normal_frag = /* glsl */"\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n";

var normal_vert = /* glsl */"\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n";

var points_frag = /* glsl */"\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

var points_vert = /* glsl */"\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n";

var shadow_frag = /* glsl */"\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <fog_fragment>\n\n}\n";

var shadow_vert = /* glsl */"\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

var sprite_frag = /* glsl */"\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

var sprite_vert = /* glsl */"\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n";

var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normalmap_pars_fragment: normalmap_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_frag: background_frag,
	background_vert: background_vert,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshmatcap_frag: meshmatcap_frag,
	meshmatcap_vert: meshmatcap_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert,
	sprite_frag: sprite_frag,
	sprite_vert: sprite_vert
};

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	var dst = {};

	for ( var u in src ) {

		dst[ u ] = {};

		for ( var p in src[ u ] ) {

			var property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	var merged = {};

	for ( var u = 0; u < uniforms.length; u ++ ) {

		var tmp = cloneUniforms( uniforms[ u ] );

		for ( var p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		uvTransform: { value: new Matrix3() }

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 0.5 },
				metalness: { value: 0.5 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			} ] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearCoat: { value: 0 },
			clearCoatRoughness: { value: 0 }
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAnimation() {

	var context = null;
	var isAnimating = false;
	var animationLoop = null;

	function onAnimationFrame( time, frame ) {

		if ( isAnimating === false ) { return; }

		animationLoop( time, frame );

		context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) { return; }
			if ( animationLoop === null ) { return; }

			context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAttributes( gl ) {

	var buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		var array = attribute.array;
		var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		var buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		var type = gl.FLOAT;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			type = gl.UNSIGNED_SHORT;

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		var array = attribute.array;
		var updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( attribute.dynamic === false ) {

			gl.bufferData( bufferType, array, gl.STATIC_DRAW );

		} else if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else if ( updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

		var data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

		var data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = ( color && color.isColor ) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

}

Object.assign( Face3.prototype, {

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var geometryId = 0; // Geometry uses even numbers as Id

function Geometry() {

	Object.defineProperty( this, 'id', { value: geometryId += 2 } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Geometry,

	isGeometry: true,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1 = new Matrix4();

		return function rotateX( angle ) {

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1 = new Matrix4();

		return function rotateY( angle ) {

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1 = new Matrix4();

		return function rotateZ( angle ) {

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1 = new Matrix4();

		return function translate( x, y, z ) {

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1 = new Matrix4();

		return function scale( x, y, z ) {

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj = new Object3D();

		return function lookAt( vector ) {

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) { this.faceVertexUvs[ 1 ] = []; }

		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			scope.vertices.push( new Vector3().fromArray( positions, i ) );

			if ( colors !== undefined ) {

				scope.colors.push( new Color().fromArray( colors, i ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexColors = ( colors === undefined ) ? [] : [
				scope.colors[ a ].clone(),
				scope.colors[ b ].clone(),
				scope.colors[ c ].clone() ];

			var vertexNormals = ( normals === undefined ) ? [] : [
				new Vector3().fromArray( normals, a * 3 ),
				new Vector3().fromArray( normals, b * 3 ),
				new Vector3().fromArray( normals, c * 3 )
			];

			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [
					new Vector2().fromArray( uvs, a * 2 ),
					new Vector2().fromArray( uvs, b * 2 ),
					new Vector2().fromArray( uvs, c * 2 )
				] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [
					new Vector2().fromArray( uvs2, a * 2 ),
					new Vector2().fromArray( uvs2, b * 2 ),
					new Vector2().fromArray( uvs2, c * 2 )
				] );

			}

		}

		var groups = geometry.groups;

		if ( groups.length > 0 ) {

			for ( var i = 0; i < groups.length; i ++ ) {

				var group = groups[ i ];

				var start = group.start;
				var count = group.count;

				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

					if ( indices !== undefined ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

					} else {

						addFace( j, j + 1, j + 2, group.materialIndex );

					}

				}

			}

		} else {

			if ( indices !== undefined ) {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			} else {

				for ( var i = 0; i < positions.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		var offset = new Vector3();

		return function center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( offset ).negate();

			this.translate( offset.x, offset.y, offset.z );

			return this;

		};

	}(),

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new Vector3(), ab = new Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) { areaWeighted = true; }

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		var f, fl, face;

		this.computeFaceNormals();

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) { face.__originalVertexNormals = []; }

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( ! ( geometry && geometry.isGeometry ) ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ],
			colors1 = this.colors,
			colors2 = geometry.colors;

		if ( materialIndexOffset === undefined ) { materialIndexOffset = 0; }

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) { vertexCopy.applyMatrix4( matrix ); }

			vertices1.push( vertexCopy );

		}

		// colors

		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( ! ( mesh && mesh.isMesh ) ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		if ( mesh.matrixAutoUpdate ) { mesh.updateMatrix(); }

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	setFromPoints: function ( points ) {

		this.vertices = [];

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return this;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) { newUvs1 = []; }
		if ( uvs2 && uvs2.length === length ) { newUvs2 = []; }

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) { newUvs1.push( uvs1[ id ] ); }
			if ( newUvs2 ) { newUvs2.push( uvs2[ id ] ); }

		}

		if ( newUvs1 ) { this.faceVertexUvs[ 0 ] = newUvs1; }
		if ( newUvs2 ) { this.faceVertexUvs[ 1 ] = newUvs2; }

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) { data.name = this.name; }

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) { data.data.colors = colors; }
		if ( uvs.length > 0 ) { data.data.uvs = [ uvs ]; } // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		var i, il, j, jl, k, kl;

		// reset

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// vertices

		var vertices = source.vertices;

		for ( i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		// colors

		var colors = source.colors;

		for ( i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		// faces

		var faces = source.faces;

		for ( i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		// face vertex uvs

		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		// morph targets

		var morphTargets = source.morphTargets;

		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;

			// vertices

			if ( morphTargets[ i ].vertices !== undefined ) {

				morphTarget.vertices = [];

				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

				}

			}

			// normals

			if ( morphTargets[ i ].normals !== undefined ) {

				morphTarget.normals = [];

				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

				}

			}

			this.morphTargets.push( morphTarget );

		}

		// morph normals

		var morphNormals = source.morphNormals;

		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

			var morphNormal = {};

			// vertex normals

			if ( morphNormals[ i ].vertexNormals !== undefined ) {

				morphNormal.vertexNormals = [];

				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					var destVertexNormal = {};

					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();

					morphNormal.vertexNormals.push( destVertexNormal );

				}

			}

			// face normals

			if ( morphNormals[ i ].faceNormals !== undefined ) {

				morphNormal.faceNormals = [];

				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

				}

			}

			this.morphNormals.push( morphNormal );

		}

		// skin weights

		var skinWeights = source.skinWeights;

		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

			this.skinWeights.push( skinWeights[ i ].clone() );

		}

		// skin indices

		var skinIndices = source.skinIndices;

		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

			this.skinIndices.push( skinIndices[ i ].clone() );

		}

		// line distances

		var lineDistances = source.lineDistances;

		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

			this.lineDistances.push( lineDistances[ i ] );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// update flags

		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {

	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( DirectGeometry.prototype, {

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex = undefined;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = {
					name: morphTargets[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = {
					name: morphNormals[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		if ( vertices.length > 0 && faces.length === 0 ) {

			console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

		}

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax( array ) {

	if ( array.length === 0 ) { return - Infinity; }

	var max = array[ 0 ];

	for ( var i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) { max = array[ i ]; }

	}

	return max;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

	},

	addAttribute: function ( name, attribute ) {

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return this;

		}

		this.attributes[ name ] = attribute;

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToBufferAttribute( position );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToBufferAttribute( normal );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1 = new Matrix4();

		return function rotateX( angle ) {

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1 = new Matrix4();

		return function rotateY( angle ) {

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1 = new Matrix4();

		return function rotateZ( angle ) {

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1 = new Matrix4();

		return function translate( x, y, z ) {

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1 = new Matrix4();

		return function scale( x, y, z ) {

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj = new Object3D();

		return function lookAt( vector ) {

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		var offset = new Vector3();

		return function center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( offset ).negate();

			this.translate( offset.x, offset.y, offset.z );

			return this;

		};

	}(),

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	setFromPoints: function ( points ) {

		var position = [];

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object.isMesh ) {

			var direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		var attribute;

		if ( geometry.verticesNeedUpdate === true ) {

			attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
				attribute.name = morphTarget.name;

				array.push( attribute.copyVector3sArray( morphTarget.data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		var position = this.attributes.position;

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		var box = new Box3();
		var vector = new Vector3();

		return function computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			var position = this.attributes.position;

			if ( position ) {

				var center = this.boundingSphere.center;

				box.setFromBufferAttribute( position );
				box.getCenter( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = position.count; i < il; i ++ ) {

					vector.x = position.getX( i );
					vector.y = position.getY( i );
					vector.z = position.getZ( i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				for ( var i = 0, il = index.count; i < il; i += 3 ) {

					vA = indices[ i + 0 ] * 3;
					vB = indices[ i + 1 ] * 3;
					vC = indices[ i + 2 ] * 3;

					pA.fromArray( positions, vA );
					pB.fromArray( positions, vB );
					pC.fromArray( positions, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ vA ] += cb.x;
					normals[ vA + 1 ] += cb.y;
					normals[ vA + 2 ] += cb.z;

					normals[ vB ] += cb.x;
					normals[ vB + 1 ] += cb.y;
					normals[ vB + 2 ] += cb.z;

					normals[ vC ] += cb.x;
					normals[ vC + 1 ] += cb.y;
					normals[ vC + 2 ] += cb.z;

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) { continue; }

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var vector = new Vector3();

		return function normalizeNormals() {

			var normals = this.attributes.normal;

			for ( var i = 0, il = normals.count; i < il; i ++ ) {

				vector.x = normals.getX( i );
				vector.y = normals.getY( i );
				vector.z = normals.getZ( i );

				vector.normalize();

				normals.setXYZ( i, vector.x, vector.y, vector.z );

			}

		};

	}(),

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		// attributes

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.addAttribute( name, newAttribute );

		}

		// morph attributes

		var morphAttributes = this.morphAttributes;

		for ( name in morphAttributes ) {

			var morphArray = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

				var attribute = morphAttribute[ i ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		// groups

		var groups = this.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) { data.name = this.name; }
		if ( Object.keys( this.userData ).length > 0 ) { data.userData = this.userData; }

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var name, i, l;

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// index

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		var attributes = source.attributes;

		for ( name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		// morph attributes

		var morphAttributes = source.morphAttributes;

		for ( name in morphAttributes ) {

			var array = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone() );

			}

			this.morphAttributes[ name ] = array;

		}

		// groups

		var groups = source.groups;

		for ( i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// BoxGeometry

function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();

}

BoxGeometry.prototype = Object.create( Geometry.prototype );
BoxGeometry.prototype.constructor = BoxGeometry;

// BoxBufferGeometry

function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	BufferGeometry.call( this );

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	width = width || 1;
	height = height || 1;
	depth = depth || 1;

	// segments

	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var numberOfVertices = 0;
	var groupStart = 0;

	// build each side of the box geometry

	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
	buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
	buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
	buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
	buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

		var segmentWidth = width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var ix, iy;

		var vector = new Vector3();

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segmentHeight - heightHalf;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segmentWidth - widthHalf;

				// set values to correct vector component

				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;

				// now apply vector to vertex buffer

				vertices.push( vector.x, vector.y, vector.z );

				// set values to correct vector component

				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;

				// now apply vector to normal buffer

				normals.push( vector.x, vector.y, vector.z );

				// uvs

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

				// counters

				vertexCounter += 1;

			}

		}

		// indices

		// 1. you need three indices to draw a single face
		// 2. a single segment consists of two faces
		// 3. so we need to generate six (2*3) indices per segment

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// increase counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, materialIndex );

		// calculate new start value for groups

		groupStart += groupCount;

		// update total number of vertices

		numberOfVertices += vertexCounter;

	}

}

BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// PlaneGeometry

function PlaneGeometry( width, height, widthSegments, heightSegments ) {

	Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	this.mergeVertices();

}

PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;

// PlaneBufferGeometry

function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

	BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	width = width || 1;
	height = height || 1;

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var ix, iy;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices.push( x, - y, 0 );

			normals.push( 0, 0, 1 );

			uvs.push( ix / gridX );
			uvs.push( 1 - ( iy / gridY ) );

		}

	}

	// indices

	for ( iy = 0; iy < gridY; iy ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;
	this.lights = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.flatShading = false;
	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.userData = {};

	this.needsUpdate = true;

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function () {},

	setValues: function ( values ) {

		if ( values === undefined ) { return; }

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) { data.name = this.name; }

		if ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }

		if ( this.roughness !== undefined ) { data.roughness = this.roughness; }
		if ( this.metalness !== undefined ) { data.metalness = this.metalness; }

		if ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }
		if ( this.emissiveIntensity !== 1 ) { data.emissiveIntensity = this.emissiveIntensity; }

		if ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }
		if ( this.shininess !== undefined ) { data.shininess = this.shininess; }
		if ( this.clearCoat !== undefined ) { data.clearCoat = this.clearCoat; }
		if ( this.clearCoatRoughness !== undefined ) { data.clearCoatRoughness = this.clearCoatRoughness; }

		if ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }
		if ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }
		if ( this.lightMap && this.lightMap.isTexture ) { data.lightMap = this.lightMap.toJSON( meta ).uuid; }

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }
		if ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }

		if ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }
		if ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

			if ( this.combine !== undefined ) { data.combine = this.combine; }
			if ( this.envMapIntensity !== undefined ) { data.envMapIntensity = this.envMapIntensity; }

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) { data.size = this.size; }
		if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

		if ( this.blending !== NormalBlending ) { data.blending = this.blending; }
		if ( this.flatShading === true ) { data.flatShading = this.flatShading; }
		if ( this.side !== FrontSide ) { data.side = this.side; }
		if ( this.vertexColors !== NoColors ) { data.vertexColors = this.vertexColors; }

		if ( this.opacity < 1 ) { data.opacity = this.opacity; }
		if ( this.transparent === true ) { data.transparent = this.transparent; }

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		// rotation (SpriteMaterial)
		if ( this.rotation !== 0 ) { data.rotation = this.rotation; }

		if ( this.polygonOffset === true ) { data.polygonOffset = true; }
		if ( this.polygonOffsetFactor !== 0 ) { data.polygonOffsetFactor = this.polygonOffsetFactor; }
		if ( this.polygonOffsetUnits !== 0 ) { data.polygonOffsetUnits = this.polygonOffsetUnits; }

		if ( this.linewidth !== 1 ) { data.linewidth = this.linewidth; }
		if ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }
		if ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }
		if ( this.scale !== undefined ) { data.scale = this.scale; }

		if ( this.dithering === true ) { data.dithering = true; }

		if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
		if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

		if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
		if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
		if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
		if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

		if ( this.morphTargets === true ) { data.morphTargets = true; }
		if ( this.skinning === true ) { data.skinning = true; }

		if ( this.visible === false ) { data.visible = false; }
		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) { data.textures = textures; }
			if ( images.length > 0 ) { data.images = images; }

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;
		this.lights = source.lights;

		this.blending = source.blending;
		this.side = source.side;
		this.flatShading = source.flatShading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;
		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.clipShadows = source.clipShadows;
		this.clipIntersection = source.clipIntersection;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				{ dstPlanes[ i ] = srcPlanes[ i ].clone(); }

		}

		this.clippingPlanes = dstPlanes;

		this.shadowSide = source.shadowSide;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = cloneUniforms( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = Material.prototype.toJSON.call( this, meta );

	data.uniforms = {};

	for ( var name in this.uniforms ) {

		var uniform = this.uniforms[ name ];
		var value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) { data.defines = this.defines; }

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	var extensions = {};

	for ( var key in this.extensions ) {

		if ( this.extensions[ key ] === true ) { extensions[ key ] = true; }

	}

	if ( Object.keys( extensions ).length > 0 ) { data.extensions = extensions; }

	return data;

};

/**
 * @author bhouston / http://clara.io
 */

function Ray( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3();

}

Object.assign( Ray.prototype, {

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function () {

		var v1 = new Vector3();

		return function recast( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		target.subVectors( point, this.origin );

		var directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new Vector3();

		return function distanceSqToPoint( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new Vector3();
		var segDir = new Vector3();
		var diff = new Vector3();

		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),

	intersectSphere: function () {

		var v1 = new Vector3();

		return function intersectSphere( sphere, target ) {

			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) { return null; }

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) { return null; }

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) { return this.at( t1, target ); }

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	},

	intersectPlane: function ( plane, target ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	},

	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, target ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }

		if ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }

		if ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }

		if ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) { return null; }

		return this.at( tmin >= 0 ? tmin : tmax, target );

	},

	intersectsBox: ( function () {

		var v = new Vector3();

		return function intersectsBox( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	} )(),

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new Vector3();
		var edge1 = new Vector3();
		var edge2 = new Vector3();
		var normal = new Vector3();

		return function intersectTriangle( a, b, c, backfaceCulling, target ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) { return null; }
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();

}

Object.assign( Triangle, {

	getNormal: function () {

		var v0 = new Vector3();

		return function getNormal( a, b, c, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getNormal() target is now required' );
				target = new Vector3();

			}

			target.subVectors( c, b );
			v0.subVectors( a, b );
			target.cross( v0 );

			var targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		};

	}(),

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	getBarycoord: function () {

		var v0 = new Vector3();
		var v1 = new Vector3();
		var v2 = new Vector3();

		return function getBarycoord( point, a, b, c, target ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
				target = new Vector3();

			}

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		};

	}(),

	containsPoint: function () {

		var v1 = new Vector3();

		return function containsPoint( point, a, b, c ) {

			Triangle.getBarycoord( point, a, b, c, v1 );

			return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

		};

	}(),

	getUV: function () {

		var barycoord = new Vector3();

		return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

			this.getBarycoord( point, p1, p2, p3, barycoord );

			target.set( 0, 0 );
			target.addScaledVector( uv1, barycoord.x );
			target.addScaledVector( uv2, barycoord.y );
			target.addScaledVector( uv3, barycoord.z );

			return target;

		};

	}()

} );

Object.assign( Triangle.prototype, {

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	getArea: function () {

		var v0 = new Vector3();
		var v1 = new Vector3();

		return function getArea() {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	getMidpoint: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	getNormal: function ( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	},

	getPlane: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Vector3();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	getBarycoord: function ( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	},

	containsPoint: function ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	getUV: function ( point, uv1, uv2, uv3, result ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );

	},

	intersectsBox: function ( box ) {

		return box.intersectsTriangle( this );

	},

	closestPointToPoint: function () {

		var vab = new Vector3();
		var vac = new Vector3();
		var vbc = new Vector3();
		var vap = new Vector3();
		var vbp = new Vector3();
		var vcp = new Vector3();

		return function closestPointToPoint( p, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			var a = this.a, b = this.b, c = this.c;
			var v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			vab.subVectors( b, a );
			vac.subVectors( c, a );
			vap.subVectors( p, a );
			var d1 = vab.dot( vap );
			var d2 = vac.dot( vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			vbp.subVectors( p, b );
			var d3 = vab.dot( vbp );
			var d4 = vac.dot( vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			var vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( vab, v );

			}

			vcp.subVectors( p, c );
			var d5 = vab.dot( vcp );
			var d6 = vac.dot( vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			var vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( vac, w );

			}

			var va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC

			}

			// face region
			var denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;
			return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );

		};

	}(),

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.lights = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.drawMode = TrianglesDrawMode;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	setDrawMode: function ( value ) {

		this.drawMode = value;

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.drawMode = source.drawMode;

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		return this;

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		var vA = new Vector3();
		var vB = new Vector3();
		var vC = new Vector3();

		var tempA = new Vector3();
		var tempB = new Vector3();
		var tempC = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		var intersectionPoint = new Vector3();
		var intersectionPointWorld = new Vector3();

		function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

			var intersect;

			if ( material.side === BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

			}

			if ( intersect === null ) { return null; }

			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) { return null; }

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {

			vA.fromBufferAttribute( position, a );
			vB.fromBufferAttribute( position, b );
			vC.fromBufferAttribute( position, c );

			var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

			if ( intersection ) {

				if ( uv ) {

					uvA.fromBufferAttribute( uv, a );
					uvB.fromBufferAttribute( uv, b );
					uvC.fromBufferAttribute( uv, c );

					intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );

				}

				var face = new Face3( a, b, c );
				Triangle.getNormal( vA, vB, vC, face.normal );

				intersection.face = face;

			}

			return intersection;

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) { return; }

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( ray.intersectsBox( geometry.boundingBox ) === false ) { return; }

			}

			var intersection;

			if ( geometry.isBufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var position = geometry.attributes.position;
				var uv = geometry.attributes.uv;
				var groups = geometry.groups;
				var drawRange = geometry.drawRange;
				var i, j, il, jl;
				var group, groupMaterial;
				var start, end;

				if ( index !== null ) {

					// indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( i = 0, il = groups.length; i < il; i ++ ) {

							group = groups[ i ];
							groupMaterial = material[ group.materialIndex ];

							start = Math.max( group.start, drawRange.start );
							end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( j = start, jl = end; j < jl; j += 3 ) {

								a = index.getX( j );
								b = index.getX( j + 1 );
								c = index.getX( j + 2 );

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						start = Math.max( 0, drawRange.start );
						end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

						for ( i = start, il = end; i < il; i += 3 ) {

							a = index.getX( i );
							b = index.getX( i + 1 );
							c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( position !== undefined ) {

					// non-indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( i = 0, il = groups.length; i < il; i ++ ) {

							group = groups[ i ];
							groupMaterial = material[ group.materialIndex ];

							start = Math.max( group.start, drawRange.start );
							end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( j = start, jl = end; j < jl; j += 3 ) {

								a = j;
								b = j + 1;
								c = j + 2;

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						start = Math.max( 0, drawRange.start );
						end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

						for ( i = start, il = end; i < il; i += 3 ) {

							a = i;
							b = i + 1;
							c = i + 2;

							intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				var fvA, fvB, fvC;
				var isMultiMaterial = Array.isArray( material );

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var uvs;

				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) { uvs = faceVertexUvs; }

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) { continue; }

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) { continue; }

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

						}

						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );

						fvA = vA;
						fvB = vB;
						fvC = vC;

					}

					intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

					if ( intersection ) {

						if ( uvs && uvs[ f ] ) {

							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );

							intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

	var clearColor = new Color( 0x000000 );
	var clearAlpha = 0;

	var planeMesh;
	var boxMesh;
	// Store the current background texture and its `version`
	// so we can recompile the material accordingly.
	var currentBackground = null;
	var currentBackgroundVersion = 0;

	function render( renderList, scene, camera, forceClear ) {

		var background = scene.background;

		if ( background === null ) {

			setClear( clearColor, clearAlpha );
			currentBackground = null;
			currentBackgroundVersion = 0;

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;
			currentBackground = null;
			currentBackgroundVersion = 0;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxBufferGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						type: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.removeAttribute( 'normal' );
				boxMesh.geometry.removeAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'map', {

					get: function () {

						return this.uniforms.tCube.value;

					}

				} );

				objects.update( boxMesh );

			}

			var texture = background.isWebGLRenderTargetCube ? background.texture : background;
			boxMesh.material.uniforms.tCube.value = texture;
			boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;

			if ( currentBackground !== background ||
			     currentBackgroundVersion !== texture.version ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = texture.version;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new ShaderMaterial( {
						type: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.removeAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				   currentBackgroundVersion !== background.version ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha ) {

			clearColor.set( color );
			clearAlpha = alpha !== undefined ? alpha : 1;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode );

	}

	function renderInstances( geometry, start, count ) {

		var extension;

		if ( capabilities.isWebGL2 ) {

			extension = gl;

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );

		info.update( count, mode, geometry.maxInstancedCount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) { return maxAnisotropy; }

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;

	var maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

/**
 * @author tschw
 */

function WebGLClipping() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;

		return dstArray;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions( gl ) {

	var extensions = {};

	return {

		get: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries( gl, attributes, info ) {

	var geometries = {};
	var wireframeAttributes = {};

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry.index !== null ) {

			attributes.remove( buffergeometry.index );

		}

		for ( var name in buffergeometry.attributes ) {

			attributes.remove( buffergeometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		var attribute = wireframeAttributes[ buffergeometry.id ];

		if ( attribute ) {

			attributes.remove( attribute );
			delete wireframeAttributes[ buffergeometry.id ];

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry ) { return buffergeometry; }

		geometry.addEventListener( 'dispose', onGeometryDispose );

		if ( geometry.isBufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry.isGeometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		info.memory.geometries ++;

		return buffergeometry;

	}

	function update( geometry ) {

		var index = geometry.index;
		var geometryAttributes = geometry.attributes;

		if ( index !== null ) {

			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], gl.ARRAY_BUFFER );

			}

		}

	}

	function getWireframeAttribute( geometry ) {

		var attribute = wireframeAttributes[ geometry.id ];

		if ( attribute ) { return attribute; }

		var indices = [];

		var geometryIndex = geometry.index;
		var geometryAttributes = geometry.attributes;

		// console.time( 'wireframe' );

		if ( geometryIndex !== null ) {

			var array = geometryIndex.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			var array = geometryAttributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

		attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

		wireframeAttributes[ geometry.id ] = attribute;

		return attribute;

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode );

	}

	function renderInstances( geometry, start, count ) {

		var extension;

		if ( capabilities.isWebGL2 ) {

			extension = gl;

		} else {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

		info.update( count, mode, geometry.maxInstancedCount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLInfo( gl ) {

	var memory = {
		geometries: 0,
		textures: 0
	};

	var render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		instanceCount = instanceCount || 1;

		render.calls ++;

		switch ( mode ) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case gl.TRIANGLE_STRIP:
			case gl.TRIANGLE_FAN:
				render.triangles += instanceCount * ( count - 2 );
				break;

			case gl.LINES:
				render.lines += instanceCount * ( count / 2 );
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * ( count - 1 );
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	var influencesList = {};
	var morphInfluences = new Float32Array( 8 );

	function update( object, geometry, material, program ) {

		var objectInfluences = object.morphTargetInfluences;

		var length = objectInfluences.length;

		var influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( var i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		var morphTargets = material.morphTargets && geometry.morphAttributes.position;
		var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		// Remove current morphAttributes

		for ( var i = 0; i < length; i ++ ) {

			var influence = influences[ i ];

			if ( influence[ 1 ] !== 0 ) {

				if ( morphTargets ) { geometry.removeAttribute( 'morphTarget' + i ); }
				if ( morphNormals ) { geometry.removeAttribute( 'morphNormal' + i ); }

			}

		}

		// Collect influences

		for ( var i = 0; i < length; i ++ ) {

			var influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		// Add morphAttributes

		for ( var i = 0; i < 8; i ++ ) {

			var influence = influences[ i ];

			if ( influence ) {

				var index = influence[ 0 ];
				var value = influence[ 1 ];

				if ( value ) {

					if ( morphTargets ) { geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] ); }
					if ( morphNormals ) { geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] ); }

					morphInfluences[ i ] = value;
					continue;

				}

			}

			morphInfluences[ i ] = 0;

		}

		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects( geometries, info ) {

	var updateList = {};

	function update( object ) {

		var frame = info.render.frame;

		var geometry = object.geometry;
		var buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateList[ buffergeometry.id ] !== frame ) {

			if ( geometry.isGeometry ) {

				buffergeometry.updateFromObject( object );

			}

			geometries.update( buffergeometry );

			updateList[ buffergeometry.id ] = frame;

		}

		return buffergeometry;

	}

	function dispose() {

		updateList = {};

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

/**
 * @author Artur Trzesiok
 */

function DataTexture3D( data, width, height, depth ) {

	// We're going to add .setXXX() methods for setting properties later.
	// Users can still set in DataTexture3D directly.
	//
	//	var texture = new THREE.DataTexture3D( data, width, height, depth );
	// 	texture.anisotropy = 16;
	//
	// See #14839

	Texture.call( this, null );

	this.image = { data: data, width: width, height: height, depth: depth };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.generateMipmaps = false;
	this.flipY = false;

}

DataTexture3D.prototype = Object.create( Texture.prototype );
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;

/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();

// --- Base for inner nodes (including the root) ---

function UniformContainer() {

	this.seq = [];
	this.map = {};

}

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array( 16 );
var mat3array = new Float32Array( 9 );
var mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	var firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) { return array; }
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) { return false; }

	for ( var i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) { return false; }

	}

	return true;

}

function copyArray( a, b ) {

	for ( var i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( renderer, n ) {

	var r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( var i = 0; i !== n; ++ i )
		{ r[ i ] = renderer.allocTextureUnit(); }

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValue1f( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) { return; }

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

function setValue1i( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) { return; }

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValue2fv( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValue3fv( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValue4fv( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or MatrixN)

function setValue2fm( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) { return; }

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValue3fm( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) { return; }

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValue4fm( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) { return; }

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) { return; }

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single texture (2D / Cube)

function setValueT1( gl, v, renderer ) {

	var cache = this.cache;
	var unit = renderer.allocTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	renderer.setTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, renderer ) {

	var cache = this.cache;
	var unit = renderer.allocTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	renderer.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, renderer ) {

	var cache = this.cache;
	var unit = renderer.allocTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	renderer.setTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValue2iv( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) { return; }

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValue3iv( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) { return; }

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValue4iv( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) { return; }

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1f; // FLOAT
		case 0x8b50: return setValue2fv; // _VEC2
		case 0x8b51: return setValue3fv; // _VEC3
		case 0x8b52: return setValue4fv; // _VEC4

		case 0x8b5a: return setValue2fm; // _MAT2
		case 0x8b5b: return setValue3fm; // _MAT3
		case 0x8b5c: return setValue4fm; // _MAT4

		case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
		case 0x8B5F: return setValueT3D1; // SAMPLER_3D
		case 0x8b60: return setValueT6; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// Array of scalars

function setValue1fv( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) { return; }

	gl.uniform1fv( this.addr, v );

	copyArray( cache, v );

}
function setValue1iv( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) { return; }

	gl.uniform1iv( this.addr, v );

	copyArray( cache, v );

}

// Array of vectors (flat or from THREE classes)

function setValueV2a( gl, v ) {

	var cache = this.cache;
	var data = flatten( v, this.size, 2 );

	if ( arraysEqual( cache, data ) ) { return; }

	gl.uniform2fv( this.addr, data );

	this.updateCache( data );

}

function setValueV3a( gl, v ) {

	var cache = this.cache;
	var data = flatten( v, this.size, 3 );

	if ( arraysEqual( cache, data ) ) { return; }

	gl.uniform3fv( this.addr, data );

	this.updateCache( data );

}

function setValueV4a( gl, v ) {

	var cache = this.cache;
	var data = flatten( v, this.size, 4 );

	if ( arraysEqual( cache, data ) ) { return; }

	gl.uniform4fv( this.addr, data );

	this.updateCache( data );

}

// Array of matrices (flat or from THREE clases)

function setValueM2a( gl, v ) {

	var cache = this.cache;
	var data = flatten( v, this.size, 4 );

	if ( arraysEqual( cache, data ) ) { return; }

	gl.uniformMatrix2fv( this.addr, false, data );

	this.updateCache( data );

}

function setValueM3a( gl, v ) {

	var cache = this.cache;
	var data = flatten( v, this.size, 9 );

	if ( arraysEqual( cache, data ) ) { return; }

	gl.uniformMatrix3fv( this.addr, false, data );

	this.updateCache( data );

}

function setValueM4a( gl, v ) {

	var cache = this.cache;
	var data = flatten( v, this.size, 16 );

	if ( arraysEqual( cache, data ) ) { return; }

	gl.uniformMatrix4fv( this.addr, false, data );

	this.updateCache( data );

}

// Array of textures (2D / Cube)

function setValueT1a( gl, v, renderer ) {

	var cache = this.cache;
	var n = v.length;

	var units = allocTexUnits( renderer, n );

	if ( arraysEqual( cache, units ) === false ) {

		gl.uniform1iv( this.addr, units );
		copyArray( cache, units );

	}

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6a( gl, v, renderer ) {

	var cache = this.cache;
	var n = v.length;

	var units = allocTexUnits( renderer, n );

	if ( arraysEqual( cache, units ) === false ) {

		gl.uniform1iv( this.addr, units );
		copyArray( cache, units );

	}

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1fv; // FLOAT
		case 0x8b50: return setValueV2a; // _VEC2
		case 0x8b51: return setValueV3a; // _VEC3
		case 0x8b52: return setValueV4a; // _VEC4

		case 0x8b5a: return setValueM2a; // _MAT2
		case 0x8b5b: return setValueM3a; // _MAT3
		case 0x8b5c: return setValueM4a; // _MAT4

		case 0x8b5e: return setValueT1a; // SAMPLER_2D
		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	var cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	UniformContainer.call( this ); // mix-in

}

StructuredUniform.prototype.setValue = function ( gl, value, renderer ) {

	var seq = this.seq;

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		u.setValue( gl, value[ u.id ], renderer );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	var path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,

			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) { id = id | 0; } // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			var map = container.map, next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program, renderer ) {

	UniformContainer.call( this );

	this.renderer = renderer;

	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

	for ( var i = 0; i < n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

	var u = this.map[ name ];

	if ( u !== undefined ) { u.setValue( gl, value, this.renderer ); }

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	var v = object[ name ];

	if ( v !== undefined ) { this.setValue( gl, name, v ); }

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, renderer );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	var r = [];

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		if ( u.id in values ) { r.push( u ); }

	}

	return r;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function addLineNumbers( string ) {

	var lines = string.split( '\n' );

	for ( var i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function WebGLShader( gl, type, string ) {

	var shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

	}

	if ( gl.getShaderInfoLog( shader ) !== '' ) {

		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

	}

	// --enable-privileged-webgl-extension
	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount = 0;

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );

	}

}

function getTexelDecodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	var toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case Uncharted2ToneMapping:
			toneMappingName = 'Uncharted2';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( extensions, parameters, rendererExtensions ) {

	extensions = extensions || {};

	var chunks = [
		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	var chunks = [];

	for ( var name in defines ) {

		var value = defines[ name ];

		if ( value === false ) { continue; }

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	var attributes = {};

	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( var i = 0; i < n; i ++ ) {

		var info = gl.getActiveAttrib( program, i );
		var name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

function parseIncludes( string ) {

	var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function replace( match, include ) {

		var replace = ShaderChunk[ include ];

		if ( replace === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return parseIncludes( replace );

	}

	return string.replace( pattern, replace );

}

function unrollLoops( string ) {

	var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

	function replace( match, start, end, snippet ) {

		var unroll = '';

		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

		}

		return unroll;

	}

	return string.replace( pattern, replace );

}

function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {

	var gl = renderer.context;

	var defines = material.defines;

	var vertexShader = shader.vertexShader;
	var fragmentShader = shader.fragmentShader;

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	}

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

	if ( parameters.envMap ) {

		switch ( material.envMap.mapping ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

		switch ( material.envMap.mapping ) {

			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

		switch ( material.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	// console.log( 'building new program ' );

	//

	var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );

	var customDefines = generateDefines( defines );

	//

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if ( material.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + shader.name,

			customDefines,

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + shader.name,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
				ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

			parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = parseIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = parseIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {

		var isGLSL3ShaderMaterial = false;

		var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

		if ( material.isShaderMaterial &&
			vertexShader.match( versionRegex ) !== null &&
			fragmentShader.match( versionRegex ) !== null ) {

			isGLSL3ShaderMaterial = true;

			vertexShader = vertexShader.replace( versionRegex, '' );
			fragmentShader = fragmentShader.replace( versionRegex, '' );

		}

		// GLSL 3.0 conversion
		prefixVertex = [
			'#version 300 es\n',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#version 300 es\n',
			'#define varying in',
			isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
			isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( material.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, material.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	var programLog = gl.getProgramInfoLog( program ).trim();
	var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
	var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

	var runnable = true;
	var haveDiagnostics = true;

	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

		runnable = false;

		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

	} else if ( programLog !== '' ) {

		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

	} else if ( vertexLog === '' || fragmentLog === '' ) {

		haveDiagnostics = false;

	}

	if ( haveDiagnostics ) {

		this.diagnostics = {

			runnable: runnable,
			material: material,

			programLog: programLog,

			vertexShader: {

				log: vertexLog,
				prefix: prefixVertex

			},

			fragmentShader: {

				log: fragmentLog,
				prefix: prefixFragment

			}

		};

	}

	// clean up

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	var cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program, renderer );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	var cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		gl.deleteProgram( program );
		this.program = undefined;

	};

	// DEPRECATED

	Object.defineProperties( this, {

		uniforms: {
			get: function () {

				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
				return this.getUniforms();

			}
		},

		attributes: {
			get: function () {

				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
				return this.getAttributes();

			}
		}

	} );


	//

	this.name = shader.name;
	this.id = programIdCount ++;
	this.code = code;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms( renderer, extensions, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
	];


	function allocateBones( object ) {

		var skeleton = object.skeleton;
		var bones = skeleton.bones;

		if ( capabilities.floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

		var encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

			encoding = GammaEncoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
		var precision = capabilities.precision;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var currentRenderTarget = renderer.getRenderTarget();

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: !! fog,
			useFog: material.fog,
			fogExp: ( fog && fog.isFogExp2 ),

			flatShading: material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( material.fragmentShader );
			array.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				array.push( name );
				array.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			array.push( parameters[ parameterNames[ i ] ] );

		}

		array.push( material.onBeforeCompile.toString() );

		array.push( renderer.gammaOutput );

		array.push( renderer.gammaFactor );

		return array.join();

	};

	this.acquireProgram = function ( material, shader, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function ( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties() {

	var properties = new WeakMap();

	function get( object ) {

		var map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program && b.program && a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	var renderItems = [];
	var renderItemsIndex = 0;

	var opaque = [];
	var transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		var renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: material.program,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = material.program;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort() {

		if ( opaque.length > 1 ) { opaque.sort( painterSortStable ); }
		if ( transparent.length > 1 ) { transparent.sort( reversePainterSortStable ); }

	}

	return {
		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,

		sort: sort
	};

}

function WebGLRenderLists() {

	var lists = {};

	function onSceneDispose( event ) {

		var scene = event.target;

		scene.removeEventListener( 'dispose', onSceneDispose );

		delete lists[ scene.id ];

	}

	function get( scene, camera ) {

		var cameras = lists[ scene.id ];
		var list;
		if ( cameras === undefined ) {

			list = new WebGLRenderList();
			lists[ scene.id ] = {};
			lists[ scene.id ][ camera.id ] = list;

			scene.addEventListener( 'dispose', onSceneDispose );

		} else {

			list = cameras[ camera.id ];
			if ( list === undefined ) {

				list = new WebGLRenderList();
				cameras[ camera.id ] = list;

			}

		}

		return list;

	}

	function dispose() {

		lists = {};

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function UniformsCache() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color(),

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
						// TODO (abelnation): set RectAreaLight shadow uniforms
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

var count = 0;

function WebGLLights() {

	var cache = new UniformsCache();

	var state = {

		id: count ++,

		hash: {
			stateID: - 1,
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,
			shadowsLength: - 1
		},

		ambient: [ 0, 0, 0 ],
		directional: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		point: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	var vector3 = new Vector3();
	var matrix4 = new Matrix4();
	var matrix42 = new Matrix4();

	function setup( lights, shadows, camera ) {

		var r = 0, g = 0, b = 0;

		var directionalLength = 0;
		var pointLength = 0;
		var spotLength = 0;
		var rectAreaLength = 0;
		var hemiLength = 0;

		var viewMatrix = camera.matrixWorldInverse;

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			var color = light.color;
			var intensity = light.intensity;
			var distance = light.distance;

			var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isDirectionalLight ) {

				var uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;

				}

				state.directionalShadowMap[ directionalLength ] = shadowMap;
				state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				var uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;

				}

				state.spotShadowMap[ spotLength ] = shadowMap;
				state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				var uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				var uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					uniforms.shadowBias = shadow.bias;
					uniforms.shadowRadius = shadow.radius;
					uniforms.shadowMapSize = shadow.mapSize;
					uniforms.shadowCameraNear = shadow.camera.near;
					uniforms.shadowCameraFar = shadow.camera.far;

				}

				state.pointShadowMap[ pointLength ] = shadowMap;
				state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				var uniforms = cache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		state.directional.length = directionalLength;
		state.spot.length = spotLength;
		state.rectArea.length = rectAreaLength;
		state.point.length = pointLength;
		state.hemi.length = hemiLength;

		state.hash.stateID = state.id;
		state.hash.directionalLength = directionalLength;
		state.hash.pointLength = pointLength;
		state.hash.spotLength = spotLength;
		state.hash.rectAreaLength = rectAreaLength;
		state.hash.hemiLength = hemiLength;
		state.hash.shadowsLength = shadows.length;

	}

	return {
		setup: setup,
		state: state
	};

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLRenderState() {

	var lights = new WebGLLights();

	var lightsArray = [];
	var shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( camera ) {

		lights.setup( lightsArray, shadowsArray, camera );

	}

	var state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates() {

	var renderStates = {};

	function onSceneDispose( event ) {

		var scene = event.target;

		scene.removeEventListener( 'dispose', onSceneDispose );

		delete renderStates[ scene.id ];

	}

	function get( scene, camera ) {

		var renderState;

		if ( renderStates[ scene.id ] === undefined ) {

			renderState = new WebGLRenderState();
			renderStates[ scene.id ] = {};
			renderStates[ scene.id ][ camera.id ] = renderState;

			scene.addEventListener( 'dispose', onSceneDispose );

		} else {

			if ( renderStates[ scene.id ][ camera.id ] === undefined ) {

				renderState = new WebGLRenderState();
				renderStates[ scene.id ][ camera.id ] = renderState;

			} else {

				renderState = renderStates[ scene.id ][ camera.id ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = {};

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: WebGLRenderTarget,

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDistanceMaterial';

	this.referencePosition = new Vector3();
	this.nearDistance = 1;
	this.farDistance = 1000;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

MeshDistanceMaterial.prototype = Object.create( Material.prototype );
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.referencePosition.copy( source.referencePosition );
	this.nearDistance = source.nearDistance;
	this.farDistance = source.farDistance;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

	var _frustum = new Frustum(),
		_projScreenMatrix = new Matrix4(),

		_shadowMapSize = new Vector2(),
		_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

		_lookTarget = new Vector3(),
		_lightPositionWorld = new Vector3(),

		_MorphingFlag = 1,
		_SkinningFlag = 2,

		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants ),

		_materialCache = {};

	var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	var cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new Vector4(), new Vector4(), new Vector4(),
		new Vector4(), new Vector4(), new Vector4()
	];

	// init

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = new MeshDepthMaterial( {

			depthPacking: RGBADepthPacking,

			morphTargets: useMorphing,
			skinning: useSkinning

		} );

		_depthMaterials[ i ] = depthMaterial;

		//

		var distanceMaterial = new MeshDistanceMaterial( {

			morphTargets: useMorphing,
			skinning: useSkinning

		} );

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) { return; }
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) { return; }

		if ( lights.length === 0 ) { return; }

		var _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		var faceCount;

		for ( var i = 0, il = lights.length; i < il; i ++ ) {

			var light = lights[ i ];
			var shadow = light.shadow;
			var isPointLight = light && light.isPointLight;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			var shadowCamera = shadow.camera;

			_shadowMapSize.copy( shadow.mapSize );
			_shadowMapSize.min( _maxShadowMapSize );

			if ( isPointLight ) {

				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;

				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				// negative X
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				// positive Z
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				// negative Z
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				// positive Y
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				// negative Y
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadowCamera.updateProjectionMatrix();

			}

			if ( shadow.isSpotLightShadow ) {

				shadow.update( light );

			}

			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			if ( isPointLight ) {

				faceCount = 6;

				// for point lights we set the shadow matrix to be a translation-only matrix
				// equal to inverse of the light's position

				shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			} else {

				faceCount = 1;

				_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _lookTarget );
				shadowCamera.updateMatrixWorld();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			}

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// render shadow map for each cube face (if omni-directional) or
			// run a single pass if not

			for ( var face = 0; face < faceCount; face ++ ) {

				if ( isPointLight ) {

					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );

				}

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// set object matrices & frustum culling

				renderObject( scene, camera, shadowCamera, isPointLight );

			}

		}

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

		var geometry = object.geometry;

		var result = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = false;

			if ( material.morphTargets ) {

				if ( geometry && geometry.isBufferGeometry ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				} else if ( geometry && geometry.isGeometry ) {

					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

				}

			}

			if ( object.isSkinnedMesh && material.skinning === false ) {

				console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

			}

			var useSkinning = object.isSkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) { variantIndex |= _MorphingFlag; }
			if ( useSkinning ) { variantIndex |= _SkinningFlag; }

			result = materialVariants[ variantIndex ];

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( isPointLight && result.isMeshDistanceMaterial ) {

			result.referencePosition.copy( lightPositionWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, isPointLight ) {

		if ( object.visible === false ) { return; }

		var visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				var geometry = _objects.update( object );
				var material = object.material;

				if ( Array.isArray( material ) ) {

					var groups = geometry.groups;

					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

						var group = groups[ k ];
						var groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, isPointLight );

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState( gl, extensions, utils, capabilities ) {

	function ColorBuffer() {

		var locked = false;

		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

					} else {

						gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( stencilTest ) {

					enable( gl.STENCIL_TEST );

				} else {

					disable( gl.STENCIL_TEST );

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();

	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var enabledCapabilities = {};

	var compressedTextureFormats = null;

	var currentProgram = null;

	var currentBlendingEnabled = null;
	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

	var lineWidthAvailable = false;
	var version = 0;
	var glVersion = gl.getParameter( gl.VERSION );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new Vector4();
	var currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( gl.DEPTH_TEST );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( gl.CULL_FACE );

	setBlending( NoBlending );

	//

	function initAttributes() {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function getCompressedTextureFormats() {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
			     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled ) {

				disable( gl.BLEND );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( ! currentBlendingEnabled ) {

			enable( gl.BLEND );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
							break;

						case MultiplyBlending:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );

		var flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) { flipSided = ! flipSided; }

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) { gl.lineWidth( width ); }

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) { webglSlot = gl.TEXTURE0 + maxTextures - 1; }

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		enabledCapabilities = {};

		compressedTextureFormats = null;

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentProgram = null;

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		enable: enable,
		disable: disable,
		getCompressedTextureFormats: getCompressedTextureFormats,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	var _videoTextures = {};
	var _canvas;

	//

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		var scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {

				if ( _canvas === undefined ) { _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); }

				// cube textures can't reuse the same canvas

				var canvas = needsNewCanvas ? document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) : _canvas;

				var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;

				canvas.width = floor( scale * image.width );
				canvas.height = floor( scale * image.height );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + canvas.width + 'x' + canvas.height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( capabilities.isWebGL2 ) { return false; }

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		var textureProperties = properties.get( texture );

		// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
		textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

	}

	function getInternalFormat( glFormat, glType ) {

		if ( ! capabilities.isWebGL2 ) { return glFormat; }

		var internalFormat = glFormat;

		if ( glFormat === _gl.RED ) {

			if ( glType === _gl.FLOAT ) { internalFormat = _gl.R32F; }
			if ( glType === _gl.HALF_FLOAT ) { internalFormat = _gl.R16F; }
			if ( glType === _gl.UNSIGNED_BYTE ) { internalFormat = _gl.R8; }

		}

		if ( glFormat === _gl.RGB ) {

			if ( glType === _gl.FLOAT ) { internalFormat = _gl.RGB32F; }
			if ( glType === _gl.HALF_FLOAT ) { internalFormat = _gl.RGB16F; }
			if ( glType === _gl.UNSIGNED_BYTE ) { internalFormat = _gl.RGB8; }

		}

		if ( glFormat === _gl.RGBA ) {

			if ( glType === _gl.FLOAT ) { internalFormat = _gl.RGBA32F; }
			if ( glType === _gl.HALF_FLOAT ) { internalFormat = _gl.RGBA16F; }
			if ( glType === _gl.UNSIGNED_BYTE ) { internalFormat = _gl.RGBA8; }

		}

		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		} else if ( internalFormat === _gl.RGB16F || internalFormat === _gl.RGB32F ) {

			console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			delete _videoTextures[ texture.id ];

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) { return; }

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) { return; }

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); }

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); }

		}

		properties.remove( renderTarget.texture );
		properties.remove( renderTarget );

	}

	//



	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) { updateVideoTexture( texture ); }

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture );

	}


	function setTextureCube( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					info.memory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = ( texture && texture.isCompressedTexture );
				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
					supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
					glFormat = utils.convert( texture.format ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( glFormat, glType );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( ! isCompressed ) {

					textureProperties.__maxMipLevel = 0;

				} else {

					textureProperties.__maxMipLevel = mipmaps.length - 1;

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					// We assume images for cube map have the same size.
					generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) { texture.onUpdate( texture ); }

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setTextureCubeDynamic( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	function setTextureParameters( textureType, texture, supportsMips ) {

		var extension;

		if ( supportsMips ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) { return; }
			if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) { return; }

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		var textureType;

		if ( texture.isDataTexture3D ) {

			textureType = _gl.TEXTURE_3D;

		} else {

			textureType = _gl.TEXTURE_2D;

		}


		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}
		state.activeTexture( _gl.TEXTURE0 + slot );


		state.bindTexture( textureType, textureProperties.__webglTexture );



		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );

		var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = _gl.DEPTH_COMPONENT;

			if ( texture.type === FloatType ) {

				if ( ! capabilities.isWebGL2 ) { throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); }
				glInternalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( capabilities.isWebGL2 ) {

				// WebGL 2.0 requires signed internalformat for glTexImage2D
				glInternalFormat = _gl.DEPTH_COMPONENT16;

			}

			if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			// Depth stencil textures need the DEPTH_STENCIL internal format
			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
			if ( texture.format === DepthStencilFormat ) {

				glInternalFormat = _gl.DEPTH_STENCIL;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( _gl.TEXTURE_2D, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) { texture.onUpdate( texture ); }

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = utils.convert( renderTarget.texture.format );
		var glType = utils.convert( renderTarget.texture.type );
		var glInternalFormat = getInternalFormat( glFormat, glType );
		state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( glFormat, glType );

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		if ( isCube ) { throw new Error( 'Depth Texture with cube render targets is not supported' ); }

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) { throw new Error( 'target.depthTexture not supported in Cube render targets' ); }

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

				}

			} else {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

			}

		}

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		info.memory.textures ++;

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
		var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( capabilities.isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
					var glFormat = utils.convert( renderTarget.texture.format );
					var glType = utils.convert( renderTarget.texture.type );
					var glInternalFormat = getInternalFormat( glFormat, glType );
					var samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;
		var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( capabilities.isWebGL2 ) {

				var renderTargetProperties = properties.get( renderTarget );

				_gl.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
				_gl.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				var width = renderTarget.width;
				var height = renderTarget.height;
				var mask = _gl.COLOR_BUFFER_BIT;

				if ( renderTarget.depthBuffer ) { mask |= _gl.DEPTH_BUFFER_BIT; }
				if ( renderTarget.stencilBuffer ) { mask |= _gl.STENCIL_BUFFER_BIT; }

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		var id = texture.id;
		var frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures[ id ] !== frame ) {

			_videoTextures[ id ] = frame;
			texture.update();

		}

	}

	this.setTexture2D = setTexture2D;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

}

/**
 * @author thespite / http://www.twitter.com/thespite
 */

function WebGLUtils( gl, extensions, capabilities ) {

	function convert( p ) {

		var extension;

		if ( p === RepeatWrapping ) { return gl.REPEAT; }
		if ( p === ClampToEdgeWrapping ) { return gl.CLAMP_TO_EDGE; }
		if ( p === MirroredRepeatWrapping ) { return gl.MIRRORED_REPEAT; }

		if ( p === NearestFilter ) { return gl.NEAREST; }
		if ( p === NearestMipMapNearestFilter ) { return gl.NEAREST_MIPMAP_NEAREST; }
		if ( p === NearestMipMapLinearFilter ) { return gl.NEAREST_MIPMAP_LINEAR; }

		if ( p === LinearFilter ) { return gl.LINEAR; }
		if ( p === LinearMipMapNearestFilter ) { return gl.LINEAR_MIPMAP_NEAREST; }
		if ( p === LinearMipMapLinearFilter ) { return gl.LINEAR_MIPMAP_LINEAR; }

		if ( p === UnsignedByteType ) { return gl.UNSIGNED_BYTE; }
		if ( p === UnsignedShort4444Type ) { return gl.UNSIGNED_SHORT_4_4_4_4; }
		if ( p === UnsignedShort5551Type ) { return gl.UNSIGNED_SHORT_5_5_5_1; }
		if ( p === UnsignedShort565Type ) { return gl.UNSIGNED_SHORT_5_6_5; }

		if ( p === ByteType ) { return gl.BYTE; }
		if ( p === ShortType ) { return gl.SHORT; }
		if ( p === UnsignedShortType ) { return gl.UNSIGNED_SHORT; }
		if ( p === IntType ) { return gl.INT; }
		if ( p === UnsignedIntType ) { return gl.UNSIGNED_INT; }
		if ( p === FloatType ) { return gl.FLOAT; }

		if ( p === HalfFloatType ) {

			if ( capabilities.isWebGL2 ) { return gl.HALF_FLOAT; }

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) { return extension.HALF_FLOAT_OES; }

		}

		if ( p === AlphaFormat ) { return gl.ALPHA; }
		if ( p === RGBFormat ) { return gl.RGB; }
		if ( p === RGBAFormat ) { return gl.RGBA; }
		if ( p === LuminanceFormat ) { return gl.LUMINANCE; }
		if ( p === LuminanceAlphaFormat ) { return gl.LUMINANCE_ALPHA; }
		if ( p === DepthFormat ) { return gl.DEPTH_COMPONENT; }
		if ( p === DepthStencilFormat ) { return gl.DEPTH_STENCIL; }
		if ( p === RedFormat ) { return gl.RED; }

		if ( p === AddEquation ) { return gl.FUNC_ADD; }
		if ( p === SubtractEquation ) { return gl.FUNC_SUBTRACT; }
		if ( p === ReverseSubtractEquation ) { return gl.FUNC_REVERSE_SUBTRACT; }

		if ( p === ZeroFactor ) { return gl.ZERO; }
		if ( p === OneFactor ) { return gl.ONE; }
		if ( p === SrcColorFactor ) { return gl.SRC_COLOR; }
		if ( p === OneMinusSrcColorFactor ) { return gl.ONE_MINUS_SRC_COLOR; }
		if ( p === SrcAlphaFactor ) { return gl.SRC_ALPHA; }
		if ( p === OneMinusSrcAlphaFactor ) { return gl.ONE_MINUS_SRC_ALPHA; }
		if ( p === DstAlphaFactor ) { return gl.DST_ALPHA; }
		if ( p === OneMinusDstAlphaFactor ) { return gl.ONE_MINUS_DST_ALPHA; }

		if ( p === DstColorFactor ) { return gl.DST_COLOR; }
		if ( p === OneMinusDstColorFactor ) { return gl.ONE_MINUS_DST_COLOR; }
		if ( p === SrcAlphaSaturateFactor ) { return gl.SRC_ALPHA_SATURATE; }

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; }
				if ( p === RGBA_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; }
				if ( p === RGBA_S3TC_DXT3_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; }
				if ( p === RGBA_S3TC_DXT5_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; }

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; }
				if ( p === RGB_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; }
				if ( p === RGBA_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; }
				if ( p === RGBA_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; }

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) { return extension.COMPRESSED_RGB_ETC1_WEBGL; }

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				return p;

			}

		}

		if ( p === MinEquation || p === MaxEquation ) {

			if ( capabilities.isWebGL2 ) {

				if ( p === MinEquation ) { return gl.MIN; }
				if ( p === MaxEquation ) { return gl.MAX; }

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === MinEquation ) { return extension.MIN_EXT; }
				if ( p === MaxEquation ) { return extension.MAX_EXT; }

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( capabilities.isWebGL2 ) { return gl.UNSIGNED_INT_24_8; }

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) { return extension.UNSIGNED_INT_24_8_WEBGL; }

		}

		return 0;

	}

	return { convert: convert };

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group,

	isGroup: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();

	this.projectionMatrix = new Matrix4();
	this.projectionMatrixInverse = new Matrix4();

}

Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera( fov, aspect, near, far ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return _Math.RAD2DEG * 2 * Math.atan(
			Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera( array ) {

	PerspectiveCamera.call( this );

	this.cameras = array || [];

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

	constructor: ArrayCamera,

	isArrayCamera: true

} );

/**
 * @author jsantell / https://www.jsantell.com/
 * @author mrdoob / http://mrdoob.com/
 */

var cameraLPos = new Vector3();
var cameraRPos = new Vector3();

/**
 * Assumes 2 cameras that are parallel and share an X-axis, and that
 * the cameras' projection and world matrices have already been set.
 * And that near and far planes are identical for both cameras.
 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
 */
function setProjectionFromUnion( camera, cameraL, cameraR ) {

	cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
	cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

	var ipd = cameraLPos.distanceTo( cameraRPos );

	var projL = cameraL.projectionMatrix.elements;
	var projR = cameraR.projectionMatrix.elements;

	// VR systems will have identical far and near planes, and
	// most likely identical top and bottom frustum extents.
	// Use the left camera for these values.
	var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
	var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
	var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
	var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

	var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
	var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
	var left = near * leftFov;
	var right = near * rightFov;

	// Calculate the new camera's position offset from the
	// left camera. xOffset should be roughly half `ipd`.
	var zOffset = ipd / ( - leftFov + rightFov );
	var xOffset = zOffset * - leftFov;

	// TODO: Better way to apply this offset?
	cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
	camera.translateX( xOffset );
	camera.translateZ( zOffset );
	camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
	camera.matrixWorldInverse.getInverse( camera.matrixWorld );

	// Find the union of the frustum values of the cameras and scale
	// the values so that the near plane's position does not change in world space,
	// although must now be relative to the new union camera.
	var near2 = near + zOffset;
	var far2 = far + zOffset;
	var left2 = left - xOffset;
	var right2 = right + ( ipd - xOffset );
	var top2 = topFov * far / far2 * near2;
	var bottom2 = bottomFov * far / far2 * near2;

	camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebVRManager( renderer ) {

	var scope = this;

	var device = null;
	var frameData = null;

	var poseTarget = null;

	var controllers = [];
	var standingMatrix = new Matrix4();
	var standingMatrixInverse = new Matrix4();

	var framebufferScaleFactor = 1.0;

	var frameOfReferenceType = 'stage';

	if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

		frameData = new window.VRFrameData();
		window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

	}

	var matrixWorldInverse = new Matrix4();
	var tempQuaternion = new Quaternion();
	var tempPosition = new Vector3();

	var cameraL = new PerspectiveCamera();
	cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
	cameraL.layers.enable( 1 );

	var cameraR = new PerspectiveCamera();
	cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
	cameraR.layers.enable( 2 );

	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	//

	function isPresenting() {

		return device !== null && device.isPresenting === true;

	}

	var currentSize, currentPixelRatio;

	function onVRDisplayPresentChange() {

		if ( isPresenting() ) {

			var eyeParameters = device.getEyeParameters( 'left' );
			var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
			var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

			currentPixelRatio = renderer.getPixelRatio();
			currentSize = renderer.getSize();

			renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

			animation.start();

		} else {

			if ( scope.enabled ) {

				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

			}

			animation.stop();

		}

	}

	//

	var triggers = [];

	function findGamepad( id ) {

		var gamepads = navigator.getGamepads && navigator.getGamepads();

		for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

			var gamepad = gamepads[ i ];

			if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
				gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
				gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
				gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

				if ( j === id ) { return gamepad; }

				j ++;

			}

		}

	}

	function updateControllers() {

		for ( var i = 0; i < controllers.length; i ++ ) {

			var controller = controllers[ i ];

			var gamepad = findGamepad( i );

			if ( gamepad !== undefined && gamepad.pose !== undefined ) {

				if ( gamepad.pose === null ) { return; }

				//  Pose

				var pose = gamepad.pose;

				if ( pose.hasPosition === false ) { controller.position.set( 0.2, - 0.6, - 0.05 ); }

				if ( pose.position !== null ) { controller.position.fromArray( pose.position ); }
				if ( pose.orientation !== null ) { controller.quaternion.fromArray( pose.orientation ); }
				controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
				controller.matrix.premultiply( standingMatrix );
				controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
				controller.matrixWorldNeedsUpdate = true;
				controller.visible = true;

				//  Trigger

				var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

				if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {

					triggers[ i ] = gamepad.buttons[ buttonId ].pressed;

					if ( triggers[ i ] === true ) {

						controller.dispatchEvent( { type: 'selectstart' } );

					} else {

						controller.dispatchEvent( { type: 'selectend' } );
						controller.dispatchEvent( { type: 'select' } );

					}

				}

			} else {

				controller.visible = false;

			}

		}

	}

	//

	this.enabled = false;

	this.getController = function ( id ) {

		var controller = controllers[ id ];

		if ( controller === undefined ) {

			controller = new Group();
			controller.matrixAutoUpdate = false;
			controller.visible = false;

			controllers[ id ] = controller;

		}

		return controller;

	};

	this.getDevice = function () {

		return device;

	};

	this.setDevice = function ( value ) {

		if ( value !== undefined ) { device = value; }

		animation.setContext( value );

	};

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

	};

	this.setFrameOfReferenceType = function ( value ) {

		frameOfReferenceType = value;

	};

	this.setPoseTarget = function ( object ) {

		if ( object !== undefined ) { poseTarget = object; }

	};

	this.getCamera = function ( camera ) {

		var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

		if ( device === null ) {

			camera.position.set( 0, userHeight, 0 );
			return camera;

		}

		device.depthNear = camera.near;
		device.depthFar = camera.far;

		device.getFrameData( frameData );

		//

		if ( frameOfReferenceType === 'stage' ) {

			var stageParameters = device.stageParameters;

			if ( stageParameters ) {

				standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

			} else {

				standingMatrix.makeTranslation( 0, userHeight, 0 );

			}

		}


		var pose = frameData.pose;
		var poseObject = poseTarget !== null ? poseTarget : camera;

		// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
		poseObject.matrix.copy( standingMatrix );
		poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

		if ( pose.orientation !== null ) {

			tempQuaternion.fromArray( pose.orientation );
			poseObject.quaternion.multiply( tempQuaternion );

		}

		if ( pose.position !== null ) {

			tempQuaternion.setFromRotationMatrix( standingMatrix );
			tempPosition.fromArray( pose.position );
			tempPosition.applyQuaternion( tempQuaternion );
			poseObject.position.add( tempPosition );

		}

		poseObject.updateMatrixWorld();

		if ( device.isPresenting === false ) { return camera; }

		//

		cameraL.near = camera.near;
		cameraR.near = camera.near;

		cameraL.far = camera.far;
		cameraR.far = camera.far;

		cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
		cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

		// TODO (mrdoob) Double check this code

		standingMatrixInverse.getInverse( standingMatrix );

		if ( frameOfReferenceType === 'stage' ) {

			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

		}

		var parent = poseObject.parent;

		if ( parent !== null ) {

			matrixWorldInverse.getInverse( parent.matrixWorld );

			cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
			cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

		}

		// envMap and Mirror needs camera.matrixWorld

		cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
		cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

		cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
		cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

		setProjectionFromUnion( cameraVR, cameraL, cameraR );

		//

		var layers = device.getLayers();

		if ( layers.length ) {

			var layer = layers[ 0 ];

			if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

				cameraL.bounds.fromArray( layer.leftBounds );

			}

			if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

				cameraR.bounds.fromArray( layer.rightBounds );

			}

		}

		updateControllers();

		return cameraVR;

	};

	this.getStandingMatrix = function () {

		return standingMatrix;

	};

	this.isPresenting = isPresenting;

	// Animation Loop

	var animation = new WebGLAnimation();

	this.setAnimationLoop = function ( callback ) {

		animation.setAnimationLoop( callback );

	};

	this.submitFrame = function () {

		if ( isPresenting() ) { device.submitFrame(); }

	};

	this.dispose = function () {

		if ( typeof window !== 'undefined' ) {

			window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebXRManager( renderer ) {

	var gl = renderer.context;

	var device = null;
	var session = null;

	var framebufferScaleFactor = 1.0;

	var frameOfReference = null;
	var frameOfReferenceType = 'stage';

	var pose = null;

	var controllers = [];
	var inputSources = [];

	function isPresenting() {

		return session !== null && frameOfReference !== null;

	}

	//

	var cameraL = new PerspectiveCamera();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new Vector4();

	var cameraR = new PerspectiveCamera();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new Vector4();

	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	//

	this.enabled = false;

	this.getController = function ( id ) {

		var controller = controllers[ id ];

		if ( controller === undefined ) {

			controller = new Group();
			controller.matrixAutoUpdate = false;
			controller.visible = false;

			controllers[ id ] = controller;

		}

		return controller;

	};

	this.getDevice = function () {

		return device;

	};

	this.setDevice = function ( value ) {

		if ( value !== undefined ) { device = value; }
		if ( value instanceof XRDevice ) { gl.setCompatibleXRDevice( value ); }

	};

	//

	function onSessionEvent( event ) {

		var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
		if ( controller ) { controller.dispatchEvent( { type: event.type } ); }

	}

	function onSessionEnd() {

		renderer.setFramebuffer( null );
		animation.stop();

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

	};

	this.setFrameOfReferenceType = function ( value ) {

		frameOfReferenceType = value;

	};

	this.setSession = function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );

			session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );
			session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {

				frameOfReference = value;

				renderer.setFramebuffer( session.baseLayer.framebuffer );

				animation.setContext( session );
				animation.start();

			} );

			//

			inputSources = session.getInputSources();

			session.addEventListener( 'inputsourceschange', function () {

				inputSources = session.getInputSources();
				console.log( inputSources );

				for ( var i = 0; i < controllers.length; i ++ ) {

					var controller = controllers[ i ];
					controller.userData.inputSource = inputSources[ i ];

				}

			} );

		}

	};

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

	}

	this.getCamera = function ( camera ) {

		if ( isPresenting() ) {

			var parent = camera.parent;
			var cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( var i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update camera and its children

			camera.matrixWorld.copy( cameraVR.matrixWorld );

			var children = camera.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

			return cameraVR;

		}

		return camera;

	};

	this.isPresenting = isPresenting;

	// Animation Loop

	var onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getDevicePose( frameOfReference );

		if ( pose !== null ) {

			var layer = session.baseLayer;
			var views = frame.views;

			for ( var i = 0; i < views.length; i ++ ) {

				var view = views[ i ];
				var viewport = layer.getViewport( view );
				var viewMatrix = pose.getViewMatrix( view );

				var camera = cameraVR.cameras[ i ];
				camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

			}

		}

		//

		for ( var i = 0; i < controllers.length; i ++ ) {

			var controller = controllers[ i ];

			var inputSource = inputSources[ i ];

			if ( inputSource ) {

				var inputPose = frame.getInputPose( inputSource, frameOfReference );

				if ( inputPose !== null ) {

					if ( 'targetRay' in inputPose ) {

						controller.matrix.elements = inputPose.targetRay.transformMatrix;

					} else if ( 'pointerMatrix' in inputPose ) {

						// DEPRECATED

						controller.matrix.elements = inputPose.pointerMatrix;

					}

					controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
					controller.visible = true;

					continue;

				}

			}

			controller.visible = false;

		}

		if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }

	}

	var animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

	// DEPRECATED

	this.getStandingMatrix = function () {

		console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
		return new THREE.Matrix4();

	};

	this.submitFrame = function () {};

}

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer( parameters ) {

	console.log( 'THREE.WebGLRenderer', REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

	var currentRenderList = null;
	var currentRenderState = null;

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

		_isContextLost = false,

		// internal state cache

		_framebuffer = null,

		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,

		// geometry and program caching

		_currentGeometryProgram = {
			geometry: null,
			program: null,
			wireframe: false
		},

		_currentCamera = null,
		_currentArrayCamera = null,

		_currentViewport = new Vector4(),
		_currentScissor = new Vector4(),
		_currentScissorTest = null,

		//

		_usedTextureUnits = 0,

		//

		_width = _canvas.width,
		_height = _canvas.height,

		_pixelRatio = 1,

		_viewport = new Vector4( 0, 0, _width, _height ),
		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,

		// frustum

		_frustum = new Frustum(),

		// clipping

		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,

		// camera matrices cache

		_projScreenMatrix = new Matrix4(),

		_vector3 = new Vector3();

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	var _gl;

	try {

		var contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw new Error( 'Error creating WebGL context with your selected attributes.' );

			} else {

				throw new Error( 'Error creating WebGL context.' );

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );

	}

	var extensions, capabilities, state, info;
	var properties, textures, attributes, geometries, objects;
	var programCache, renderLists, renderStates;

	var background, morphtargets, bufferRenderer, indexedBufferRenderer;

	var utils;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		if ( ! capabilities.isWebGL2 ) {

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'ANGLE_instanced_arrays' );

		}

		extensions.get( 'OES_texture_float_linear' );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, utils, capabilities );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		attributes = new WebGLAttributes( _gl );
		geometries = new WebGLGeometries( _gl, attributes, info );
		objects = new WebGLObjects( geometries, info );
		morphtargets = new WebGLMorphtargets( _gl );
		programCache = new WebGLPrograms( _this, extensions, capabilities );
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates();

		background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.context = _gl;
		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// vr

	var vr = null;

	if ( typeof navigator !== 'undefined' ) {

		vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

	}

	this.vr = vr;

	// shadow map

	var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

	this.shadowMap = shadowMap;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) { extension.loseContext(); }

	};

	this.forceContextRestore = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) { extension.restoreContext(); }

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) { return; }

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( vr.isPresenting() ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function () {

		return {
			width: _width * _pixelRatio,
			height: _height * _pixelRatio
		};

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function () {

		return _currentViewport;

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewport.set( x, _height - y - height, width, height );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

	};

	this.setScissor = function ( x, y, width, height ) {

		_scissor.set( x, _height - y - height, width, height );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return background.getClearColor();

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) { bits |= _gl.COLOR_BUFFER_BIT; }
		if ( depth === undefined || depth ) { bits |= _gl.DEPTH_BUFFER_BIT; }
		if ( stencil === undefined || stencil ) { bits |= _gl.STENCIL_BUFFER_BIT; }

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		objects.dispose();

		vr.dispose();

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		initGLContext();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) { buffers.position = _gl.createBuffer(); }
		if ( object.hasNormals && ! buffers.normal ) { buffers.normal = _gl.createBuffer(); }
		if ( object.hasUvs && ! buffers.uv ) { buffers.uv = _gl.createBuffer(); }
		if ( object.hasColors && ! buffers.color ) { buffers.color = _gl.createBuffer(); }

		var programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

		var frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 );

		state.setMaterial( material, frontFaceCW );

		var program = setProgram( camera, fog, material, object );

		var updateBuffers = false;

		if ( _currentGeometryProgram.geometry !== geometry.id ||
			_currentGeometryProgram.program !== program.id ||
			_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

			_currentGeometryProgram.geometry = geometry.id;
			_currentGeometryProgram.program = program.id;
			_currentGeometryProgram.wireframe = material.wireframe === true;
			updateBuffers = true;

		}

		if ( object.morphTargetInfluences ) {

			morphtargets.update( object, geometry, material, program );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;
		var rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		var attribute;
		var renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

			}

		}

		//

		var dataCount = Infinity;

		if ( index !== null ) {

			dataCount = index.count;

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;

		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) { return; }

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				switch ( object.drawMode ) {

					case TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;

					case TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;

					case TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;

				}

			}


		} else if ( object.isLine ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) { lineWidth = 1; } // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( _gl.LINES );

			} else if ( object.isLineLoop ) {

				renderer.setMode( _gl.LINE_LOOP );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( _gl.POINTS );

		} else if ( object.isSprite ) {

			renderer.setMode( _gl.TRIANGLES );

		}

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			if ( geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry, drawStart, drawCount );

			}

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry ) {

		if ( geometry && geometry.isInstancedBufferGeometry & ! capabilities.isWebGL2 ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) { continue; }

					var buffer = attribute.buffer;
					var type = attribute.type;
					var bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		scene.traverse( function ( object ) {

			if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( camera );

		scene.traverse( function ( object ) {

			if ( object.material ) {

				if ( Array.isArray( object.material ) ) {

					for ( var i = 0; i < object.material.length; i ++ ) {

						initMaterial( object.material[ i ], scene.fog, object );

					}

				} else {

					initMaterial( object.material, scene.fog, object );

				}

			}

		} );

	};

	// Animation Loop

	var onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( vr.isPresenting() ) { return; }
		if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }

	}

	var animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) { animation.setContext( window ); }

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		vr.setAnimationLoop( callback );

		animation.start();

	};

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( ! ( camera && camera.isCamera ) ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost ) { return; }

		// reset caching for this frame

		_currentGeometryProgram.geometry = null;
		_currentGeometryProgram.program = null;
		_currentGeometryProgram.wireframe = false;
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }

		// update camera matrices and frustum

		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

		if ( vr.enabled ) {

			camera = vr.getCamera( camera );

		}

		//

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		scene.onBeforeRender( _this, scene, camera, renderTarget );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, camera );
		currentRenderList.init();

		projectObject( scene, camera, 0, _this.sortObjects );

		if ( _this.sortObjects === true ) {

			currentRenderList.sort();

		}

		//

		if ( _clippingEnabled ) { _clipping.beginShadows(); }

		var shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights( camera );

		if ( _clippingEnabled ) { _clipping.endShadows(); }

		//

		if ( this.info.autoReset ) { this.info.reset(); }

		if ( renderTarget === undefined ) {

			renderTarget = null;

		}

		this.setRenderTarget( renderTarget );

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		var opaqueObjects = currentRenderList.opaque;
		var transparentObjects = currentRenderList.transparent;

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera, overrideMaterial ); }
			if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera, overrideMaterial ); }

		} else {

			// opaque pass (front-to-back order)

			if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera ); }

			// transparent pass (back-to-front order)

			if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera ); }

		}

		//

		if ( renderTarget ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( renderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		scene.onAfterRender( _this, scene, camera );

		if ( vr.enabled ) {

			vr.submitFrame();

		}

		// _gl.finish();

		currentRenderList = null;
		currentRenderState = null;

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) { return; }

		var visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					object.skeleton.update();

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var i = 0, l = groups.length; i < l; i ++ ) {

							var group = groups[ i ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			if ( camera.isArrayCamera ) {

				_currentArrayCamera = camera;

				var cameras = camera.cameras;

				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

					var camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						if ( 'viewport' in camera2 ) { // XR

							state.viewport( _currentViewport.copy( camera2.viewport ) );

						} else {

							var bounds = camera2.bounds;

							var x = bounds.x * _width;
							var y = bounds.y * _height;
							var width = bounds.z * _width;
							var height = bounds.w * _height;

							state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

						}

						currentRenderState.setupLights( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				_currentArrayCamera = null;

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			state.setMaterial( material );

			var program = setProgram( camera, scene.fog, material, object );

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

	}

	function initMaterial( material, fog, object ) {

		var materialProperties = properties.get( material );

		var lights = currentRenderState.state.lights;
		var shadowsArray = currentRenderState.state.shadowsArray;

		var lightsHash = materialProperties.lightsHash;
		var lightsStateHash = lights.state.hash;

		var parameters = programCache.getParameters(
			material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
			lightsHash.directionalLength !== lightsStateHash.directionalLength ||
			lightsHash.pointLength !== lightsStateHash.pointLength ||
			lightsHash.spotLength !== lightsStateHash.spotLength ||
			lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
			lightsHash.hemiLength !== lightsStateHash.hemiLength ||
			lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {

			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

			programChange = false;

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = ShaderLib[ parameters.shaderID ];

				materialProperties.shader = {
					name: material.type,
					uniforms: cloneUniforms( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.shader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.onBeforeCompile( materialProperties.shader, _this );

			// Computing code again as onBeforeCompile may have changed the shaders
			code = programCache.getProgramCode( material, parameters );

			program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var programAttributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.shader.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		materialProperties.fog = fog;

		// store the light setup it was created for
		if ( lightsHash === undefined ) {

			materialProperties.lightsHash = lightsHash = {};

		}

		lightsHash.stateID = lightsStateHash.stateID;
		lightsHash.directionalLength = lightsStateHash.directionalLength;
		lightsHash.pointLength = lightsStateHash.pointLength;
		lightsHash.spotLength = lightsStateHash.spotLength;
		lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
		lightsHash.hemiLength = lightsStateHash.hemiLength;
		lightsHash.shadowsLength = lightsStateHash.shadowsLength;

		if ( material.lights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.pointLights.value = lights.state.point;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setProgram( camera, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );
		var lights = currentRenderState.state.lights;

		var lightsHash = materialProperties.lightsHash;
		var lightsStateHash = lights.state.hash;

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );

			}

		}

		if ( material.needsUpdate === false ) {

			if ( materialProperties.program === undefined ) {

				material.needsUpdate = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				material.needsUpdate = true;

			} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
				lightsHash.pointLength !== lightsStateHash.pointLength ||
				lightsHash.spotLength !== lightsStateHash.spotLength ||
				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {

				material.needsUpdate = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

				material.needsUpdate = true;

			}

		}

		if ( material.needsUpdate ) {

			initMaterial( material, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.shader.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				var bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === undefined ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = _Math.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
						boneTexture.needsUpdate = true;

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

			if ( material.lights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

				if ( material.isMeshToonMaterial ) {

					refreshUniformsToon( m_uniforms, material );

				} else {

					refreshUniformsPhong( m_uniforms, material );

				}

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( m_uniforms, material );

				} else {

					refreshUniformsStandard( m_uniforms, material );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

				refreshUniformsMatcap( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsDepth( m_uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsDistance( m_uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsNormal( m_uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( m_uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( m_uniforms, material );

			} else if ( material.isShadowMaterial ) {

				m_uniforms.color.value = material.color;
				m_uniforms.opacity.value = material.opacity;

			}

			// RectAreaLight Texture
			// TODO (mrdoob): Find a nicer implementation

			if ( m_uniforms.ltc_1 !== undefined ) { m_uniforms.ltc_1.value = UniformsLib.LTC_1; }
			if ( m_uniforms.ltc_2 !== undefined ) { m_uniforms.ltc_2.value = UniformsLib.LTC_2; }

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value = material.color;

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		if ( material.envMap ) {

			uniforms.envMap.value = material.envMap;

			// don't flip CubeTexture envMaps, flip everything else:
			//  WebGLRenderTargetCube will be flipped for backwards compatibility
			//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
			// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
			uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			if ( material.map.matrixAutoUpdate === true ) {

				material.map.updateMatrix();

			}

			uniforms.uvTransform.value.copy( material.map.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;
		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			if ( material.map.matrixAutoUpdate === true ) {

				material.map.updateMatrix();

			}

			uniforms.uvTransform.value.copy( material.map.matrix );

		}

	}

	function refreshUniformsFog( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		refreshUniformsPhong( uniforms, material );

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		refreshUniformsStandard( uniforms, material );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	// Textures

	function allocTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	this.allocTextureUnit = allocTextureUnit;

	// this.setTexture2D = setTexture2D;
	this.setTexture2D = ( function () {

		var warned = false;

		// backwards compatibility: peel texture.texture
		return function setTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTexture3D = ( function () {

		// backwards compatibility: peel texture.texture
		return function setTexture3D( texture, slot ) {

			textures.setTexture3D( texture, slot );

		};

	}() );

	this.setTexture = ( function () {

		var warned = false;

		return function setTexture( texture, slot ) {

			if ( ! warned ) {

				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
				warned = true;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTextureCube = ( function () {

		var warned = false;

		return function setTextureCube( texture, slot ) {

			// backwards compatibility: peel texture.texture
			if ( texture && texture.isWebGLRenderTargetCube ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				textures.setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube

				textures.setTextureCubeDynamic( texture, slot );

			}

		};

	}() );

	//

	this.setFramebuffer = function ( value ) {

		_framebuffer = value;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget ) {

		_currentRenderTarget = renderTarget;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var framebuffer = _framebuffer;
		var isCube = false;

		if ( renderTarget ) {

			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLRenderTargetCube ) {

				framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level ) {

		var width = texture.image.width;
		var height = texture.image.height;
		var glFormat = utils.convert( texture.format );

		this.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0 );

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

		var width = srcTexture.image.width;
		var height = srcTexture.image.height;
		var glFormat = utils.convert( dstTexture.format );
		var glType = utils.convert( dstTexture.type );

		this.setTexture2D( dstTexture, 0 );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

}

Object.assign( Clock.prototype, {

	start: function () {

		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.morphTargets = false;

	this.lights = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new Vector3();
			var intersectPoint = new Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					ray.closestPointToPoint( point, intersectPoint );
					intersectPoint.applyMatrix4( matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) { return; }

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.lights = false;

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	computeLineDistances: ( function () {

		var start = new Vector3();
		var end = new Vector3();

		return function computeLineDistances() {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					var positionAttribute = geometry.attributes.position;
					var lineDistances = [ 0 ];

					for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

						start.fromBufferAttribute( positionAttribute, i - 1 );
						end.fromBufferAttribute( positionAttribute, i );

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += start.distanceTo( end );

					}

					geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var lineDistances = geometry.lineDistances;

				lineDistances[ 0 ] = 0;

				for ( var i = 1, l = vertices.length; i < l; i ++ ) {

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

				}

			}

			return this;

		};

	}() ),

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );
			sphere.radius += precision;

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localPrecisionSq = localPrecision * localPrecision;

			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = ( this && this.isLineSegments ) ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localPrecisionSq ) { continue; }

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localPrecisionSq ) { continue; }

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > localPrecisionSq ) { continue; }

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() ),

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.geometry.copy( source.geometry );
		this.material.copy( source.material );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: ( function () {

		var start = new Vector3();
		var end = new Vector3();

		return function computeLineDistances() {

			var geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					var positionAttribute = geometry.attributes.position;
					var lineDistances = [];

					for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

						start.fromBufferAttribute( positionAttribute, i );
						end.fromBufferAttribute( positionAttribute, i + 1 );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

					}

					geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var lineDistances = geometry.lineDistances;

				for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

					start.copy( vertices[ i ] );
					end.copy( vertices[ i + 1 ] );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

				}

			}

			return this;

		};

	}() )

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = ( left !== undefined ) ? left : - 1;
	this.right = ( right !== undefined ) ? right : 1;
	this.top = ( top !== undefined ) ? top : 1;
	this.bottom = ( bottom !== undefined ) ? bottom : - 1;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
			var scaleW = ( this.right - this.left ) / this.view.width;
			var scaleH = ( this.top - this.bottom ) / this.view.height;

			left += scaleW * ( this.view.offsetX / zoomW );
			right = left + scaleW * ( this.view.width / zoomW );
			top -= scaleH * ( this.view.offsetY / zoomH );
			bottom = top - scaleH * ( this.view.height / zoomH );

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

		return data;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		BufferGeometry.prototype.copy.call( this, source );

		this.maxInstancedCount = source.maxInstancedCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;

	this.params = {
		Mesh: {},
		Line: {},
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.visible === false ) { return; }

	object.raycast( raycaster, intersects );

	if ( recursive === true ) {

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	linePrecision: 1,

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( ( camera && camera.isPerspectiveCamera ) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

		} else if ( ( camera && camera.isOrthographicCamera ) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive, optionalTarget ) {

		var intersects = optionalTarget || [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive, optionalTarget ) {

		var intersects = optionalTarget || [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	BufferAttribute.call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

} );

// export * from '../../build/three.js';
function Float32BufferAttribute$1( array, itemSize, normalized ) {
  if(Array.isArray( array )){
    array = new Float32Array( array );
  }
	BufferAttribute.call( this, array, itemSize, normalized );

}

Float32BufferAttribute$1.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute$1.prototype.constructor = Float32BufferAttribute$1;

var THREE$1 = /*#__PURE__*/Object.freeze({
Float32BufferAttribute: Float32BufferAttribute$1,
Scene: Scene,
WebGLRenderer: WebGLRenderer,
CanvasTexture: CanvasTexture,
Object3D: Object3D,
Group: Group,
Clock: Clock,
Points: Points,
LineSegments: LineSegments,
Mesh: Mesh,
Texture: Texture,
WebGLRenderTarget: WebGLRenderTarget,
PerspectiveCamera: PerspectiveCamera,
OrthographicCamera: OrthographicCamera,
BufferGeometry: BufferGeometry,
InstancedBufferGeometry: InstancedBufferGeometry,
PlaneBufferGeometry: PlaneBufferGeometry,
BoxBufferGeometry: BoxBufferGeometry,
Raycaster: Raycaster,
UniformsUtils: UniformsUtils,
Matrix4: Matrix4,
Matrix3: Matrix3,
Line: Line,
Vector4: Vector4,
Vector3: Vector3,
Vector2: Vector2,
ShaderMaterial: ShaderMaterial,
DataTexture: DataTexture,
Color: Color,
Float64BufferAttribute: Float64BufferAttribute,
Uint32BufferAttribute: Uint32BufferAttribute,
Int32BufferAttribute: Int32BufferAttribute,
Uint16BufferAttribute: Uint16BufferAttribute,
Int16BufferAttribute: Int16BufferAttribute,
Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,
Uint8BufferAttribute: Uint8BufferAttribute,
Int8BufferAttribute: Int8BufferAttribute,
BufferAttribute: BufferAttribute,
InstancedBufferAttribute: InstancedBufferAttribute,
REVISION: REVISION,
MOUSE: MOUSE,
CullFaceNone: CullFaceNone,
CullFaceBack: CullFaceBack,
CullFaceFront: CullFaceFront,
CullFaceFrontBack: CullFaceFrontBack,
FrontFaceDirectionCW: FrontFaceDirectionCW,
FrontFaceDirectionCCW: FrontFaceDirectionCCW,
BasicShadowMap: BasicShadowMap,
PCFShadowMap: PCFShadowMap,
PCFSoftShadowMap: PCFSoftShadowMap,
FrontSide: FrontSide,
BackSide: BackSide,
DoubleSide: DoubleSide,
FlatShading: FlatShading,
SmoothShading: SmoothShading,
NoColors: NoColors,
FaceColors: FaceColors,
VertexColors: VertexColors,
NoBlending: NoBlending,
NormalBlending: NormalBlending,
AdditiveBlending: AdditiveBlending,
SubtractiveBlending: SubtractiveBlending,
MultiplyBlending: MultiplyBlending,
CustomBlending: CustomBlending,
AddEquation: AddEquation,
SubtractEquation: SubtractEquation,
ReverseSubtractEquation: ReverseSubtractEquation,
MinEquation: MinEquation,
MaxEquation: MaxEquation,
ZeroFactor: ZeroFactor,
OneFactor: OneFactor,
SrcColorFactor: SrcColorFactor,
OneMinusSrcColorFactor: OneMinusSrcColorFactor,
SrcAlphaFactor: SrcAlphaFactor,
OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,
DstAlphaFactor: DstAlphaFactor,
OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,
DstColorFactor: DstColorFactor,
OneMinusDstColorFactor: OneMinusDstColorFactor,
SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,
NeverDepth: NeverDepth,
AlwaysDepth: AlwaysDepth,
LessDepth: LessDepth,
LessEqualDepth: LessEqualDepth,
EqualDepth: EqualDepth,
GreaterEqualDepth: GreaterEqualDepth,
GreaterDepth: GreaterDepth,
NotEqualDepth: NotEqualDepth,
MultiplyOperation: MultiplyOperation,
MixOperation: MixOperation,
AddOperation: AddOperation,
NoToneMapping: NoToneMapping,
LinearToneMapping: LinearToneMapping,
ReinhardToneMapping: ReinhardToneMapping,
Uncharted2ToneMapping: Uncharted2ToneMapping,
CineonToneMapping: CineonToneMapping,
ACESFilmicToneMapping: ACESFilmicToneMapping,
UVMapping: UVMapping,
CubeReflectionMapping: CubeReflectionMapping,
CubeRefractionMapping: CubeRefractionMapping,
EquirectangularReflectionMapping: EquirectangularReflectionMapping,
EquirectangularRefractionMapping: EquirectangularRefractionMapping,
SphericalReflectionMapping: SphericalReflectionMapping,
CubeUVReflectionMapping: CubeUVReflectionMapping,
CubeUVRefractionMapping: CubeUVRefractionMapping,
RepeatWrapping: RepeatWrapping,
ClampToEdgeWrapping: ClampToEdgeWrapping,
MirroredRepeatWrapping: MirroredRepeatWrapping,
NearestFilter: NearestFilter,
NearestMipMapNearestFilter: NearestMipMapNearestFilter,
NearestMipMapLinearFilter: NearestMipMapLinearFilter,
LinearFilter: LinearFilter,
LinearMipMapNearestFilter: LinearMipMapNearestFilter,
LinearMipMapLinearFilter: LinearMipMapLinearFilter,
UnsignedByteType: UnsignedByteType,
ByteType: ByteType,
ShortType: ShortType,
UnsignedShortType: UnsignedShortType,
IntType: IntType,
UnsignedIntType: UnsignedIntType,
FloatType: FloatType,
HalfFloatType: HalfFloatType,
UnsignedShort4444Type: UnsignedShort4444Type,
UnsignedShort5551Type: UnsignedShort5551Type,
UnsignedShort565Type: UnsignedShort565Type,
UnsignedInt248Type: UnsignedInt248Type,
AlphaFormat: AlphaFormat,
RGBFormat: RGBFormat,
RGBAFormat: RGBAFormat,
LuminanceFormat: LuminanceFormat,
LuminanceAlphaFormat: LuminanceAlphaFormat,
RGBEFormat: RGBEFormat,
DepthFormat: DepthFormat,
DepthStencilFormat: DepthStencilFormat,
RedFormat: RedFormat,
RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
RGB_ETC1_Format: RGB_ETC1_Format,
RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
LoopOnce: LoopOnce,
LoopRepeat: LoopRepeat,
LoopPingPong: LoopPingPong,
InterpolateDiscrete: InterpolateDiscrete,
InterpolateLinear: InterpolateLinear,
InterpolateSmooth: InterpolateSmooth,
ZeroCurvatureEnding: ZeroCurvatureEnding,
ZeroSlopeEnding: ZeroSlopeEnding,
WrapAroundEnding: WrapAroundEnding,
TrianglesDrawMode: TrianglesDrawMode,
TriangleStripDrawMode: TriangleStripDrawMode,
TriangleFanDrawMode: TriangleFanDrawMode,
LinearEncoding: LinearEncoding,
sRGBEncoding: sRGBEncoding,
GammaEncoding: GammaEncoding,
RGBEEncoding: RGBEEncoding,
LogLuvEncoding: LogLuvEncoding,
RGBM7Encoding: RGBM7Encoding,
RGBM16Encoding: RGBM16Encoding,
RGBDEncoding: RGBDEncoding,
BasicDepthPacking: BasicDepthPacking,
RGBADepthPacking: RGBADepthPacking,
TangentSpaceNormalMap: TangentSpaceNormalMap,
ObjectSpaceNormalMap: ObjectSpaceNormalMap
});

var isArrayLike_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var isArrayLike = function (value) {
    /**
     * isArrayLike([1, 2, 3]) => true
     * isArrayLike(document.body.children) => true
     * isArrayLike('abc') => true
     * isArrayLike(Function) => false
     */
    return value !== null && typeof value !== 'function' && isFinite(value.length);
};
exports["default"] = isArrayLike;

});

unwrapExports$$1(isArrayLike_1);

var contains_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var contains = function (arr, value) {
    if (!isArrayLike_1["default"](arr)) {
        return false;
    }
    return arr.indexOf(value) > -1;
};
exports["default"] = contains;

});

unwrapExports$$1(contains_1);

var isType_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var toString = {}.toString;
var isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };
exports["default"] = isType;

});

unwrapExports$$1(isType_1);

var isArray = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = (function (value) {
    return Array.isArray ?
        Array.isArray(value) :
        isType_1["default"](value, 'Array');
});

});

unwrapExports$$1(isArray);

var isObject = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
exports["default"] = (function (value) {
    /**
     * isObject({}) => true
     * isObject([1, 2, 3]) => true
     * isObject(Function) => true
     * isObject(null) => false
     */
    var type = typeof value;
    return value !== null && type === 'object' || type === 'function';
});

});

unwrapExports$$1(isObject);

var each_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


function each(elements, func) {
    if (!elements) {
        return;
    }
    var rst;
    if (isArray["default"](elements)) {
        for (var i = 0, len = elements.length; i < len; i++) {
            rst = func(elements[i], i);
            if (rst === false) {
                break;
            }
        }
    }
    else if (isObject["default"](elements)) {
        for (var k in elements) {
            if (elements.hasOwnProperty(k)) {
                rst = func(elements[k], k);
                if (rst === false) {
                    break;
                }
            }
        }
    }
}
exports["default"] = each;

});

unwrapExports$$1(each_1);

var filter_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var filter = function (arr, func) {
    if (!isArrayLike_1["default"](arr)) {
        return arr;
    }
    var result = [];
    each_1["default"](arr, function (value, index) {
        if (func(value, index)) {
            result.push(value);
        }
    });
    return result;
};
exports["default"] = filter;

});

unwrapExports$$1(filter_1);

var difference_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to inspect.
 * @param {Array} values The values to exclude.
 * @return {Array} Returns the new array of filtered values.
 * @example
 * difference([2, 1], [2, 3]);  // => [1]
 */
var difference = function (arr, values) {
    if (values === void 0) { values = []; }
    return filter_1["default"](arr, function (value) { return !contains_1["default"](values, value); });
};
exports["default"] = difference;

});

unwrapExports$$1(difference_1);

var isFunction = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 是否为函数
 * @param  {*} fn 对象
 * @return {Boolean}  是否函数
 */

exports["default"] = (function (value) {
    return isType_1["default"](value, 'Function');
});

});

unwrapExports$$1(isFunction);

var isNil_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
// isFinite,
var isNil = function (value) {
    /**
     * isNil(null) => true
     * isNil() => true
     */
    return value === null || value === undefined;
};
exports["default"] = isNil;

});

unwrapExports$$1(isNil_1);

var keys_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {
    var result = [];
    each_1["default"](obj, function (value, key) {
        if (!(isFunction["default"](obj) && key === 'prototype')) {
            result.push(key);
        }
    });
    return result;
};
exports["default"] = keys;

});

unwrapExports$$1(keys_1);

var isMatch_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


function isMatch(obj, attrs) {
    var _keys = keys_1["default"](attrs);
    var length = _keys.length;
    if (isNil_1["default"](obj))
        { return !length; }
    for (var i = 0; i < length; i += 1) {
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) {
            return false;
        }
    }
    return true;
}
exports["default"] = isMatch;

});

unwrapExports$$1(isMatch_1);

var isObjectLike_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var isObjectLike = function (value) {
    /**
     * isObjectLike({}) => true
     * isObjectLike([1, 2, 3]) => true
     * isObjectLike(Function) => false
     * isObjectLike(null) => false
     */
    return typeof value === 'object' && value !== null;
};
exports["default"] = isObjectLike;

});

unwrapExports$$1(isObjectLike_1);

var isPlainObject_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var isPlainObject = function (value) {
    /**
     * isObjectLike(new Foo) => false
     * isObjectLike([1, 2, 3]) => false
     * isObjectLike({ x: 0, y: 0 }) => true
     * isObjectLike(Object.create(null)) => true
     */
    if (!isObjectLike_1["default"](value) || !isType_1["default"](value, 'Object')) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
};
exports["default"] = isPlainObject;

});

unwrapExports$$1(isPlainObject_1);

var find_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;




function find(arr, predicate) {
    if (!isArray["default"](arr))
        { return null; }
    var _predicate;
    if (isFunction["default"](predicate)) {
        _predicate = predicate;
    }
    if (isPlainObject_1["default"](predicate)) {
        _predicate = function (a) { return isMatch_1["default"](a, predicate); };
    }
    if (_predicate) {
        for (var i = 0; i < arr.length; i += 1) {
            if (_predicate(arr[i])) {
                return arr[i];
            }
        }
    }
    return null;
}
exports["default"] = find;

});

unwrapExports$$1(find_1);

var findIndex_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
function findIndex(arr, predicate, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    for (var i = fromIndex; i < arr.length; i++) {
        if (predicate(arr[i], i)) {
            // 找到终止循环
            return i;
        }
    }
    return -1;
}
exports["default"] = findIndex;

});

unwrapExports$$1(findIndex_1);

var firstValue_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var firstValue = function (data, name) {
    var rst = null;
    for (var i = 0; i < data.length; i++) {
        var obj = data[i];
        var value = obj[name];
        if (!isNil_1["default"](value)) {
            if (isArray["default"](value)) {
                rst = value[0]; // todo 这里是否应该使用递归，调用 firstValue @绝云
            }
            else {
                rst = value;
            }
            break;
        }
    }
    return rst;
};
exports["default"] = firstValue;

});

unwrapExports$$1(firstValue_1);

var flatten_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
 */
var flatten = function (arr) {
    if (!isArray["default"](arr)) {
        return [];
    }
    var rst = [];
    for (var i = 0; i < arr.length; i++) {
        rst = rst.concat(arr[i]);
    }
    return rst;
};
exports["default"] = flatten;

});

var flatten$1 = unwrapExports$$1(flatten_1);

var flattenDeep_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @param {Array} result The array to return.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]
 */
var flattenDeep = function (arr, result) {
    if (result === void 0) { result = []; }
    if (!isArray["default"](arr)) {
        result.push(arr);
    }
    else {
        for (var i = 0; i < arr.length; i += 1) {
            flattenDeep(arr[i], result);
        }
    }
    return result;
};
exports["default"] = flattenDeep;

});

unwrapExports$$1(flattenDeep_1);

var getRange_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var getRange = function (values) {
    // 存在 NaN 时，min,max 判定会出问题
    values = filter_1["default"](values, function (v) {
        return !isNaN(v);
    });
    if (!values.length) { // 如果没有数值则直接返回0
        return {
            min: 0,
            max: 0
        };
    }
    if (isArray["default"](values[0])) {
        var tmp = [];
        for (var i = 0; i < values.length; i++) {
            tmp = tmp.concat(values[i]);
        }
        values = tmp;
    }
    var max = Math.max.apply(null, values);
    var min = Math.min.apply(null, values);
    return {
        min: min,
        max: max
    };
};
exports["default"] = getRange;

});

unwrapExports$$1(getRange_1);

var pull_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;
var pull = function (arr) {
    var arguments$1 = arguments;

    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments$1[_i];
    }
    for (var i = 0; i < values.length; i++) {
        var value = values[i];
        var fromIndex = -1;
        while ((fromIndex = indexOf.call(arr, value)) > -1) {
            splice.call(arr, fromIndex, 1);
        }
    }
    return arr;
};
exports["default"] = pull;

});

unwrapExports$$1(pull_1);

var pullAt_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var splice = Array.prototype.splice;
var pullAt = function pullAt(arr, indexes) {
    if (!isArrayLike_1["default"](arr)) {
        return [];
    }
    var length = arr ? indexes.length : 0;
    var last = length - 1;
    while (length--) {
        var previous = void 0;
        var index = indexes[length];
        if (length === last || index !== previous) {
            previous = index;
            splice.call(arr, index, 1);
        }
    }
    return arr;
};
exports["default"] = pullAt;

});

unwrapExports$$1(pullAt_1);

var reduce_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



var reduce = function (arr, fn, init) {
    if (!isArray["default"](arr) && !isPlainObject_1["default"](arr)) {
        return arr;
    }
    var result = init;
    each_1["default"](arr, function (data, i) {
        result = fn(result, data, i);
    });
    return result;
};
exports["default"] = reduce;

});

unwrapExports$$1(reduce_1);

var remove_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var remove = function (arr, predicate) {
    /**
     * const arr = [1, 2, 3, 4]
     * const evens = remove(arr, n => n % 2 == 0)
     * console.log(arr) // => [1, 3]
     * console.log(evens) // => [2, 4]
     */
    var result = [];
    if (!isArrayLike_1["default"](arr)) {
        return result;
    }
    var i = -1;
    var indexes = [];
    var length = arr.length;
    while (++i < length) {
        var value = arr[i];
        if (predicate(value, i, arr)) {
            result.push(value);
            indexes.push(i);
        }
    }
    pullAt_1["default"](arr, indexes);
    return result;
};
exports["default"] = remove;

});

unwrapExports$$1(remove_1);

var isString = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = (function (str) {
    return isType_1["default"](str, 'String');
});

});

var isString$1 = unwrapExports$$1(isString);

var sortBy_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



function sortBy(arr, key) {
    var comparer;
    if (isFunction["default"](key)) {
        comparer = function (a, b) { return key(a) - key(b); };
    }
    else {
        var keys_1 = [];
        if (isString["default"](key)) {
            keys_1.push(key);
        }
        else if (isArray["default"](key)) {
            keys_1 = key;
        }
        comparer = function (a, b) {
            for (var i = 0; i < keys_1.length; i += 1) {
                var prop = keys_1[i];
                if (a[prop] > b[prop]) {
                    return 1;
                }
                if (a[prop] < b[prop]) {
                    return -1;
                }
            }
            return 0;
        };
    }
    arr.sort(comparer);
    return arr;
}
exports["default"] = sortBy;

});

unwrapExports$$1(sortBy_1);

var uniq_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var uniq = function (arr) {
    var resultArr = [];
    each_1["default"](arr, function (item) {
        if (!contains_1["default"](resultArr, item)) {
            resultArr.push(item);
        }
    });
    return resultArr;
};
exports["default"] = uniq;

});

var uniq = unwrapExports$$1(uniq_1);

var union_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var union = function () {
    var arguments$1 = arguments;

    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments$1[_i];
    }
    return uniq_1["default"]([].concat.apply([], sources));
};
exports["default"] = union;

});

unwrapExports$$1(union_1);

var valuesOfKey = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



exports["default"] = (function (data, name) {
    var rst = [];
    var tmpMap = {};
    data.forEach(function (obj) {
        var value = obj[name];
        if (!isNil_1["default"](value)) {
            // flatten
            if (!isArray["default"](value)) {
                value = [value];
            }
            each_1["default"](value, function (val) {
                // unique
                if (!tmpMap[val]) {
                    rst.push(val);
                    tmpMap[val] = true;
                }
            });
        }
    });
    return rst;
});

});

unwrapExports$$1(valuesOfKey);

var head_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

function head(o) {
    if (isArrayLike_1["default"](o)) {
        return o[0];
    }
    return undefined;
}
exports["default"] = head;

});

unwrapExports$$1(head_1);

var last_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

function last(o) {
    if (isArrayLike_1["default"](o)) {
        var arr = o;
        return arr[arr.length - 1];
    }
    return undefined;
}
exports["default"] = last;

});

unwrapExports$$1(last_1);

var startsWith_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


function startsWith(arr, e) {
    return (isArray["default"](arr) || isString["default"](arr)) ? arr[0] === e : false;
}
exports["default"] = startsWith;

});

unwrapExports$$1(startsWith_1);

var endsWith_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


function endsWith(arr, e) {
    return (isArray["default"](arr) || isString["default"](arr)) ? arr[arr.length - 1] === e : false;
}
exports["default"] = endsWith;

});

unwrapExports$$1(endsWith_1);

var every_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 只要有一个不满足条件就返回 false
 * @param arr
 * @param func
 */
var every = function (arr, func) {
    for (var i = 0; i < arr.length; i++) {
        if (!func(arr[i], i))
            { return false; }
    }
    return true;
};
exports["default"] = every;

});

unwrapExports$$1(every_1);

var some_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 只要有一个满足条件就返回 true
 * @param arr
 * @param func
 */
var some = function (arr, func) {
    for (var i = 0; i < arr.length; i++) {
        if (func(arr[i], i))
            { return true; }
    }
    return false;
};
exports["default"] = some;

});

unwrapExports$$1(some_1);

var groupBy_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



var hasOwnProperty = Object.prototype.hasOwnProperty;
function groupBy(data, condition) {
    if (!condition || !isArray["default"](data)) {
        return {};
    }
    var result = {};
    // 兼容方法和 字符串的写法
    var predicate = isFunction["default"](condition) ? condition : function (item) { return item[condition]; };
    var key;
    each_1["default"](data, function (item) {
        key = predicate(item);
        if (hasOwnProperty.call(result, key)) {
            result[key].push(item);
        }
        else {
            result[key] = [item];
        }
    });
    return result;
}
exports["default"] = groupBy;

});

unwrapExports$$1(groupBy_1);

var groupToMap_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



var groupToMap = function (data, condition) {
    if (!condition) {
        return {
            0: data
        };
    }
    if (!isFunction["default"](condition)) {
        var paramsCondition_1 = isArray["default"](condition) ? condition : condition.replace(/\s+/g, '').split('*');
        condition = function (row) {
            var unique = '_'; // 避免出现数字作为Key的情况，会进行按照数字的排序
            for (var i = 0, l = paramsCondition_1.length; i < l; i++) {
                unique += row[paramsCondition_1[i]] && row[paramsCondition_1[i]].toString();
            }
            return unique;
        };
    }
    var groups = groupBy_1["default"](data, condition);
    return groups;
};
exports["default"] = groupToMap;

});

unwrapExports$$1(groupToMap_1);

var group = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = (function (data, condition) {
    if (!condition) {
        // 没有条件，则自身改成数组
        return [data];
    }
    var groups = groupToMap_1["default"](data, condition);
    var array = [];
    for (var i in groups) {
        array.push(groups[i]);
    }
    return array;
});

});

unwrapExports$$1(group);

var getWrapBehavior_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 获取封装的事件
 * @protected
 * @param  {Object} obj   对象
 * @param  {String} action 事件名称
 * @return {Function}        返回事件处理函数
 */
function getWrapBehavior(obj, action) {
    return obj['_wrap_' + action];
}
exports["default"] = getWrapBehavior;

});

unwrapExports$$1(getWrapBehavior_1);

var wrapBehavior_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 封装事件，便于使用上下文this,和便于解除事件时使用
 * @protected
 * @param  {Object} obj   对象
 * @param  {String} action 事件名称
 * @return {Function}        返回事件处理函数
 */
function wrapBehavior(obj, action) {
    if (obj['_wrap_' + action]) {
        return obj['_wrap_' + action];
    }
    var method = function (e) {
        obj[action](e);
    };
    obj['_wrap_' + action] = method;
    return method;
}
exports["default"] = wrapBehavior;

});

unwrapExports$$1(wrapBehavior_1);

var number2color = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var numColorCache = {};
function numberToColor(num) {
    // 增加缓存
    var color = numColorCache[num];
    if (!color) {
        var str = num.toString(16);
        for (var i = str.length; i < 6; i++) {
            str = '0' + str;
        }
        color = '#' + str;
        numColorCache[num] = color;
    }
    return color;
}
exports["default"] = numberToColor;

});

unwrapExports$$1(number2color);

var parseRadius_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

function parseRadius(radius) {
    var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
    if (isArray["default"](radius)) {
        if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
        }
        else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
        }
        else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
        }
        else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = radius;
    }
    return {
        r1: r1,
        r2: r2,
        r3: r3,
        r4: r4
    };
}
exports["default"] = parseRadius;

});

unwrapExports$$1(parseRadius_1);

var clamp_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var clamp = function (a, min, max) {
    if (a < min) {
        return min;
    }
    else if (a > max) {
        return max;
    }
    return a;
};
exports["default"] = clamp;

});

unwrapExports$$1(clamp_1);

var fixedBase_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var fixedBase = function (v, base) {
    var str = base.toString();
    var index = str.indexOf('.');
    if (index === -1) {
        return Math.round(v);
    }
    var length = str.substr(index + 1).length;
    if (length > 20) {
        length = 20;
    }
    return parseFloat(v.toFixed(length));
};
exports["default"] = fixedBase;

});

unwrapExports$$1(fixedBase_1);

var isNumber_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 判断是否数字
 * @return {Boolean} 是否数字
 */

var isNumber = function (value) {
    return isType_1["default"](value, 'Number');
};
exports["default"] = isNumber;

});

unwrapExports$$1(isNumber_1);

var isDecimal_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isDecimal = function (num) {
    return isNumber_1["default"](num) && num % 1 !== 0;
};
exports["default"] = isDecimal;

});

unwrapExports$$1(isDecimal_1);

var isEven_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isEven = function (num) {
    return isNumber_1["default"](num) && num % 2 === 0;
};
exports["default"] = isEven;

});

unwrapExports$$1(isEven_1);

var isInteger_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isInteger = Number.isInteger ? Number.isInteger : function (num) {
    return isNumber_1["default"](num) && num % 1 === 0;
};
exports["default"] = isInteger;

});

unwrapExports$$1(isInteger_1);

var isNegative_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isNegative = function (num) {
    return isNumber_1["default"](num) && num < 0;
};
exports["default"] = isNegative;

});

unwrapExports$$1(isNegative_1);

var isNumberEqual_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var PRECISION = 0.00001; // numbers less than this is considered as 0
function isNumberEqual(a, b, precision) {
    if (precision === void 0) { precision = PRECISION; }
    return Math.abs((a - b)) < precision;
}
exports["default"] = isNumberEqual;

});

unwrapExports$$1(isNumberEqual_1);

var isOdd_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isOdd = function (num) {
    return isNumber_1["default"](num) && num % 2 !== 0;
};
exports["default"] = isOdd;

});

unwrapExports$$1(isOdd_1);

var isPositive_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isPositive = function (num) {
    return isNumber_1["default"](num) && num > 0;
};
exports["default"] = isPositive;

});

unwrapExports$$1(isPositive_1);

var maxBy = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
exports["default"] = (function (arr, fn) {
    if (!isArray["default"](arr)) {
        return undefined;
    }
    var max = arr[0];
    var maxData;
    if (isFunction["default"](fn)) {
        maxData = fn(arr[0]);
    }
    else {
        maxData = arr[0][fn];
    }
    var data;
    each_1["default"](arr, function (val) {
        if (isFunction["default"](fn)) {
            data = fn(val);
        }
        else {
            data = val[fn];
        }
        if (data > maxData) {
            max = val;
            maxData = data;
        }
    });
    return max;
});

});

unwrapExports$$1(maxBy);

var minBy = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * minBy(objects, 'n');
 * // => { 'n': 1 }
 */
exports["default"] = (function (arr, fn) {
    if (!isArray["default"](arr)) {
        return undefined;
    }
    var min = arr[0];
    var minData;
    if (isFunction["default"](fn)) {
        minData = fn(arr[0]);
    }
    else {
        minData = arr[0][fn];
    }
    var data;
    each_1["default"](arr, function (val) {
        if (isFunction["default"](fn)) {
            data = fn(val);
        }
        else {
            data = val[fn];
        }
        if (data < minData) {
            min = val;
            minData = data;
        }
    });
    return min;
});

});

unwrapExports$$1(minBy);

var mod_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var mod = function (n, m) {
    return ((n % m) + m) % m;
};
exports["default"] = mod;

});

unwrapExports$$1(mod_1);

var toDegree_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var DEGREE = 180 / Math.PI;
var toDegree = function (radian) {
    return DEGREE * radian;
};
exports["default"] = toDegree;

});

unwrapExports$$1(toDegree_1);

var toInteger = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
exports["default"] = parseInt;

});

unwrapExports$$1(toInteger);

var toRadian_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var RADIAN = Math.PI / 180;
var toRadian = function (degree) {
    return RADIAN * degree;
};
exports["default"] = toRadian;

});

unwrapExports$$1(toRadian_1);

var forIn = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = each_1["default"];

});

unwrapExports$$1(forIn);

var has = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
exports["default"] = (function (obj, key) { return obj.hasOwnProperty(key); });

});

unwrapExports$$1(has);

var hasKey = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = has["default"];

});

unwrapExports$$1(hasKey);

var values_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


// @ts-ignore
var values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {
    var result = [];
    each_1["default"](obj, function (value, key) {
        if (!(isFunction["default"](obj) && key === 'prototype')) {
            result.push(value);
        }
    });
    return result;
};
exports["default"] = values;

});

unwrapExports$$1(values_1);

var hasValue = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


exports["default"] = (function (obj, value) { return contains_1["default"](values_1["default"](obj), value); });

});

unwrapExports$$1(hasValue);

var toString_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = (function (value) {
    if (isNil_1["default"](value))
        { return ''; }
    return value.toString();
});

});

unwrapExports$$1(toString_1);

var lowerCase_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var lowerCase = function (str) {
    return toString_1["default"](str).toLowerCase();
};
exports["default"] = lowerCase;

});

unwrapExports$$1(lowerCase_1);

var lowerFirst_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var lowerFirst = function (value) {
    var str = toString_1["default"](value);
    return str.charAt(0).toLowerCase() + str.substring(1);
};
exports["default"] = lowerFirst;

});

unwrapExports$$1(lowerFirst_1);

var substitute_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
function substitute(str, o) {
    if (!str || !o) {
        return str;
    }
    return str.replace(/\\?\{([^{}]+)\}/g, function (match, name) {
        if (match.charAt(0) === '\\') {
            return match.slice(1);
        }
        return (o[name] === undefined) ? '' : o[name];
    });
}
exports["default"] = substitute;

});

unwrapExports$$1(substitute_1);

var upperCase_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var upperCase = function (str) {
    return toString_1["default"](str).toUpperCase();
};
exports["default"] = upperCase;

});

unwrapExports$$1(upperCase_1);

var upperFirst_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var upperFirst = function (value) {
    var str = toString_1["default"](value);
    return str.charAt(0).toUpperCase() + str.substring(1);
};
exports["default"] = upperFirst;

});

unwrapExports$$1(upperFirst_1);

var getType_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var toString = {}.toString;
var getType = function (value) {
    return toString.call(value).replace(/^\[object /, '').replace(/]$/, '');
};
exports["default"] = getType;

});

unwrapExports$$1(getType_1);

var isArguments_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 是否是参数类型
 *
 * @param {Object} value 测试的值
 * @return {Boolean}
 */

var isArguments = function (value) {
    return isType_1["default"](value, 'Arguments');
};
exports["default"] = isArguments;

});

unwrapExports$$1(isArguments_1);

var isBoolean_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 是否是布尔类型
 *
 * @param {Object} value 测试的值
 * @return {Boolean}
 */

var isBoolean = function (value) {
    return isType_1["default"](value, 'Boolean');
};
exports["default"] = isBoolean;

});

unwrapExports$$1(isBoolean_1);

var isDate_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isDate = function (value) {
    return isType_1["default"](value, 'Date');
};
exports["default"] = isDate;

});

unwrapExports$$1(isDate_1);

var isError_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 是否是参数类型
 *
 * @param {Object} value 测试的值
 * @return {Boolean}
 */

var isError = function (value) {
    return isType_1["default"](value, 'Error');
};
exports["default"] = isError;

});

unwrapExports$$1(isError_1);

var _isFinite = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 判断是否为有限数
 * @return {Boolean}
 */

function default_1(value) {
    return isNumber_1["default"](value) && isFinite(value);
}
exports["default"] = default_1;

});

unwrapExports$$1(_isFinite);

var isNull_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var isNull = function (value) {
    return value === null;
};
exports["default"] = isNull;

});

unwrapExports$$1(isNull_1);

var isPrototype_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var objectProto = Object.prototype;
var isPrototype = function (value) {
    var Ctor = value && value.constructor;
    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;
    return value === proto;
};
exports["default"] = isPrototype;

});

unwrapExports$$1(isPrototype_1);

var isRegExp_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var isRegExp = function (str) {
    return isType_1["default"](str, 'RegExp');
};
exports["default"] = isRegExp;

});

unwrapExports$$1(isRegExp_1);

var isUndefined_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var isUndefined = function (value) {
    return value === undefined;
};
exports["default"] = isUndefined;

});

unwrapExports$$1(isUndefined_1);

var isElement_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * 判断是否HTML元素
 * @return {Boolean} 是否HTML元素
 */
var isElement = function (o) {
    return o instanceof Element || o instanceof HTMLDocument;
};
exports["default"] = isElement;

});

unwrapExports$$1(isElement_1);

var requestAnimationFrame_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
function requestAnimationFrame(fn) {
    var method = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        // @ts-ignore
        window.mozRequestAnimationFrame ||
        // @ts-ignore
        window.msRequestAnimationFrame ||
        function (f) {
            return setTimeout(f, 16);
        };
    return method(fn);
}
exports["default"] = requestAnimationFrame;

});

unwrapExports$$1(requestAnimationFrame_1);

var clearAnimationFrame = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
function cancelAnimationFrame(handler) {
    var method = window.cancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        // @ts-ignore
        window.mozCancelAnimationFrame ||
        // @ts-ignore
        window.msCancelAnimationFrame ||
        clearTimeout;
    method(handler);
}
exports["default"] = cancelAnimationFrame;

});

unwrapExports$$1(clearAnimationFrame);

var mix_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
// FIXME: Mutable param should be forbidden in static lang.
function _mix(dist, obj) {
    for (var key in obj) {
        if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
            dist[key] = obj[key];
        }
    }
}
function mix(dist, src1, src2, src3) {
    if (src1)
        { _mix(dist, src1); }
    if (src2)
        { _mix(dist, src2); }
    if (src3)
        { _mix(dist, src3); }
    return dist;
}
exports["default"] = mix;

});

unwrapExports$$1(mix_1);

var augment_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var augment = function () {
    var arguments$1 = arguments;

    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
    }
    var c = args[0];
    for (var i = 1; i < args.length; i++) {
        var obj = args[i];
        if (isFunction["default"](obj)) {
            obj = obj.prototype;
        }
        mix_1["default"](c.prototype, obj);
    }
};
exports["default"] = augment;

});

unwrapExports$$1(augment_1);

var clone_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var clone = function (obj) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    var rst;
    if (isArray["default"](obj)) {
        rst = [];
        for (var i = 0, l = obj.length; i < l; i++) {
            if (typeof obj[i] === 'object' && obj[i] != null) {
                rst[i] = clone(obj[i]);
            }
            else {
                rst[i] = obj[i];
            }
        }
    }
    else {
        rst = {};
        for (var k in obj) {
            if (typeof obj[k] === 'object' && obj[k] != null) {
                rst[k] = clone(obj[k]);
            }
            else {
                rst[k] = obj[k];
            }
        }
    }
    return rst;
};
exports["default"] = clone;

});

unwrapExports$$1(clone_1);

var debounce_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
function debounce(func, wait, immediate) {
    var timeout;
    return function () {
        var context = this, args = arguments;
        var later = function () {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(context, args);
        }
    };
}
exports["default"] = debounce;

});

unwrapExports$$1(debounce_1);

var cache = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
/**
 * k-v 存储
 */
var default_1 = /** @class */ (function () {
    function default_1() {
        this.map = {};
    }
    default_1.prototype.has = function (key) {
        return this.map[key] !== undefined;
    };
    default_1.prototype.get = function (key, def) {
        var v = this.map[key];
        return v === undefined ? def : v;
    };
    default_1.prototype.set = function (key, value) {
        this.map[key] = value;
    };
    default_1.prototype.clear = function () {
        this.map = {};
    };
    default_1.prototype["delete"] = function (key) {
        delete this.map[key];
    };
    default_1.prototype.size = function () {
        return Object.keys(this.map).length;
    };
    return default_1;
}());
exports["default"] = default_1;

});

unwrapExports$$1(cache);

var memoize = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


/**
 * _.memoize(calColor);
 * _.memoize(calColor, (...args) => args[0]);
 * @param f
 * @param resolver
 */
exports["default"] = (function (f, resolver) {
    if (!isFunction["default"](f)) {
        throw new TypeError('Expected a function');
    }
    var memoized = function () {
        var arguments$1 = arguments;

        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments$1[_i];
        }
        // 使用方法构造 key，如果不存在 resolver，则直接取第一个参数作为 key
        var key = resolver ? resolver.apply(this, args) : args[0];
        var cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = f.apply(this, args);
        // 缓存起来
        cache.set(key, result);
        return result;
    };
    memoized.cache = new cache["default"]();
    return memoized;
});

});

unwrapExports$$1(memoize);

var deepMix_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var MAX_MIX_LEVEL = 5;
function _deepMix(dist, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
        if (src.hasOwnProperty(key)) {
            var value = src[key];
            if (value !== null && isPlainObject_1["default"](value)) {
                if (!isPlainObject_1["default"](dist[key])) {
                    dist[key] = {};
                }
                if (level < maxLevel) {
                    _deepMix(dist[key], value, level + 1, maxLevel);
                }
                else {
                    dist[key] = src[key];
                }
            }
            else if (isArray["default"](value)) {
                dist[key] = [];
                dist[key] = dist[key].concat(value);
            }
            else if (value !== undefined) {
                dist[key] = value;
            }
        }
    }
}
// todo 重写
var deepMix = function (rst) {
    var arguments$1 = arguments;

    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments$1[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
        _deepMix(rst, args[i]);
    }
    return rst;
};
exports["default"] = deepMix;

});

var merge = unwrapExports$$1(deepMix_1);

var extend_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var extend = function (subclass, superclass, overrides, staticOverrides) {
    // 如果只提供父类构造函数，则自动生成子类构造函数
    if (!isFunction["default"](superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = function () { };
    }
    var create = Object.create ?
        function (proto, c) {
            return Object.create(proto, {
                constructor: {
                    value: c
                }
            });
        } :
        function (proto, c) {
            function Tmp() { }
            Tmp.prototype = proto;
            var o = new Tmp();
            o.constructor = c;
            return o;
        };
    var superObj = create(superclass.prototype, subclass); // new superclass(),//实例化父类作为子类的prototype
    subclass.prototype = mix_1["default"](superObj, subclass.prototype); // 指定子类的prototype
    subclass.superclass = create(superclass.prototype, superclass);
    mix_1["default"](superObj, overrides);
    mix_1["default"](subclass, staticOverrides);
    return subclass;
};
exports["default"] = extend;

});

unwrapExports$$1(extend_1);

var indexOf_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

var indexOf = function (arr, obj) {
    if (!isArrayLike_1["default"](arr)) {
        return -1;
    }
    var m = Array.prototype.indexOf;
    if (m) {
        return m.call(arr, obj);
    }
    var index = -1;
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === obj) {
            index = i;
            break;
        }
    }
    return index;
};
exports["default"] = indexOf;

});

unwrapExports$$1(indexOf_1);

var isEmpty_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;




var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmpty(value) {
    /**
     * isEmpty(null) => true
     * isEmpty() => true
     * isEmpty(true) => true
     * isEmpty(1) => true
     * isEmpty([1, 2, 3]) => false
     * isEmpty('abc') => false
     * isEmpty({ a: 1 }) => false
     */
    if (isNil_1["default"](value)) {
        return true;
    }
    if (isArrayLike_1["default"](value)) {
        return !value.length;
    }
    var type = getType_1["default"](value);
    if (type === 'Map' || type === 'Set') {
        return !value.size;
    }
    if (isPrototype_1["default"](value)) {
        return !Object.keys(value).length;
    }
    for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
            return false;
        }
    }
    return true;
}
exports["default"] = isEmpty;

});

unwrapExports$$1(isEmpty_1);

var isEqual_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



var isEqual = function (value, other) {
    if (value === other) {
        return true;
    }
    if (!value || !other) {
        return false;
    }
    if (isString["default"](value) || isString["default"](other)) {
        return false;
    }
    if (isArrayLike_1["default"](value) || isArrayLike_1["default"](other)) {
        if (value.length !== other.length) {
            return false;
        }
        var rst = true;
        for (var i = 0; i < value.length; i++) {
            rst = isEqual(value[i], other[i]);
            if (!rst) {
                break;
            }
        }
        return rst;
    }
    if (isObjectLike_1["default"](value) || isObjectLike_1["default"](other)) {
        var valueKeys = Object.keys(value);
        var otherKeys = Object.keys(other);
        if (valueKeys.length !== otherKeys.length) {
            return false;
        }
        var rst = true;
        for (var i = 0; i < valueKeys.length; i++) {
            rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
            if (!rst) {
                break;
            }
        }
        return rst;
    }
    return false;
};
exports["default"] = isEqual;

});

unwrapExports$$1(isEqual_1);

var isEqualWith = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


/**
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [fn] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * isEqualWith(array, other, customizer);  // => true
 */
exports["default"] = (function (value, other, fn) {
    if (!isFunction["default"](fn)) {
        return isEqual_1["default"](value, other);
    }
    return !!fn(value, other);
});

});

unwrapExports$$1(isEqualWith);

var map_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var map = function (arr, func) {
    if (!isArrayLike_1["default"](arr)) {
        // @ts-ignore
        return arr;
    }
    var result = [];
    each_1["default"](arr, function (value, index) {
        result.push(func(value, index));
    });
    return result;
};
exports["default"] = map;

});

unwrapExports$$1(map_1);

var mapValues = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var identity = function (v) { return v; };
exports["default"] = (function (object, func) {
    if (func === void 0) { func = identity; }
    var r = {};
    if (isObject["default"](object) && !isNil_1["default"](object)) {
        Object.keys(object).forEach(function (key) {
            // @ts-ignore
            r[key] = func(object[key], key);
        });
    }
    return r;
});

});

unwrapExports$$1(mapValues);

var get = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param key
 * @param defaultValue
 */
exports["default"] = (function (obj, key, defaultValue) {
    var p = 0;
    var keyArr = isString["default"](key) ? key.split('.') : key;
    while (obj && p < keyArr.length) {
        obj = obj[keyArr[p++]];
    }
    return (obj === undefined || p < keyArr.length) ? defaultValue : obj;
});

});

unwrapExports$$1(get);

var set = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;



/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param path
 * @param value
 */
exports["default"] = (function (obj, path, value) {
    var o = obj;
    var keyArr = isString["default"](path) ? path.split('.') : path;
    keyArr.forEach(function (key, idx) {
        // 不是最后一个
        if (idx < keyArr.length - 1) {
            if (!isObject["default"](o[key])) {
                o[key] = isNumber_1["default"](keyArr[idx + 1]) ? [] : {};
            }
            o = o[key];
        }
        else {
            o[key] = value;
        }
    });
    return obj;
});

});

unwrapExports$$1(set);

var pick = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


var hasOwnProperty = Object.prototype.hasOwnProperty;
exports["default"] = (function (object, keys) {
    if (object === null || !isPlainObject_1["default"](object)) {
        return {};
    }
    var result = {};
    each_1["default"](keys, function (key) {
        if (hasOwnProperty.call(object, key)) {
            result[key] = object[key];
        }
    });
    return result;
});

});

unwrapExports$$1(pick);

var throttle = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
exports["default"] = (function (func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options)
        { options = {}; }
    var later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            { context = args = null; }
    };
    var throttled = function () {
        var now = Date.now();
        if (!previous && options.leading === false)
            { previous = now; }
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
                { context = args = null; }
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
    throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
});

});

unwrapExports$$1(throttle);

var toArray = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;

exports["default"] = (function (value) {
    return isArrayLike_1["default"](value) ? Array.prototype.slice.call(value) : [];
});

});

unwrapExports$$1(toArray);

var uniqueId = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
var map = {};
exports["default"] = (function (prefix) {
    prefix = prefix || 'g';
    if (!map[prefix]) {
        map[prefix] = 1;
    }
    else {
        map[prefix] += 1;
    }
    return prefix + map[prefix];
});

});

unwrapExports$$1(uniqueId);

var noop = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
exports["default"] = (function () { });

});

unwrapExports$$1(noop);

var identity = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
exports["default"] = (function (v) { return v; });

});

unwrapExports$$1(identity);

var size_1 = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;


function size(o) {
    if (isNil_1["default"](o)) {
        return 0;
    }
    if (isArrayLike_1["default"](o)) {
        return o.length;
    }
    return Object.keys(o).length;
}
exports["default"] = size;

});

unwrapExports$$1(size_1);

var lib = createCommonjsModule$$1(function (module, exports) {
exports.__esModule = true;
// array

exports.contains = contains_1["default"];
exports.includes = contains_1["default"];

exports.difference = difference_1["default"];

exports.find = find_1["default"];

exports.findIndex = findIndex_1["default"];

exports.firstValue = firstValue_1["default"];

exports.flatten = flatten_1["default"];

exports.flattenDeep = flattenDeep_1["default"];

exports.getRange = getRange_1["default"];

exports.pull = pull_1["default"];

exports.pullAt = pullAt_1["default"];

exports.reduce = reduce_1["default"];

exports.remove = remove_1["default"];

exports.sortBy = sortBy_1["default"];

exports.union = union_1["default"];

exports.uniq = uniq_1["default"];

exports.valuesOfKey = valuesOfKey["default"];

exports.head = head_1["default"];

exports.last = last_1["default"];

exports.startsWith = startsWith_1["default"];

exports.endsWith = endsWith_1["default"];

exports.filter = filter_1["default"];

exports.every = every_1["default"];

exports.some = some_1["default"];

exports.group = group["default"];

exports.groupBy = groupBy_1["default"];

exports.groupToMap = groupToMap_1["default"];
// event

exports.getWrapBehavior = getWrapBehavior_1["default"];

exports.wrapBehavior = wrapBehavior_1["default"];
// format

exports.number2color = number2color["default"];

exports.parseRadius = parseRadius_1["default"];
// math

exports.clamp = clamp_1["default"];

exports.fixedBase = fixedBase_1["default"];

exports.isDecimal = isDecimal_1["default"];

exports.isEven = isEven_1["default"];

exports.isInteger = isInteger_1["default"];

exports.isNegative = isNegative_1["default"];

exports.isNumberEqual = isNumberEqual_1["default"];

exports.isOdd = isOdd_1["default"];

exports.isPositive = isPositive_1["default"];

exports.maxBy = maxBy["default"];

exports.minBy = minBy["default"];

exports.mod = mod_1["default"];

exports.toDegree = toDegree_1["default"];

exports.toInteger = toInteger["default"];

exports.toRadian = toRadian_1["default"];
// object

exports.forIn = forIn["default"];

exports.has = has["default"];

exports.hasKey = hasKey["default"];

exports.hasValue = hasValue["default"];

exports.keys = keys_1["default"];

exports.isMatch = isMatch_1["default"];

exports.values = values_1["default"];
// string

exports.lowerCase = lowerCase_1["default"];

exports.lowerFirst = lowerFirst_1["default"];

exports.substitute = substitute_1["default"];

exports.upperCase = upperCase_1["default"];

exports.upperFirst = upperFirst_1["default"];
// type

exports.getType = getType_1["default"];

exports.isArguments = isArguments_1["default"];

exports.isArray = isArray["default"];

exports.isArrayLike = isArrayLike_1["default"];

exports.isBoolean = isBoolean_1["default"];

exports.isDate = isDate_1["default"];

exports.isError = isError_1["default"];

exports.isFunction = isFunction["default"];

exports.isFinite = _isFinite["default"];

exports.isNil = isNil_1["default"];

exports.isNull = isNull_1["default"];

exports.isNumber = isNumber_1["default"];

exports.isObject = isObject["default"];

exports.isObjectLike = isObjectLike_1["default"];

exports.isPlainObject = isPlainObject_1["default"];

exports.isPrototype = isPrototype_1["default"];

exports.isRegExp = isRegExp_1["default"];

exports.isString = isString["default"];

exports.isType = isType_1["default"];

exports.isUndefined = isUndefined_1["default"];

exports.isElement = isElement_1["default"];

exports.requestAnimationFrame = requestAnimationFrame_1["default"];

exports.clearAnimationFrame = clearAnimationFrame["default"];
// other

exports.augment = augment_1["default"];

exports.clone = clone_1["default"];

exports.debounce = debounce_1["default"];

exports.memoize = memoize["default"];

exports.deepMix = deepMix_1["default"];

exports.each = each_1["default"];

exports.extend = extend_1["default"];

exports.indexOf = indexOf_1["default"];

exports.isEmpty = isEmpty_1["default"];

exports.isEqual = isEqual_1["default"];

exports.isEqualWith = isEqualWith["default"];

exports.map = map_1["default"];

exports.mapValues = mapValues["default"];

exports.mix = mix_1["default"];
exports.assign = mix_1["default"];

exports.get = get["default"];

exports.set = set["default"];

exports.pick = pick["default"];

exports.throttle = throttle["default"];

exports.toArray = toArray["default"];

exports.toString = toString_1["default"];

exports.uniqueId = uniqueId["default"];

exports.noop = noop["default"];

exports.identity = identity["default"];

exports.size = size_1["default"];
// 不知道为什么，需要把这个 export，不然 ts 会报类型错误

exports.Cache = cache["default"];

});

var index = unwrapExports$$1(lib);
var lib_1 = lib.contains;
var lib_2 = lib.includes;
var lib_3 = lib.difference;
var lib_4 = lib.find;
var lib_5 = lib.findIndex;
var lib_6 = lib.firstValue;
var lib_7 = lib.flatten;
var lib_8 = lib.flattenDeep;
var lib_9 = lib.getRange;
var lib_10 = lib.pull;
var lib_11 = lib.pullAt;
var lib_12 = lib.reduce;
var lib_13 = lib.remove;
var lib_14 = lib.sortBy;
var lib_15 = lib.union;
var lib_16 = lib.uniq;
var lib_17 = lib.valuesOfKey;
var lib_18 = lib.head;
var lib_19 = lib.last;
var lib_20 = lib.startsWith;
var lib_21 = lib.endsWith;
var lib_22 = lib.filter;
var lib_23 = lib.every;
var lib_24 = lib.some;
var lib_25 = lib.group;
var lib_26 = lib.groupBy;
var lib_27 = lib.groupToMap;
var lib_28 = lib.getWrapBehavior;
var lib_29 = lib.wrapBehavior;
var lib_30 = lib.number2color;
var lib_31 = lib.parseRadius;
var lib_32 = lib.clamp;
var lib_33 = lib.fixedBase;
var lib_34 = lib.isDecimal;
var lib_35 = lib.isEven;
var lib_36 = lib.isInteger;
var lib_37 = lib.isNegative;
var lib_38 = lib.isNumberEqual;
var lib_39 = lib.isOdd;
var lib_40 = lib.isPositive;
var lib_41 = lib.maxBy;
var lib_42 = lib.minBy;
var lib_43 = lib.mod;
var lib_44 = lib.toDegree;
var lib_45 = lib.toInteger;
var lib_46 = lib.toRadian;
var lib_47 = lib.forIn;
var lib_48 = lib.has;
var lib_49 = lib.hasKey;
var lib_50 = lib.hasValue;
var lib_51 = lib.keys;
var lib_52 = lib.isMatch;
var lib_53 = lib.values;
var lib_54 = lib.lowerCase;
var lib_55 = lib.lowerFirst;
var lib_56 = lib.substitute;
var lib_57 = lib.upperCase;
var lib_58 = lib.upperFirst;
var lib_59 = lib.getType;
var lib_60 = lib.isArguments;
var lib_61 = lib.isArray;
var lib_62 = lib.isArrayLike;
var lib_63 = lib.isBoolean;
var lib_64 = lib.isDate;
var lib_65 = lib.isError;
var lib_66 = lib.isFunction;
var lib_67 = lib.isFinite;
var lib_68 = lib.isNil;
var lib_69 = lib.isNull;
var lib_70 = lib.isNumber;
var lib_71 = lib.isObject;
var lib_72 = lib.isObjectLike;
var lib_73 = lib.isPlainObject;
var lib_74 = lib.isPrototype;
var lib_75 = lib.isRegExp;
var lib_76 = lib.isString;
var lib_77 = lib.isType;
var lib_78 = lib.isUndefined;
var lib_79 = lib.isElement;
var lib_80 = lib.requestAnimationFrame;
var lib_81 = lib.clearAnimationFrame;
var lib_82 = lib.augment;
var lib_83 = lib.clone;
var lib_84 = lib.debounce;
var lib_85 = lib.memoize;
var lib_86 = lib.deepMix;
var lib_87 = lib.each;
var lib_88 = lib.extend;
var lib_89 = lib.indexOf;
var lib_90 = lib.isEmpty;
var lib_91 = lib.isEqual;
var lib_92 = lib.isEqualWith;
var lib_93 = lib.map;
var lib_94 = lib.mapValues;
var lib_95 = lib.mix;
var lib_96 = lib.assign;
var lib_97 = lib.get;
var lib_98 = lib.set;
var lib_99 = lib.pick;
var lib_100 = lib.throttle;
var lib_101 = lib.toArray;
var lib_102 = lib.uniqueId;
var lib_103 = lib.noop;
var lib_104 = lib.identity;
var lib_105 = lib.size;
var lib_106 = lib.Cache;

var Utils = /*#__PURE__*/Object.freeze({
'default': index,
__moduleExports: lib,
contains: lib_1,
includes: lib_2,
difference: lib_3,
find: lib_4,
findIndex: lib_5,
firstValue: lib_6,
flatten: lib_7,
flattenDeep: lib_8,
getRange: lib_9,
pull: lib_10,
pullAt: lib_11,
reduce: lib_12,
remove: lib_13,
sortBy: lib_14,
union: lib_15,
uniq: lib_16,
valuesOfKey: lib_17,
head: lib_18,
last: lib_19,
startsWith: lib_20,
endsWith: lib_21,
filter: lib_22,
every: lib_23,
some: lib_24,
group: lib_25,
groupBy: lib_26,
groupToMap: lib_27,
getWrapBehavior: lib_28,
wrapBehavior: lib_29,
number2color: lib_30,
parseRadius: lib_31,
clamp: lib_32,
fixedBase: lib_33,
isDecimal: lib_34,
isEven: lib_35,
isInteger: lib_36,
isNegative: lib_37,
isNumberEqual: lib_38,
isOdd: lib_39,
isPositive: lib_40,
maxBy: lib_41,
minBy: lib_42,
mod: lib_43,
toDegree: lib_44,
toInteger: lib_45,
toRadian: lib_46,
forIn: lib_47,
has: lib_48,
hasKey: lib_49,
hasValue: lib_50,
keys: lib_51,
isMatch: lib_52,
values: lib_53,
lowerCase: lib_54,
lowerFirst: lib_55,
substitute: lib_56,
upperCase: lib_57,
upperFirst: lib_58,
getType: lib_59,
isArguments: lib_60,
isArray: lib_61,
isArrayLike: lib_62,
isBoolean: lib_63,
isDate: lib_64,
isError: lib_65,
isFunction: lib_66,
isFinite: lib_67,
isNil: lib_68,
isNull: lib_69,
isNumber: lib_70,
isObject: lib_71,
isObjectLike: lib_72,
isPlainObject: lib_73,
isPrototype: lib_74,
isRegExp: lib_75,
isString: lib_76,
isType: lib_77,
isUndefined: lib_78,
isElement: lib_79,
requestAnimationFrame: lib_80,
clearAnimationFrame: lib_81,
augment: lib_82,
clone: lib_83,
debounce: lib_84,
memoize: lib_85,
deepMix: lib_86,
each: lib_87,
extend: lib_88,
indexOf: lib_89,
isEmpty: lib_90,
isEqual: lib_91,
isEqualWith: lib_92,
map: lib_93,
mapValues: lib_94,
mix: lib_95,
assign: lib_96,
get: lib_97,
set: lib_98,
pick: lib_99,
throttle: lib_100,
toArray: lib_101,
uniqueId: lib_102,
noop: lib_103,
identity: lib_104,
size: lib_105,
Cache: lib_106
});

var Util = lib_95({}, Utils, {
  assign: lib_95, // simple mix
  merge: lib_86, // deep mix
  cloneDeep: lib_83,
  isFinite: isFinite,
  isNaN: isNaN,
  snapEqual: lib_38,
  remove: lib_10,
  inArray: lib_1
});

Util.Array = {
  groupToMap: lib_27,
  group: lib_25,
  merge: Util.merge,
  values: lib_17,
  getRange: lib_9,
  firstValue: lib_6,
  remove: lib_10
};

/**
 * @fileOverview Chart、View、Geometry 的基类
 * @author dxq613@gmail.com
 */

var Base = /*@__PURE__*/(function (EventEmitter) {
  function Base(cfg) {
    EventEmitter.call(this);
    var attrs = {
      visible: true
    };
    var defaultCfg = this.getDefaultCfg();
    this._attrs = attrs;
    Util.assign(attrs, defaultCfg, cfg);
  }

  if ( EventEmitter ) Base.__proto__ = EventEmitter;
  Base.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Base.prototype.constructor = Base;

  Base.prototype.getDefaultCfg = function getDefaultCfg () {
    return {};
  };

  Base.prototype.get = function get (name) {
    return this._attrs[name];
  };

  Base.prototype.set = function set (name, value) {
    this._attrs[name] = value;
  };
  Base.prototype.destroy = function destroy () {
    this._attrs = {};
    this.removeAllListeners();
    this.destroyed = true;
  };

  return Base;
}(EventEmitter));

var name = "@antv/l7";
var version = "1.3.8";
var description = "Large-scale WebGL-powered Geospatial Data Visualization";
var main = "build/L7.js";
var homepage = "https://github.com/antvis/l7";
var repository = {
	type: "git",
	url: "git@github.com:antvis/l7.git"
};
var bugs = {
	url: "https://github.com/antvis/l7/issues"
};
var keywords = [
	"l7",
	"gis",
	"geometry"
];
var author = "https://github.com/orgs/antvis/people";
var license = "MIT";
var devDependencies = {
	"@babel/cli": "^7.4.3",
	"@babel/core": "~7.4.3",
	"@babel/preset-env": "~7.4.3",
	"babel-eslint": "~8.0.3",
	"babel-loader": "~8.0.0",
	"babel-plugin-transform-remove-strict-mode": "~0.0.2",
	"babel-preset-env": "~1.6.1",
	"body-parser": "^1.18.2",
	chai: "~4.1.2",
	commander: "~2.12.2",
	connect: "^3.6.6",
	"d3-queue": "~3.0.7",
	debug: "~3.1.0",
	electron: "~2.0.2",
	eslint: "~6.1.0",
	"eslint-config-egg": "~7.4.1",
	"eslint-plugin-html": "~6.0.0",
	"event-simulate": "~1.0.0",
	"get-port": "~3.2.0",
	"glsl-shaders-loader": "^1.0.0",
	jszip: "^3.1.5",
	nightmare: "~2.10.0",
	nunjucks: "~3.0.1",
	open: "~6.4.0",
	parseurl: "~1.3.2",
	"postcss-url": "^8.0.0",
	"pre-commit": "^1.2.2",
	rollup: "^1.16.2",
	"rollup-plugin-buble": "^0.19.6",
	"rollup-plugin-commonjs": "^9.2.1",
	"rollup-plugin-css-porter": "^1.0.2",
	"rollup-plugin-image": "^1.0.2",
	"rollup-plugin-json": "^4.0.0",
	"rollup-plugin-node-builtins": "^2.1.2",
	"rollup-plugin-node-resolve": "^4.0.1",
	"rollup-plugin-postcss": "^2.0.3",
	"rollup-plugin-sourcemaps": "^0.4.2",
	"rollup-plugin-terser": "^4.0.4",
	"serve-static": "^1.13.2",
	shelljs: "~0.7.8",
	"string-replace-loader": "~1.3.0",
	torchjs: "~2.1.0",
	"uglify-js": "~3.1.10"
};
var scripts = {
	"build-dev": "rollup -c --environment BUILD:dev",
	"watch-dev": "rollup -c --environment BUILD:dev --watch & npm run demos-web ",
	"build-prod": "rollup -c --environment BUILD:production,MINIFY:false",
	"build-prod-min": "rollup -c --environment BUILD:production,MINIFY:true",
	build: "rollup -c --environment BUILD:production",
	"build-lib": "babel src --out-dir lib",
	bundler: "electron ./bundler/app.js",
	ci: "npm run lint && npm run test",
	"compress-l7": "uglifyjs -c -m -o dist/l7.min.js -- build/l7.js",
	"compress-core": "uglifyjs -c -m -o dist/l7-core.min.js -- build/l7-core.js",
	"compress-simple": "uglifyjs -c -m -o dist/l7-simple.min.js -- build/l7-simple.js",
	compress: "npm run compress-l7",
	coverage: "npm run coverage-generator && npm run coverage-viewer",
	"coverage-generator": "torch --compile --coverage --renderer --recursive test/unit",
	"coverage-viewer": "torch-coverage",
	demos: "electron ./demos/app.js",
	"demos-web": "node ./demos/app.js --web --port 2046",
	dev: "npm run watch & npm run demos-web",
	dist: "npm run build-prod-min && npm run build-prod",
	lint: "eslint --ext .html,.js ./",
	"lint-fix": "eslint --ext .html,.js --fix ./",
	"mkdir-dist": "node ./bin/mkdir-dist.js",
	prepublishOnly: "npm run dist",
	screenshot: "node ./bin/screenshot.js",
	start: "npm run watch-dev",
	test: "torch  --compile-opts ./.torch.compile.opts.js --compile --renderer --recursive test/unit",
	"test-all": "npm run test && npm run test-bugs",
	"test-bugs": "torch --compile --renderer --recursive test/bugs",
	"test-bugs-live": "torch --compile --interactive --watch --recursive test/bugs",
	"test-live": "torch  --compile --interactive --watch --recursive test/unit",
	watch: "webpack --config webpack-dev.config.js",
	"win-dev": "node ./bin/win-dev.js"
};
var dependencies = {
	"@antv/geo-coord": "^1.0.8",
	"@antv/util": "~2.0.1",
	"@mapbox/geojson-rewind": "^0.4.0",
	"@mapbox/tiny-sdf": "^1.1.0",
	"@mapbox/vector-tile": "^1.3.1",
	"@turf/bbox": "^6.0.1",
	"@turf/clean-coords": "^6.0.1",
	"@turf/invariant": "^6.1.2",
	"@turf/meta": "^6.0.2",
	"d3-dsv": "^1.0.10",
	"d3-hexbin": "^0.2.2",
	earcut: "^2.1.3",
	fecha: "^2.3.3",
	"geojson-rewind": "^0.3.1",
	"gl-matrix": "^2.4.1",
	"gl-vec2": "^1.3.0",
	lodash: "^4.17.5",
	pbf: "^3.2.0",
	"polyline-miter-util": "^1.0.1",
	rbush: "^2.0.2",
	"simple-statistics": "^7.0.1",
	supercluster: "^6.0.1",
	three: "^0.101.1",
	"viewport-mercator-project": "^5.2.0",
	"webworkify-webpack": "^2.1.3",
	"wolfy87-eventemitter": "~5.2.4"
};
var pkg = {
	name: name,
	version: version,
	description: description,
	main: main,
	homepage: homepage,
	repository: repository,
	bugs: bugs,
	keywords: keywords,
	author: author,
	license: license,
	devDependencies: devDependencies,
	scripts: scripts,
	"pre-commit": {
	run: [
		"lint",
		"test"
	],
	silent: false
},
	dependencies: dependencies
};

var version$1 = 'v' + pkg.version;

/**
 * @fileOverview 全局变量
 * @author dxq613
 */
var FONT_FAMILY = '"-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",SimSun, "sans-serif"';
var Global = {
  version: version$1,
  scene: {
    mapType: 'AMAP',
    zoom: 5,
    center: [ 107.622, 39.266 ],
    minZoom: 3,
    maxZoom: 18,
    pitch: 0,
    hash: false,
    zoomControl: true,
    scaleControl: true,
    attributionControl: true
  },
  animate: true,
  height: 0,
  activeColor: '#2f54eb',
  colors: [ 'rgb(103,0,31)', 'rgb(178,24,43)', 'rgb(214,96,77)', 'rgb(244,165,130)', 'rgb(253,219,199)', 'rgb(247,247,247)', 'rgb(209,229,240)', 'rgb(146,197,222)', 'rgb(67,147,195)', 'rgb(33,102,172)', 'rgb(5,48,97)' ],
  size: 10000,
  shape: 'circle',
  pattern: '',
  snapArray: [ 0, 1, 2, 4, 5, 10 ],
  pointShape: {
    '2d': [ 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica' ],
    '3d': [ 'cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn' ]
  },
  sdfHomeUrl: 'https://sdf.amap.com',
  scales: { },
  textStyle: {
    fontSize: 12,
    fill: '#ccc',
    textBaseline: 'middle',
    fontFamily: FONT_FAMILY,
    textAlign: 'center'
  }
};

/**
 * @fileOverview the base class of scale
 * @author dxq613@gmail.com
 */

/**
 * 度量的构造函数
 * @class Scale
 */
var Base$1 = function Base(cfg) {
  var defaultCfg = this.getDefaultCfg();
  Util.mix(this, defaultCfg, cfg);
  this.init();
};

/**
 * 度量初始化
 * @protected
 */
Base$1.prototype.getDefaultCfg = function getDefaultCfg () {
  return {
    /**
     * type of the scale
     * @type {String}
     */
    type: 'base',

    /**
     * 格式化函数,输出文本或者tick时的格式化函数
     * @type {Function}
     */
    formatter: null,

    /**
     * 输出的值域
     * @type {Array}
     */
    range: [ 0, 1 ],

    /**
     * 度量的标记
     * @type {Array}
     */
    ticks: null,

    /**
     * 参与度量计算的值，可选项
     * @type {Array}
     */
    values: []
  };
};

Base$1.prototype.init = function init () {

};

Base$1.prototype.getTicks = function getTicks () {
  var self = this;
  var ticks = self.ticks;
  var rst = [];
  Util.each(ticks, function(tick) {
    var obj;
    if (Util.isObject(tick)) {
      obj = tick;
    } else {
      obj = {
        text: self.getText(tick),
        tickValue: tick,
        value: self.scale(tick)
      };
    }
    rst.push(obj);
  });
  return rst;
};

/**
 * 获取格式化后的文本
 * @param{*} value 输入的数据
 * @return {String} 格式化的文本
 */
Base$1.prototype.getText = function getText (value) {
  var formatter = this.formatter;
  value = formatter ? formatter(value) : value;
  if (Util.isNil(value) || !value.toString) {
    value = '';
  }
  return value.toString();
};
/**
 * 输出的值域最小值
 * @protected
 * @return {Number} 返回最小的值
 */
Base$1.prototype.rangeMin = function rangeMin () {
  return this.range[0];
};
/**
 * 输出的值域最大值
 * @protected
 * @return {Number} 返回最大的值
 */
Base$1.prototype.rangeMax = function rangeMax () {
  var range = this.range;
  return range[range.length - 1];
};

/**
 * 度量转换后的结果，翻转回输入域
 * @param{Number} value 需要翻转的数值
 * @return {*} 度量的输入值
 */
Base$1.prototype.invert = function invert (value) {
  return value;
};
/**
 * 将传入的值从非数值转换成数值格式，如分类字符串、时间字符串等
 * @param{*} value 传入的值
 * @return {Number} 转换的值
 */
Base$1.prototype.translate = function translate (value) {
  return value;
};
/**
 * 进行度量转换
 * @param{*} value 输入值
 * @return {Number} 输出值，在设定的输出值域之间，默认[0,1]
 */
Base$1.prototype.scale = function scale (value) {
  return value;
};
/**
 * 克隆一个新的scale,拥有跟当前scale相同的输入域、输出域等
 * @return {Scale} 克隆的度量
 */
Base$1.prototype.clone = function clone () {
  var self = this;
  var constr = self.constructor;
  var cfg = {};
  Util.each(self, function(v, k) {
    cfg[k] = self[k];
  });
  return new constr(cfg);
};
/**
 * 更改度量的属性信息
 * @param{Object} info 属性信息
 * @return {Scale} 返回自身的引用
 */
Base$1.prototype.change = function change (info) {
  this.ticks = null;
  Util.mix(this, info);
  this.init();
  return this;
};

/**
 * @fileOverview 计算方法
 * @author dxq613@gmail.com
 */

// 如果小数点后面超过 10 位浮点数时进行一下处理
var DECIMAL_LENGTH = 12;
// 获取系数
function getFactor(v) {
  var factor = 1;
  if (v === Infinity || v === -Infinity) {
    throw new Error('Not support Infinity!');
  }
  if (v < 1) {
    var count = 0;
    while (v < 1) {
      factor = factor / 10;
      v = v * 10;
      count++;
    }
    // 浮点数计算出现问题
    if (factor.toString().length > DECIMAL_LENGTH) {
      factor = parseFloat(factor.toFixed(count));
    }
  } else {
    while (v > 10) {
      factor = factor * 10;
      v = v / 10;
    }
  }

  return factor;
}

// 取小于当前值的
function arrayFloor(values, value) {
  var length = values.length;
  if (length === 0) {
    return NaN;
  }

  var pre = values[0];

  if (value < values[0]) {
    return NaN;
  }

  if (value >= values[length - 1]) {
    return values[length - 1];
  }
  for (var i = 1; i < values.length; i++) {
    if (value < values[i]) {
      break;
    }
    pre = values[i];
  }

  return pre;
}

// 大于当前值的第一个
function arrayCeiling(values, value) {
  var length = values.length;
  if (length === 0) {
    return NaN;
  }
  // var pre = values[0];
  var rst;
  if (value > values[length - 1]) {
    return NaN;
  }
  if (value < values[0]) {
    return values[0];
  }

  for (var i = 1; i < values.length; i++) {
    if (value <= values[i]) {
      rst = values[i];
      break;
    }
  }

  return rst;
}

var Util$1 = {
  // 获取逼近的数值
  snapFactorTo: function snapFactorTo(v, arr, snapType) {
    // 假设 v = -512,isFloor = true
    if (isNaN(v)) {
      return NaN;
    }
    var factor = 1; // 计算系数
    if (v !== 0) {
      if (v < 0) {
        factor = -1;
      }
      v = v * factor; // v = 512
      var tmpFactor = getFactor(v);
      factor = factor * tmpFactor; // factor = -100

      v = v / tmpFactor; // v = 5.12
    }
    if (snapType === 'floor') {
      v = Util$1.snapFloor(arr, v); // v = 5
    } else if (snapType === 'ceil') {
      v = Util$1.snapCeiling(arr, v); // v = 6
    } else {
      v = Util$1.snapTo(arr, v); // 四舍五入 5
    }
    var rst = v * factor;
    // 如果出现浮点数计算问题，需要处理一下
    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {
      var decimalVal = parseInt(1 / factor);
      var symbol = factor > 0 ? 1 : -1;
      rst = (v / decimalVal) * symbol;
    }
    return rst;
  },
  // 获取逼近的倍数
  snapMultiple: function snapMultiple(v, base, snapType) {
    var div;
    if (snapType === 'ceil') {
      div = Math.ceil(v / base);
    } else if (snapType === 'floor') {
      div = Math.floor(v / base);
    } else {
      div = Math.round(v / base);
    }
    return div * base;
  },
  /**
   * 获取逼近的值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的值
   */
  snapTo: function snapTo(values, value) {
    // 这里假定values是升序排列
    var floorVal = arrayFloor(values, value);
    var ceilingVal = arrayCeiling(values, value);
    if (isNaN(floorVal) || isNaN(ceilingVal)) {
      if (values[0] >= value) {
        return values[0];
      }
      var last = values[values.length - 1];
      if (last <= value) {
        return last;
      }
    }
    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {
      return floorVal;
    }
    return ceilingVal;
  },
  /**
   * 获取逼近的最小值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的最小值
   */
  snapFloor: function snapFloor(values, value) {
    // 这里假定values是升序排列
    return arrayFloor(values, value);
  },
  /**
   * 获取逼近的最大值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的最大值
   */
  snapCeiling: function snapCeiling(values, value) {
    // 这里假定values是升序排列
    return arrayCeiling(values, value);
  }
};

/**
 * @fileOverview 自动计算数字坐标轴
 * @author dxq613@gmail.com
 */
var MIN_COUNT = 5;
var MAX_COUNT = 7;

function numberAuto(info) {
  var min = info.min;
  var max = info.max;
  var interval = info.interval;
  var ticks = [];
  var minCount = info.minCount || MIN_COUNT;
  var maxCount = info.maxCount || MAX_COUNT;
  var isFixedCount = minCount === maxCount; // 是否限定死了个数
  var minLimit = Util.isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值
  var maxLimit = Util.isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值
  var avgCount = (minCount + maxCount) / 2;
  var count = avgCount;
  // 用户传入的逼近数组
  var snapArray = info.snapArray ? info.snapArray : (isFixedCount ? Global.snapCountArray : Global.snapArray);

  // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分
  if (min === minLimit && max === maxLimit && isFixedCount) {
    interval = (max - min) / (count - 1);
  }

  if (Util.isNil(min)) {
    min = 0;
  }
  if (Util.isNil(max)) {
    max = 0;
  }
  if (max === min) {
    if (min === 0) {
      max = 1;
    } else {
      if (min > 0) {
        min = 0;
      } else {
        max = 0;
      }
    }
    if (max - min < 5 && !interval && max - min >= 1) {
      interval = 1;
    }
  }

  if (Util.isNil(interval)) {
    // 计算间距
    var temp = (max - min) / (avgCount - 1);
    interval = Util$1.snapFactorTo(temp, snapArray, 'ceil');
    if (maxCount !== minCount) {
      count = parseInt((max - min) / interval, 10);
      if (count > maxCount) {
        count = maxCount;
      }
      if (count < minCount) {
        count = minCount;
      }
      // 不确定tick的个数时，使得tick偏小
      interval = Util$1.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');
    }
  }
  if (info.interval || maxCount !== minCount) {
    // 校正 max 和 min
    max = Math.min(Util$1.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近
    min = Math.max(Util$1.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近

    count = Math.round((max - min) / interval);
    min = Util.fixedBase(min, interval);
    max = Util.fixedBase(max, interval);
  } else {
    avgCount = parseInt(avgCount, 10); // 取整
    var avg = (max + min) / 2;
    var avgTick = Util$1.snapMultiple(avg, interval, 'ceil');
    var sideCount = Math.floor((avgCount - 2) / 2);
    var maxTick = avgTick + sideCount * interval;
    var minTick;
    if (avgCount % 2 === 0) {
      minTick = avgTick - sideCount * interval;
    } else {
      minTick = avgTick - (sideCount + 1) * interval;
    }
    if (maxTick < max) {
      maxTick = maxTick + interval;
    }
    if (minTick > min) {
      minTick = minTick - interval;
    }
    max = Util.fixedBase(maxTick, interval);
    min = Util.fixedBase(minTick, interval);
  }

  max = Math.min(max, maxLimit);
  min = Math.max(min, minLimit);

  ticks.push(min);
  for (var i = 1; i < count; i++) {
    var tickValue = Util.fixedBase(interval * i + min, interval);
    if (tickValue < max) {
      ticks.push(tickValue);
    }
  }
  if (ticks[ticks.length - 1] < max) {
    ticks.push(max);
  }
  return {
    min: min,
    max: max,
    interval: interval,
    count: count,
    ticks: ticks
  };
}

/**
 * @fileOverview The measurement of linear data scale function
 * @author dxq613@gmail.com
 */

/**
 * 线性度量
 * @class Scale.Linear
 */
var Linear = /*@__PURE__*/(function (Base) {
  function Linear () {
    Base.apply(this, arguments);
  }

  if ( Base ) Linear.__proto__ = Base;
  Linear.prototype = Object.create( Base && Base.prototype );
  Linear.prototype.constructor = Linear;

  Linear.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Base.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      /**
       * type of the scale
       * @type {String}
       */
      type: 'linear',

      /**
       * 是否线性
       * @type {Boolean}
       * @readOnly
       * @default true
       */
      isLinear: true,

      /**
       * min value of the scale
       * @type {Number}
       * @default null
       */
      min: null,

      /**
       * min value limitted of the scale
       * @type {Number}
       * @default null
       */
      minLimit: null,

      /**
       * max value of the scale
       * @type {Number}
       * @default null
       */
      max: null,

      /**
       * max value limitted of the scale
       * @type {Number}
       * @default null
       */
      maxLimit: null,

      /**
       * 是否为了用户习惯，优化min,max和ticks，如果进行优化，则会根据生成的ticks调整min,max，否则舍弃(min,max)范围之外的ticks
       * @type {Boolean}
       * @default false
       */
      nice: false,

      /**
       * 自动生成标记时的个数
       * @type {Number}
       * @default null
       */
      tickCount: null,

      /**
       * 坐标轴点之间的间距，指的是真实数据的差值
       * @type {Number}
       * @default null
       */
      tickInterval: null,

      /**
       * 用于计算坐标点时逼近的数组
       * @type {Array}
       */
      snapArray: null
    });
  };
  /**
   * @protected
   * @override
   */
  Linear.prototype.init = function init () {
    var self = this;
    if (!self.ticks) {
      self.min = self.translate(self.min);
      self.max = self.translate(self.max);
      self.initTicks();
    } else {
      var ticks = self.ticks;
      var firstValue = self.translate(ticks[0]);
      var lastValue = self.translate(ticks[ticks.length - 1]);
      if (Util.isNil(self.min) || self.min > firstValue) {
        self.min = firstValue;
      }
      if (Util.isNil(self.max) || self.max < lastValue) {
        self.max = lastValue;
      }
    }
  };

  /**
   * 计算坐标点
   * @protected
   * @return {Array} 计算完成的坐标点
   */
  Linear.prototype.calculateTicks = function calculateTicks () {
    var self = this;
    var min = self.min;
    var max = self.max;
    var count = self.tickCount;
    var interval = self.tickInterval;
    if (max < min) {
      throw new Error(("max: " + max + " should not be less than min: " + min));
    }
    var tmp = numberAuto({
      min: min,
      max: max,
      minLimit: self.minLimit,
      maxLimit: self.maxLimit,
      minCount: count,
      maxCount: count,
      interval: interval,
      snapArray: this.snapArray
    });
    return tmp.ticks;
  };

  // 初始化ticks
  Linear.prototype.initTicks = function initTicks () {
    var self = this;
    var calTicks = self.calculateTicks();
    if (self.nice) { // 如果需要优化显示的tick
      self.ticks = calTicks;
      self.min = calTicks[0];
      self.max = calTicks[calTicks.length - 1];
    } else {
      var ticks = [];
      Util.each(calTicks, function(tick) {
        if (tick >= self.min && tick <= self.max) {
          ticks.push(tick);
        }
      });
      // 如果 ticks 为空，直接输入最小值、最大值
      if (!ticks.length) {
        ticks.push(self.min);
        ticks.push(self.max);
      }
      self.ticks = ticks;
    }
  };

  /**
   * @override
   */
  Linear.prototype.scale = function scale (value) {
    if (value === null || value === undefined) {
      return NaN;
    }
    var max = this.max;
    var min = this.min;
    if (max === min) {
      return 0;
    }

    var percent = Math.min(1, Math.max(0, (value - min) / (max - min))); // 数据控制到 0-1 范围
    // const percent = (value - min) / (max - min);
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    return rangeMin + percent * (rangeMax - rangeMin);
  };

  /**
   * @override
   */
  Linear.prototype.invert = function invert (value) {
    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    return this.min + percent * (this.max - this.min);
  };

  return Linear;
}(Base$1));

/**
 * @fileOverview The data is replaced with constant
 * @author dxq613@gmail.com
 */

var Identity = /*@__PURE__*/(function (Base) {
  function Identity () {
    Base.apply(this, arguments);
  }

  if ( Base ) Identity.__proto__ = Base;
  Identity.prototype = Object.create( Base && Base.prototype );
  Identity.prototype.constructor = Identity;

  Identity.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Base.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      isIdentity: true,
      /**
       * @override
       * @type {String}
       */
      type: 'identity',

      /**
       * 常量值
       * @type {*}
       */
      value: null
    });
  };

  /**
   * @override
   */
  Identity.prototype.getText = function getText () {
    return this.value.toString();
  };

  /**
   * @override
   */
  Identity.prototype.scale = function scale (value) {
    if (this.value !== value && Util.isNumber(value)) {
      return value;
    }
    return this.range[0];
  };

  /**
   * @override
   */
  Identity.prototype.invert = function invert () {
    return this.value;
  };

  return Identity;
}(Base$1));

/**
 * @fileOverview 计算分类的的坐标点
 * @author dxq613@gmail.com
 */
var MAX_COUNT$1 = 8;
var SUB_COUNT = 4; // 控制个数不能过小

function getSimpleArray(data) {
  var arr = [];
  Util.each(data, function(sub) {
    if (Util.isArray(sub)) {
      arr = arr.concat(sub);
    } else {
      arr.push(sub);
    }
  });
  return arr;
}
function getGreatestFactor(count, number) {
  var i;
  for (i = number; i > 0; i--) {
    if (count % i === 0) { break; }
  }
  // 如果是素数，没有可以整除的数字
  if (i === 1) {
    for (i = number; i > 0; i--) {
      if ((count - 1) % i === 0) { break; }
    }
  }
  return i;
}

function catAuto(info) {
  var rst = {};
  var ticks = [];
  var maxCount = info.maxCount || MAX_COUNT$1;
  var categories = getSimpleArray(info.data);
  var length = categories.length;
  var tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1;

  // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount
  if (tickCount === 2) {
    tickCount = maxCount;
  } else if (tickCount < maxCount - SUB_COUNT) {
    tickCount = maxCount - SUB_COUNT;
  }
  var step = parseInt(length / (tickCount - 1), 10);

  var groups = categories.map(function(e, i) {
    return i % step === 0 ? categories.slice(i, i + step) : null;
  }).filter(function(e) {
    return e;
  });

  if (categories.length) {
    ticks.push(categories[0]);
  }
  for (var i = 1; (i < groups.length) && (i * step < length - step); i++) {
    ticks.push(groups[i][0]);
  }
  if (categories.length) {
    var last = categories[length - 1];
    if (ticks.indexOf(last) === -1) {
      ticks.push(last);
    }
  }

  rst.categories = categories;
  rst.ticks = ticks;
  return rst;
}

/**
 * @fileOverview the scale function to process the categories
 * @author dxq613@gmail.com
 */

/**
 * 度量的构造函数
 * @class Scale.Category
 */
var Category = /*@__PURE__*/(function (Base) {
  function Category () {
    Base.apply(this, arguments);
  }

  if ( Base ) Category.__proto__ = Base;
  Category.prototype = Object.create( Base && Base.prototype );
  Category.prototype.constructor = Category;

  Category.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Base.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      /**
       * type of the scale
       * @type {String}
       */
      type: 'cat',

      /**
       * 自动生成标记时的个数
       * @type {Number}
       * @default null
       */
      tickCount: null,

      /**
       * 是否分类度量
       * @type {Boolean}
       */
      isCategory: true
    });
  };

  /**
   * @override
   */
  Category.prototype.init = function init () {
    var self = this;
    var values = self.values;
    var tickCount = self.tickCount;

    Util.each(values, function(v, i) {
      values[i] = v.toString();
    });
    if (!self.ticks) {
      var ticks = values;
      if (tickCount) {
        var temp = catAuto({
          maxCount: tickCount,
          data: values
        });
        ticks = temp.ticks;
      }
      this.ticks = ticks;
    }
  };

  /**
   * @override
   */
  Category.prototype.getText = function getText (value) {

    if (this.values.indexOf(value) === -1 && Util.isNumber(value)) {
      value = this.values[Math.round(value)];
    }

    return Base.prototype.getText.call(this, value);
  };

  /**
   * @override
   */
  Category.prototype.translate = function translate (value) {
    var index = this.values.indexOf(value);
    if (index === -1 && Util.isNumber(value)) {
      index = value;
    } else if (index === -1) {
      index = NaN;
    }
    return index;
  };
  /**
   * @override
   */
  Category.prototype.scale = function scale (value) {
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var percent;

    if (Util.isString(value) || this.values.indexOf(value) !== -1) {
      value = this.translate(value);
    }
    if (this.values.length > 1) {
      percent = (value) / (this.values.length - 1);
    } else {
      percent = value;
    }
    return rangeMin + percent * (rangeMax - rangeMin);
  };

  /**
   * @override
   */
  Category.prototype.invert = function invert (value) {
    if (Util.isString(value)) { // 如果已经是字符串
      return value;
    }
    var min = this.rangeMin();
    var max = this.rangeMax();

    // 归一到 范围内
    if (value < min) {
      value = min;
    }
    if (value > max) {
      value = max;
    }
    var percent = (value - min) / (max - min);
    var index = Math.round(percent * (this.values.length - 1)) % this.values.length;
    index = index || 0;
    return this.values[index];
  };

  return Category;
}(Base$1));

/**
 * @fileOverview 计算时间坐标轴
 * @author dxq613@gmail.com
 */

var MAX_COUNT$2 = 6;
var SNAP_ARRAY = [ 1, 2, 4, 6, 8, 12 ];
var MINUTE_MS = 60 * 1000;
var HOUR_MS = 3600 * 1000;
var DAY_MS = 24 * 3600 * 1000;

function getYear(date) {
  return new Date(date).getFullYear();
}

function createYear(year) {
  return new Date(year, 0, 1).getTime();
}

function getMonth(date) {
  return new Date(date).getMonth();
}

function diffMonth(min, max) {
  var minYear = getYear(min);
  var maxYear = getYear(max);
  var minMonth = getMonth(min);
  var maxMonth = getMonth(max);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}

function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}

function diffDay(min, max) {
  return Math.ceil((max - min) / DAY_MS);
}

function diffHour(min, max) {
  return Math.ceil((max - min) / HOUR_MS);
}

function diffMinus(min, max) {
  return Math.ceil((max - min) / (60 * 1000));
}

function timeAuto(info) {
  var minInterval = info.minInterval;
  var ticks = [];
  var min = info.min;
  var max = info.max;
  var interval = info.interval;
  var count;

  // 如果最大值和最小值相等，则设置最大值大于最小值一天
  if (max === min) {
    max = min + DAY_MS;
  }

  // 计算间距
  if (Util.isNil(interval)) {
    var innerTime = max - min;
    var dms = DAY_MS; // 天代表的秒
    var yms = 365 * dms; // 年代表的秒
    interval = parseInt(innerTime / (info.maxCount || MAX_COUNT$2), 10);
    if (minInterval && minInterval > interval) {
      interval = minInterval;
    }
    var yfactor = interval / yms;
    var minYear = getYear(min);
    // 大于半年
    if (yfactor > 0.51) {
      var year = Math.ceil(yfactor);
      // interval = year * yms;
      var maxYear = getYear(max);

      for (var i = minYear; i <= maxYear + year; i = i + year) {
        ticks.push(createYear(i));
      }
      interval = null;
    } else if (yfactor > 0.0834) { // 大于一个月
      var month = Math.ceil(yfactor / 0.0834);
      var mmMoth = getMonth(min);
      var dMonths = diffMonth(min, max);

      for (var i$1 = 0; i$1 <= dMonths + month; i$1 = i$1 + month) {
        ticks.push(creatMonth(minYear, i$1 + mmMoth));
      }
      interval = null;

    } else if (interval > dms * 0.5) { // 大于一天
      var date = new Date(min);
      var year$1 = date.getFullYear();
      var month$1 = date.getMonth(min);
      var mday = date.getDate();
      var day = Math.ceil(interval / dms);
      var ddays = diffDay(min, max);
      interval = day * dms;
      for (var i$2 = 0; i$2 < ddays + day; i$2 = i$2 + day) {
        ticks.push(new Date(year$1, month$1, mday + i$2).getTime());
      }

    } else if (interval > HOUR_MS) { // 大于一个小时
      var date$1 = new Date(min);
      var year$2 = date$1.getFullYear();
      var month$2 = date$1.getMonth(min);
      var day$1 = date$1.getDate();
      var hour = date$1.getHours();
      var hours = Util$1.snapTo(SNAP_ARRAY, Math.ceil(interval / HOUR_MS));
      var dHours = diffHour(min, max);
      interval = hours * HOUR_MS;

      for (var i$3 = 0; i$3 <= dHours + hours; i$3 = i$3 + hours) {
        ticks.push(new Date(year$2, month$2, day$1, hour + i$3).getTime());
      }

    } else if (interval > MINUTE_MS) { // 最小单位是分钟
      var dMinus = diffMinus(min, max);
      var minutes = Math.ceil(interval / MINUTE_MS);
      interval = minutes * MINUTE_MS;

      for (var i$4 = 0; i$4 <= dMinus + minutes; i$4 = i$4 + minutes) {
        ticks.push(min + i$4 * MINUTE_MS);
      }
    } else {
      if (interval < 1000) {
        interval = 1000;
      }
      min = Math.floor(min / 1000) * 1000;
      var dSeconds = Math.ceil((max - min) / 1000);
      var seconds = Math.ceil(interval / 1000);
      interval = seconds * 1000;

      for (var i$5 = 0; i$5 < dSeconds + seconds; i$5 = i$5 + seconds) {
        ticks.push(min + i$5 * 1000);
      }
    }

  }

  if (!ticks.length) {
    min = Math.floor(min / 1000) * 1000;
    max = Math.ceil(max / 1000) * 1000;
    count = (max - min) / interval;
    for (var i$6 = 0; i$6 <= count; i$6++) {
      ticks.push(Util.fixedBase(interval * i$6 + min, interval));
    }
  }

  return {
    max: max,
    min: min,
    interval: interval,
    ticks: ticks,
    count: ticks.length
  };
}

var fecha = createCommonjsModule$$1(function (module) {
(function (main) {

  /**
   * Parse or format dates
   * @class fecha
   */
  var fecha = {};
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var literal = /\[([^]*?)\]/gm;
  var noop = function () {
  };

  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };

  var formatFlags = {
    D: function(dateObj) {
      return dateObj.getDate();
    },
    DD: function(dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return dateObj.getDay();
    },
    dd: function(dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    YYYY: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return dateObj.getHours();
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };

  var parseFlags = {
    D: [twoDigits, function (d, v) {
      d.day = v;
    }],
    Do: [new RegExp(twoDigits.source + word.source), function (d, v) {
      d.day = parseInt(v, 10);
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    YY: [twoDigits, function (d, v) {
      var da = new Date(), cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    YYYY: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    d: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/([\+\-]\d\d:?\d\d|Z)/, function (d, v) {
      if (v === 'Z') { v = '+00:00'; }
      var parts = (v + '').match(/([\+\-]|\d\d)/gi), minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.dd = parseFlags.d;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.DD = parseFlags.D;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;


  // Some common format strings
  fecha.masks = {
    default: 'ddd MMM DD YYYY HH:mm:ss',
    shortDate: 'M/D/YY',
    mediumDate: 'MMM D, YYYY',
    longDate: 'MMMM D, YYYY',
    fullDate: 'dddd, MMMM D, YYYY',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };

  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];

    var literals = [];

    // Make literals inactive by replacing them with ??
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return '??';
    });
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/\?\?/g, function() {
      return literals.shift();
    });
  };

  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format;

    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
      return false;
    }

    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }

      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });

    if (!isValid) {
      return false;
    }

    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,
        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,
        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  /* istanbul ignore next */
  if ( module.exports) {
    module.exports = fecha;
  } else {
    main.fecha = fecha;
  }
})(this);
});

/**
 * @fileOverview 提取公共代码到util方法
 * @author dxq613@gmail.com
 */

var TimeUtil = {
  toTimeStamp: function toTimeStamp(value) {
    if (Util.isString(value)) {
      if (value.indexOf('T') > 0) {
        value = new Date(value).getTime();
      } else {
        value = new Date(value.replace(/-/ig, '/')).getTime();
      }
    }
    if (Util.isDate(value)) {
      value = value.getTime();
    }
    return value;
  }
};

/**
 * @fileOverview The measurement of linear data scale function
 * @author dxq613@gmail.com
 */

/**
 * 时间度量的构造函数
 * @class Scale.Time
 */
var Time = /*@__PURE__*/(function (Linear) {
  function Time () {
    Linear.apply(this, arguments);
  }

  if ( Linear ) Time.__proto__ = Linear;
  Time.prototype = Object.create( Linear && Linear.prototype );
  Time.prototype.constructor = Time;

  Time.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Linear.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      /**
       * @override
       */
      type: 'time',

      /**
       * 格式化符
       * @type {String}
       */
      mask: 'YYYY-MM-DD'
    });
  };

  /**
   * @override
   */
  Time.prototype.init = function init () {
    var self = this;
    var values = self.values;
    if (values && values.length) { // 重新计算最大最小值
      var min = Infinity; // 最小值
      var secondMin = min; // 次小值
      var max = 0;
      // 使用一个循环，计算min,max,secondMin
      Util.each(values, function(v) {
        var timeStamp = self._toTimeStamp(v);
        if (isNaN(timeStamp)) {
          throw new TypeError(("Invalid Time: " + v));
        }
        if (min > timeStamp) {
          secondMin = min;
          min = timeStamp;
        } else if (secondMin > timeStamp) {
          secondMin = timeStamp;
        }
        if (max < timeStamp) {
          max = timeStamp;
        }
      });
      // 存在多个值时，设置最小间距
      if (values.length > 1) {
        self.minTickInterval = secondMin - min;
      }
      if (Util.isNil(self.min) || self._toTimeStamp(self.min) > min) {
        self.min = min;
      }
      if (Util.isNil(self.max) || self._toTimeStamp(self.max) < max) {
        self.max = max;
      }
    }
    Linear.prototype.init.call(this);
  };

  Time.prototype.calculateTicks = function calculateTicks () {
    var self = this;
    var min = self.min;
    var max = self.max;
    var count = self.tickCount;
    var interval = self.tickInterval;
    var tmp = timeAuto({
      min: min,
      max: max,
      minCount: count,
      maxCount: count,
      interval: interval,
      minInterval: self.minTickInterval
    });
    return tmp.ticks;
  };

  /**
   * @override
   */
  Time.prototype.getText = function getText (value) {
    var formatter = this.formatter;
    value = this.translate(value);
    value = formatter ? formatter(value) : fecha.format(value, this.mask);
    return value;
  };

  /**
   * @override
   */
  Time.prototype.scale = function scale (value) {
    if (Util.isString(value)) {
      value = this.translate(value);
    }
    return Linear.prototype.scale.call(this, value);
  };

  /**
   * @override
   */
  Time.prototype.translate = function translate (value) {
    return this._toTimeStamp(value);
  };

  // 将时间转换为时间戳
  Time.prototype._toTimeStamp = function _toTimeStamp (value) {
    return TimeUtil.toTimeStamp(value);
  };

  return Time;
}(Linear));

/**
 * @fileOverview 时间数据作为分类类型
 * @author dxq613@gmail.com
 */

/**
 * 度量的构造函数
 * @class Scale.TimeCategory
 */
var TimeCategory = /*@__PURE__*/(function (Category) {
  function TimeCategory () {
    Category.apply(this, arguments);
  }

  if ( Category ) TimeCategory.__proto__ = Category;
  TimeCategory.prototype = Object.create( Category && Category.prototype );
  TimeCategory.prototype.constructor = TimeCategory;

  TimeCategory.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Category.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      /**
       * @override
       */
      type: 'timeCat',

      /**
       * 格式化符
       * @type {String}
       */
      mask: 'YYYY-MM-DD',

      /**
       * @override
       */
      tickCount: 7
    });
  };

  TimeCategory.prototype.init = function init () {
    var self = this;
    var values = this.values;
    // 针对时间分类类型，会将时间统一转换为时间戳
    Util.each(values, function(v, i) {
      values[i] = self._toTimeStamp(v);
    });
    values.sort(function(v1, v2) {
      return v1 - v2;
    });

    if (!self.ticks) {
      self.ticks = this.calculateTicks(false);
    }
  };

  /**
   * 计算 ticks
   * @param  {boolean} formated 是否将 ticks 按照指定的 mask 格式化
   * @return {array} 返回 ticks 数组
   */
  TimeCategory.prototype.calculateTicks = function calculateTicks (formated) {
    var self = this;
    var count = self.tickCount;
    var ticks;
    if (count) {
      var temp = catAuto({
        maxCount: count,
        data: self.values
      });
      ticks = temp.ticks;
    } else {
      ticks = self.values;
    }

    if (formated) {
      Util.each(ticks, function(value, index) {
        ticks[index] = fecha.format(value, self.mask);
      });
    }
    return ticks;
  };

  /**
   * @override
   */
  TimeCategory.prototype.translate = function translate (value) {
    value = this._toTimeStamp(value);
    var index = this.values.indexOf(value);

    if (index === -1) {
      if (Util.isNumber(value) && value < this.values.length) {
        index = value;
      } else {
        index = NaN;
      }
    }
    return index;
  };

  /**
   * @override
   */
  TimeCategory.prototype.scale = function scale (value) {
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var index = this.translate(value);
    var percent;

    if (this.values.length === 1) {
      percent = index;
    } else if (index > -1) {
      percent = (index) / (this.values.length - 1);
    } else {
      percent = 0;
    }

    return rangeMin + percent * (rangeMax - rangeMin);
  };

  /**
   * @override
   */
  TimeCategory.prototype.getText = function getText (value) {
    var result = '';
    var index = this.translate(value);
    if (index > -1) {
      result = this.values[index];
    } else {
      result = value;
    }

    var formatter = this.formatter;
    result = parseInt(result, 10);
    result = formatter ? formatter(result) : fecha.format(result, this.mask);
    return result;
  };

  /**
   * @override
   */
  TimeCategory.prototype.getTicks = function getTicks () {
    var self = this;
    var ticks = this.ticks;
    var rst = [];
    Util.each(ticks, function(tick) {
      var obj;
      if (Util.isObject(tick)) {
        obj = tick;
      } else {
        obj = {
          text: Util.isString(tick) ? tick : self.getText(tick),
          tickValue: tick, // 用于坐标轴上文本动画时确定前后帧的对应关系
          value: self.scale(tick)
        };
      }
      rst.push(obj);
    });
    return rst;
  };

  // 将时间转换为时间戳
  TimeCategory.prototype._toTimeStamp = function _toTimeStamp (value) {
    return TimeUtil.toTimeStamp(value);
  };

  return TimeCategory;
}(Category));

/**
 * @fileOverview 使用度量，进行log转换
 * @author dxq613@gmail.com
 */

// 计算log
function log(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}

/**
 * 度量的log计算
 * @class Scale.Log
 */
var Log = /*@__PURE__*/(function (Linear) {
  function Log () {
    Linear.apply(this, arguments);
  }

  if ( Linear ) Log.__proto__ = Linear;
  Log.prototype = Object.create( Linear && Linear.prototype );
  Log.prototype.constructor = Log;

  Log.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Linear.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      /**
       * @override
       */
      type: 'log',

      /**
       * 进行log计算的基数
       * @type {Number}
       */
      base: 2,

      /**
       * @override
       * log 的坐标点的个数控制在10个以下
       * @type {Number}
       */
      tickCount: 10,

      // 最小的tick，仅内部使用
      _minTick: null
    });
  };
  /**
   * @override
   */
  Log.prototype.calculateTicks = function calculateTicks () {
    var self = this;
    var base = self.base;
    var minTick;
    if (self.min < 0) {
      throw new Error('The minimum value must be greater than zero!');
    }
    var maxTick = log(base, self.max);

    if (self.min > 0) {
      minTick = Math.floor(log(base, self.min));
    } else {
      var values = self.values;
      var positiveMin = self.max; // 查找大于0的第一个值, 如果都小于0，默认为1
      Util.each(values, function(value) {
        if (value > 0 && value < positiveMin) {
          positiveMin = value;
        }
      });
      if (positiveMin === self.max) {
        positiveMin = self.max / base;
      }
      if (positiveMin > 1) {
        positiveMin = 1;
      }
      minTick = Math.floor(log(base, positiveMin));
      self._minTick = minTick;
      self.positiveMin = positiveMin;
    }
    var count = maxTick - minTick;
    var tickCount = self.tickCount;
    var avg = Math.ceil(count / tickCount);
    var ticks = [];

    for (var i = minTick; i < maxTick + avg; i = i + avg) {
      ticks.push(Math.pow(base, i));
    } /**/
    if (self.min === 0) {
      ticks.unshift(0);
    }
    return ticks;
  };
  // 获取度量计算时，value占的定义域百分比
  Log.prototype._getScalePercent = function _getScalePercent (value) {
    var max = this.max;
    var min = this.min;
    if (max === min) {
      return 0;
    }
    // 如果值小于等于0，则按照0处理
    if (value <= 0) {
      return 0;
    }
    var base = this.base;
    var positiveMin = this.positiveMin;
    // 如果min == 0, 则根据比0大的最小值，计算比例关系。这个最小值作为坐标轴上的第二个tick，第一个是0但是不显示
    if (positiveMin) {
      min = positiveMin * 1 / base;
    }
    var percent;
    // 如果数值小于次小值，那么就计算 value / 次小值 占整体的比例
    if (value < positiveMin) {
      percent = (value / positiveMin) / (log(base, max) - log(base, min));
    } else {
      percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
    }
    return percent;
  };

  /**
   * @override
   */
  Log.prototype.scale = function scale (value) {
    var percent = this._getScalePercent(value);
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    return rangeMin + percent * (rangeMax - rangeMin);
  };
  /**
   * @override
   */
  Log.prototype.invert = function invert (value) {
    var base = this.base;
    var max = log(base, this.max);
    var rangeMin = this.rangeMin();
    var range = (this.rangeMax() - rangeMin);
    var min;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      if (value === 0) {
        return 0;
      }
      min = log(base, positiveMin / base);
      var appendPercent = (1 / (max - min)) * range; // 0 到 positiveMin的占比
      if (value < appendPercent) { // 落到 0 - positiveMin 之间
        return value / appendPercent * positiveMin;
      }
    } else {
      min = log(base, this.min);
    }
    var percent = (value - rangeMin) / (range);
    var tmp = percent * (max - min) + min;
    return Math.pow(base, tmp);
  };

  return Log;
}(Linear));

/**
 * @fileOverview 使用pow进行度量计算
 * @author dxq613@gmail.com
 */

// 求以a为次幂，结果为b的基数，如 x^^a = b;求x
function calBase(a, b) {
  var e = Math.E;
  var value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底
  return value;
}

/**
 * 度量的Pow计算
 * @class Scale.Log
 */
var Pow = /*@__PURE__*/(function (Linear) {
  function Pow () {
    Linear.apply(this, arguments);
  }

  if ( Linear ) Pow.__proto__ = Linear;
  Pow.prototype = Object.create( Linear && Linear.prototype );
  Pow.prototype.constructor = Pow;

  Pow.prototype.getDefaultCfg = function getDefaultCfg () {
    var cfg = Linear.prototype.getDefaultCfg.call(this);
    return Util.mix({}, cfg, {
      /**
       * @override
       */
      type: 'pow',

      /**
       * 进行pow计算的基数
       * @type {Number}
       */
      exponent: 2,

      /**
       * @override
       * pow 的坐标点的个数控制在10个以下
       * @type {Number}
       */
      tickCount: 10
    });
  };

  /**
   * @override
   */
  Pow.prototype.calculateTicks = function calculateTicks () {
    var self = this;
    var exponent = self.exponent;
    var min;
    var max = Math.ceil(calBase(exponent, self.max));

    if (self.min >= 0) {
      min = Math.floor(calBase(exponent, self.min));
    } else {
      min = 0;
    }
    if (min > max) {
      var tmp = max;
      max = min;
      min = tmp;
    }
    var count = max - min;
    var tickCount = self.tickCount;
    var avg = Math.ceil(count / tickCount);
    var ticks = [];

    for (var i = min; i < max + avg; i = i + avg) {
      ticks.push(Math.pow(i, exponent));
    }
    return ticks;
  };

  // 获取度量计算时，value占的定义域百分比
  Pow.prototype._getScalePercent = function _getScalePercent (value) {
    var max = this.max;
    var min = this.min;
    if (max === min) {
      return 0;
    }
    var exponent = this.exponent;
    var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));
    return percent;
  };

  /**
   * @override
   */
  Pow.prototype.scale = function scale (value) {
    var percent = this._getScalePercent(value);
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    return rangeMin + percent * (rangeMax - rangeMin);
  };

  /**
   * @override
   */
  Pow.prototype.invert = function invert (value) {
    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    var exponent = this.exponent;
    var max = calBase(exponent, this.max);
    var min = calBase(exponent, this.min);
    var tmp = percent * (max - min) + min;
    return Math.pow(tmp, exponent);
  };

  return Pow;
}(Linear));

/**
 * @fileOverview Scale entry, used to reference all the scales
 * @author dxq613@gmail.com
 */

Base$1.Linear = Linear;
Base$1.Identity = Identity;
Base$1.Cat = Category;
Base$1.Time = Time;
Base$1.TimeCat = TimeCategory;
Base$1.Log = Log;
Base$1.Pow = Pow;

var loop = function ( k ) {
  if (Base$1.hasOwnProperty(k)) {
    var methodName = Util.lowerFirst(k);
    Base$1[methodName] = function(cfg) {
      return new Base$1[k](cfg);
    };
  }
};

for (var k in Base$1) loop( k );

var CAT_ARR = [ 'cat', 'timeCat' ];

Base$1.isCategory = function(type) {
  return CAT_ARR.indexOf(type) >= 0;
};

/**
 * @fileOverview 度量的控制器
 * @author dxq613@gmail.com
 */
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
var TYPES = {
  LINEAR: 'linear',
  CAT: 'cat',
  TIME: 'time'
};

var ScaleController = function ScaleController(cfg) {
  // defs 列定义
  this.defs = {};
  Util.assign(this, cfg);
};

ScaleController.prototype._getDef = function _getDef (field) {
  var defs = this.defs;
  var def = null;
  if (Global.scales[field] || defs[field]) {
    def = Util.mix({}, Global.scales[field]);
    // 处理覆盖属性的问题
    Util.each(defs[field], function(v, k) {
      if (Util.isNil(v)) {
        delete def[k];
      } else {
        def[k] = v;
      }
    });
  }
  return def;
};

ScaleController.prototype._getDefaultType = function _getDefaultType (field, data) {
  var type = TYPES.LINEAR;
  var value = Util.Array.firstValue(data, field);
  if (Util.isArray(value)) {
    value = value[0];
  }
  if (dateRegex.test(value)) {
    type = TYPES.TIME;
  } else if (Util.isString(value)) {
    type = TYPES.CAT;
  }
  return type;
};

ScaleController.prototype._getScaleCfg = function _getScaleCfg (type, field, data) {
  var cfg = {
    field: field
  };
  var values = Util.Array.values(data, field);
  cfg.values = values;
  if (!Base$1.isCategory(type) && type !== 'time') {
    var range = Util.Array.getRange(values);
    cfg.min = range.min;
    cfg.max = range.max;
    cfg.nice = true;
  }

  if (type === 'time') {
    cfg.nice = false;
  }
  return cfg;
};

ScaleController.prototype.createScale = function createScale (field, data) {
  var self = this;
  var def = self._getDef(field);
  var scale;
  // 如果数据为空直接返回常量度量
  if (!data || !data.length) {
    if (def && def.type) {
      scale = Base$1[def.type](def);
    } else {
      scale = Base$1.identity({
        value: field,
        field: field.toString(),
        values: [ field ]
      });
    }
    return scale;
  }
  var firstValue = Util.Array.firstValue(data, field);

  if (Util.isNumber(field) || (Util.isNil(firstValue)) && !def) {
    scale = Base$1.identity({
      value: field,
      field: field.toString(),
      values: [ field ]
    });
  } else { // 如果已经定义过这个度量
    var type;
    if (def) {
      type = def.type;
    }
    type = type || self._getDefaultType(field, data);
    var cfg = self._getScaleCfg(type, field, data);
    if (def) {
      Util.mix(cfg, def);
    }
    scale = Base$1[type](cfg);
  }
  return scale;
};

/**
 * @fileOverview 颜色计算的辅助方法
 * @author dxq613@gmail.com
 */
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var ColorKeywords$1 = {
  aliceblue: '#F0F8FF', antiquewhite: '#FAEBD7', aqua: '#00FFFF', aquamarine: '#7FFFD4', azure: '#F0FFFF',
  beige: '#F5F5DC', bisque: '#FFE4C4', black: '#000000', blanchedalmond: '#FFEBCD', blue: '#0000FF', blueviolet: '#8A2BE2',
  brown: '#A52A2A', burlywood: '#DEB887', cadetblue: '#5F9EA0', chartreuse: '#7FFF00', chocolate: '#D2691E', coral: '#FF7F50',
  cornflowerblue: '#6495ED', cornsilk: '#FFF8DC', crimson: '#DC143C', cyan: '#00FFFF', darkblue: '#00008B', darkcyan: '#008B8B',
  darkgoldenrod: '#B8860B', darkgray: '#A9A9A9', darkgreen: '#006400', darkgrey: '#A9A9A9', darkkhaki: '#BDB76B', darkmagenta: '#8B008B',
  darkolivegreen: '#556B2F', darkorange: '#FF8C00', darkorchid: '#9932CC', darkred: '#8B0000', darksalmon: '#E9967A', darkseagreen: '#8FBC8F',
  darkslateblue: '#483D8B', darkslategray: '#2F4F4F', darkslategrey: '#2F4F4F', darkturquoise: '#00CED1', darkviolet: '#9400D3',
  deeppink: '#FF1493', deepskyblue: '#00BFFF', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1E90FF', firebrick: '#B22222',
  floralwhite: '#FFFAF0', forestgreen: '#228B22', fuchsia: '#FF00FF', gainsboro: '#DCDCDC', ghostwhite: '#F8F8FF', gold: '#FFD700',
  goldenrod: '#DAA520', gray: '#808080', green: '#008000', greenyellow: '#ADFF2F', grey: '#808080', honeydew: '#F0FFF0', hotpink: '#FF69B4',
  indianred: '#CD5C5C', indigo: '#4B0082', ivory: '#FFFFF0', khaki: '#F0E68C', lavender: '#E6E6FA', lavenderblush: '#FFF0F5', lawngreen: '#7CFC00',
  lemonchiffon: '#FFFACD', lightblue: '#ADD8E6', lightcoral: '#F08080', lightcyan: '#E0FFFF', lightgoldenrodyellow: '#FAFAD2', lightgray: '#D3D3D3',
  lightgreen: '#90EE90', lightgrey: '#D3D3D3', lightpink: '#FFB6C1', lightsalmon: '#FFA07A', lightseagreen: '#20B2AA', lightskyblue: '#87CEFA',
  lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#B0C4DE', lightyellow: '#FFFFE0', lime: '#00FF00', limegreen: '#32CD32',
  linen: '#FAF0E6', magenta: '#FF00FF', maroon: '#800000', mediumaquamarine: '#66CDAA', mediumblue: '#0000CD', mediumorchid: '#BA55D3',
  mediumpurple: '#9370DB', mediumseagreen: '#3CB371', mediumslateblue: '#7B68EE', mediumspringgreen: '#00FA9A', mediumturquoise: '#48D1CC',
  mediumvioletred: '#C71585', midnightblue: '#191970', mintcream: '#F5FFFA', mistyrose: '#FFE4E1', moccasin: '#FFE4B5', navajowhite: '#FFDEAD',
  navy: '#000080', oldlace: '#FDF5E6', olive: '#808000', olivedrab: '#6B8E23', orange: '#FFA500', orangered: '#FF4500', orchid: '#DA70D6',
  palegoldenrod: '#EEE8AA', palegreen: '#98FB98', paleturquoise: '#AFEEEE', palevioletred: '#DB7093', papayawhip: '#FFEFD5', peachpuff: '#FFDAB9',
  peru: '#CD853F', pink: '#FFC0CB', plum: '#DDA0DD', powderblue: '#B0E0E6', purple: '#800080', rebeccapurple: '#663399', red: '#FF0000', rosybrown: '#BC8F8F',
  royalblue: '#4169E1', saddlebrown: '#8B4513', salmon: '#FA8072', sandybrown: '#F4A460', seagreen: '#2E8B57', seashell: '#FFF5EE',
  sienna: '#A0522D', silver: '#C0C0C0', skyblue: '#87CEEB', slateblue: '#6A5ACD', slategray: '#708090', slategrey: '#708090', snow: '#FFFAFA',
  springgreen: '#00FF7F', steelblue: '#4682B4', tan: '#D2B48C', teal: '#008080', thistle: '#D8BFD8', tomato: '#FF6347', turquoise: '#40E0D0',
  violet: '#EE82EE', wheat: '#F5DEB3', white: '#FFFFFF', whitesmoke: '#F5F5F5', yellow: '#FFFF00', yellowgreen: '#9ACD32'
};

// 获取颜色之间的插值
function getValue(start, end, percent, index) {
  var value = start[index] + (end[index] - start[index]) * percent;
  return value;
}

function calColor(colors, percent) {
  if (Util.isNaN(percent) || !Util.isNumber(percent)) {
    percent = 0;
  }
  var steps = colors.length - 1;
  var step = Math.floor(steps * percent);
  var left = steps * percent - step;
  var start = colors[step];
  var end = step === steps ? start : colors[step + 1];
  return [ getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2), getValue(start, end, left, 3) ];
}

// rgb 颜色转换成数组
function rgb2arr(str) {
  var arr = [];
  if (str.length === 4) {
    str = "#" + (str[1]) + (str[1]) + (str[2]) + (str[2]) + (str[3]) + (str[3]);
  }
  arr.push(parseInt(str.substr(1, 2), 16));
  arr.push(parseInt(str.substr(3, 2), 16));
  arr.push(parseInt(str.substr(5, 2), 16));
  return arr;
}
var ColorUtil = {
  /**
   * 将颜色转换到 rgb 的格式
   * @param  {String} color 颜色
   * @return {String} 将颜色转换到 '#ffffff' 的格式
   */
  toRGB: function toRGB(color) {
    // 如果已经是 rgb的格式
    var colorArray = [ 255, 255, 255, 255 ];
    if (ColorKeywords$1[color]) { // color name 2  hex
      var hexColor = ColorKeywords$1[color];
      colorArray = rgb2arr(hexColor);
      colorArray.push(255.0);
    }
    if (color[0] === '#' && (color.length === 7 || color.length === 4)) { // hex2array
      colorArray = rgb2arr(color);
      colorArray.push(255.0);
      return colorArray;
    }
    if (RGB_REG.test(color)) {
      var matchs = RGB_REG.exec(color);
      colorArray = matchs[1].split(/\s*,\s*/);
      if (colorArray.length === 4) {
        colorArray[3] *= 255;
      }
      if (colorArray.length === 3) {
        colorArray.push(255.0);
      }
    }
    return colorArray;
  },
  // 转成 WebGl color buffer
  color2Arr: function color2Arr(str) {
    var rgba = this.toRGB(str);
    return rgba.map(function (v) { return v / 255; });
  },
  colorArray2RGBA: function colorArray2RGBA(arr) {
    return ("rgba(" + (arr[0] * 255) + "," + (arr[1] * 255) + "," + (arr[2] * 255) + "," + (arr[3]) + ")");
  },
  color2RGBA: function color2RGBA(str) {
    return this.color2Arr(str);
  },
  rgb2arr: rgb2arr,

  /**
   * 获取渐变函数
   * @param  {Array} colors 多个颜色
   * @return {String} 颜色值
   */
  gradient: function gradient(colors) {
    var points = [];
    if (Util.isString(colors)) {
      colors = colors.split('-');
    }
    Util.each(colors, function(color) {
      var colorArray = ColorUtil.toRGB(color).map(function (e) { return (e / 255); });
      // colorArray[3] = colorArray[3] * 255;
      points.push(colorArray);
    });

    return function(percent) {
      return calColor(points, percent);
    };
  }
};

/**
 * @fileOverview the Attribute base class
 * @author huangtonger@aliyun.com
 */

function toScaleString(scale, value) {
  if (Util.isString(value)) {
    return value;
  }
  return scale.invert(scale.scale(value));
}
/**
 * 所有视觉通道属性的基类
 * @class Attr
 */
var AttributeBase = function AttributeBase(cfg) {
  /**
   * 属性的类型
   * @type {String}
   */
  this.type = 'base';

  /**
   * 属性的名称
   * @type {String}
   */
  this.name = null;

  /**
   * 回调函数
   * @type {Function}
   */
  this.method = null;

  /**
   * 备选的值数组
   * @type {Array}
   */
  this.values = [];

  /**
   * 属性内部的度量
   * @type {Array}
   */
  this.scales = [];

  /**
   * 是否通过线性取值, 如果未指定，则根据数值的类型判定
   * @type {Boolean}
   */
  this.linear = null;

  Util.mix(this, cfg);
};

AttributeBase.prototype.get = function get (name) {
  return this[name];
};

AttributeBase.prototype.set = function set (name, value) {
  this[name] = value;
};

// 获取属性值，将值映射到视觉通道
AttributeBase.prototype._getAttrValue = function _getAttrValue (scale, value) {
  var values = this.values;
  if (scale.isCategory && !this.linear) {
    var index = scale.translate(value);
    return values[index % values.length];
  }
  var percent = scale.scale(value);
  return this.getLinearValue(percent);
};

/**
 * 如果进行线性映射，返回对应的映射值
 * @protected
 * @param{Number} percent 百分比
 * @return {*}颜色值、形状、大小等
 */
AttributeBase.prototype.getLinearValue = function getLinearValue (percent) {
  var values = this.values;
  var steps = values.length - 1;
  var step = Math.floor(steps * percent);
  var leftPercent = steps * percent - step;
  var start = values[step];
  var end = step === steps ? start : values[step + 1];
  var rstValue = start + (end - start) * leftPercent;
  return rstValue;
};

/**
 * 默认的回调函数
 * @param {*} value 回调函数的值
 * @type {Function}
 * @return {Array} 返回映射后的值
 */
AttributeBase.prototype.callback = function callback (value) {

  var self = this;
  var scale = self.scales[0];
  var rstValue = null;
  if (scale.type === 'identity') {

    rstValue = scale.value;
  } else {

    rstValue = self._getAttrValue(scale, value);
  }
  return rstValue;
};

/**
 * 根据度量获取属性名
 * @return {Array} dims of this Attribute
 */
AttributeBase.prototype.getNames = function getNames () {
  var scales = this.scales;
  var names = this.names;
  var length = Math.min(scales.length, names.length);
  var rst = [];
  for (var i = 0; i < length; i++) {
    rst.push(names[i]);
  }
  return rst;
};

/**
 * 根据度量获取维度名
 * @return {Array} dims of this Attribute
 */
AttributeBase.prototype.getFields = function getFields () {
  var scales = this.scales;
  var rst = [];
  Util.each(scales, function(scale) {
    rst.push(scale.field);
  });
  return rst;
};

/**
 * 根据名称获取度量
 * @param{String} name the name of scale
 * @return {Scale} scale
 */
AttributeBase.prototype.getScale = function getScale (name) {
  var scales = this.scales;
  var names = this.names;
  var index = names.indexOf(name);
  return scales[index];
};

/**
 * 映射数据
 * @param {*} params 多个数值
 * @return {Array} 映射的值组成的数组
 */
AttributeBase.prototype.mapping = function mapping () {
    var params = [], len = arguments.length;
    while ( len-- ) params[ len ] = arguments[ len ];

  var scales = this.scales;
  var callback = this.callback;
  var values = params;
  if (callback) {
    for (var i = 0; i < params.length; i++) {
      params[i] = this._toOriginParam(params[i], scales[i]);
    }
    values = callback.apply(this, params);
  }
  if (this.type === 'color' && !Util.isArray(values)) {
    values = ColorUtil.toRGB(values).map(function (e) { return e / 255; });
    // values[3] = values[3] * 255;
  }
  if (!Util.isArray(values)) {
    values = [ values ];
  }
  return values;
};

// 原始的参数
AttributeBase.prototype._toOriginParam = function _toOriginParam (param, scale) {
  var rst = param;
  if (!scale.isLinear) {
    if (Util.isArray(param)) {
      rst = [];
      for (var i = 0; i < param.length; i++) {
        rst.push(toScaleString(scale, param[i]));
      }
    } else {
      rst = toScaleString(scale, param);
    }
  }
  return rst;
};

/**
 * @fileOverview the color attribute of core
 * @author huangtonger@aliyun.com
 */

/**
 * 视觉通道 color
 * @class Attr.Color
 */
var Color$1 = /*@__PURE__*/(function (Base) {
  function Color(cfg) {
    Base.call(this, cfg);
    this.names = [ 'color' ];
    this.type = 'color';
    this.gradient = null;
    if (Util.isString(this.values)) {
      this.linear = true;
    }
  }

  if ( Base ) Color.__proto__ = Base;
  Color.prototype = Object.create( Base && Base.prototype );
  Color.prototype.constructor = Color;

  /**
   * @override
   */
  Color.prototype.getLinearValue = function getLinearValue (percent) {
    var gradient = this.gradient;
    if (!gradient) {
      var values = this.values;
      gradient = ColorUtil.gradient(values);
      this.gradient = gradient;
    }
    var color = gradient(percent);
    return color;
  };

  return Color;
}(AttributeBase));

/**
 * @fileOverview the size attribute of core
 * @author huangtonger@aliyun.com
 */

/**
 * 视觉通道 size
 * @class Attr.Size
 */
var Size = /*@__PURE__*/(function (Base) {
  function Size(cfg) {
    Base.call(this, cfg);
    this.names = [ 'size' ];
    this.type = 'size';
    this.gradient = null;
    this.domainIndex = 0;
  }

  if ( Base ) Size.__proto__ = Base;
  Size.prototype = Object.create( Base && Base.prototype );
  Size.prototype.constructor = Size;

  Size.prototype.mapping = function mapping () {
    var arguments$1 = arguments;

    // 重构
    var self = this;
    var outputs = [];
    var scales = self.scales;
    if (self.values.length === 0) {
      var callback = this.callback.bind(this);
      outputs.push(callback.apply(void 0, arguments));
    } else {
      if (!Util.isArray(self.values[0])) {
        self.values = [ self.values ];
      }
      for (var i = 0; i < scales.length; i++) {
        outputs.push(self._scaling(scales[i], arguments$1[i]));
      }
    }
    this.domainIndex = 0;
    return outputs;
  };

  Size.prototype._scaling = function _scaling (scale, v) {
    if (scale.type === 'identity') {
      return v;
    }
    var percent = scale.scale(v);
    return this.getLinearValue(percent);

    // else if (scale.type === 'linear') {
  };

  Size.prototype.getLinearValue = function getLinearValue (percent) {
    var values = this.values[this.domainIndex];
    var steps = values.length - 1;
    var step = Math.floor(steps * percent);
    var leftPercent = steps * percent - step;
    var start = values[step];
    var end = step === steps ? start : values[step + 1];
    var rstValue = start + (end - start) * leftPercent;
    this.domainIndex += 1;
    return rstValue;
  };

  return Size;
}(AttributeBase));

/**
 * @fileOverview the opacity attribute of core
 * @author huangtonger@aliyun.com
 */

/**
 * 视觉通道 Opacity
 * @class Attr.Opacity
 */
var Opacity = /*@__PURE__*/(function (Base) {
  function Opacity(cfg) {
    Base.call(this, cfg);
    this.names = [ 'opacity' ];
    this.type = 'opacity';
    this.gradient = null;
  }

  if ( Base ) Opacity.__proto__ = Base;
  Opacity.prototype = Object.create( Base && Base.prototype );
  Opacity.prototype.constructor = Opacity;

  return Opacity;
}(AttributeBase));

/**
 * @fileOverview the shape attribute of core
 * @author huangtonger@aliyun.com
 */

/**
 * 视觉通道 Shape
 * @class Attr.Shape
 */
var Shape = /*@__PURE__*/(function (Base) {
  function Shape(cfg) {
    Base.call(this, cfg);
    this.names = [ 'shape' ];
    this.type = 'shape';
    this.gradient = null;
  }

  if ( Base ) Shape.__proto__ = Base;
  Shape.prototype = Object.create( Base && Base.prototype );
  Shape.prototype.constructor = Shape;

  /**
   * @override
   */
  Shape.prototype.getLinearValue = function getLinearValue (percent) {
    var values = this.values;
    var index = Math.round((values.length - 1) * percent);
    return values[index];
  };
  /**
   * @override
   */
  Shape.prototype._getAttrValue = function _getAttrValue (scale, value) {
    if (this.values === 'text') { return value; }
    var values = this.values;
    if (scale.isCategory && !this.linear) {
      var index = scale.translate(value);
      return values[index % values.length];
    }
    var percent = scale.scale(value);
    return this.getLinearValue(percent);
  };

  return Shape;
}(AttributeBase));

/**
 * @fileOverview the position attribute of core
 * @author huangtonger@aliyun.com
 */

var Position = /*@__PURE__*/(function (Base) {
  function Position(cfg) {
    Base.call(this, cfg);
    this.names = [ 'x', 'y' ];
    this.type = 'position';
  }

  if ( Base ) Position.__proto__ = Base;
  Position.prototype = Object.create( Base && Base.prototype );
  Position.prototype.constructor = Position;

  Position.prototype.mapping = function mapping (x, y) {
    var scales = this.scales;
    var coord = this.coord;
    var scaleX = scales[0];
    var scaleY = scales[1];
    var rstX;
    var rstY;
    var obj;
    if (Util.isNil(x) || Util.isNil(y)) {
      return [];
    }
    if (Util.isArray(y) && Util.isArray(x)) {
      rstX = [];
      rstY = [];
      for (var i = 0, j = 0; i < x.length && j < y.length; i++, j++) {
        obj = coord.convertPoint({
          x: scaleX.scale(x[i]),
          y: scaleY.scale(y[j])
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if (Util.isArray(y)) {
      x = scaleX.scale(x);
      rstY = [];
      Util.each(y, function(yVal) {
        yVal = scaleY.scale(yVal);
        obj = coord.convertPoint({
          x: x,
          y: yVal
        });
        if (rstX && rstX !== obj.x) {
          if (!Util.isArray(rstX)) {
            rstX = [ rstX ];
          }
          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }
        rstY.push(obj.y);
      });
    } else if (Util.isArray(x)) {
      y = scaleY.scale(y);
      rstX = [];
      Util.each(x, function(xVal) {
        xVal = scaleX.scale(xVal);
        obj = coord.convertPoint({
          x: xVal,
          y: y
        });
        if (rstY && rstY !== obj.y) {
          if (!Util.isArray(rstY)) {
            rstY = [ rstY ];
          }
          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }
        rstX.push(obj.x);
      });
    } else {
      x = scaleX.scale(x);
      y = scaleY.scale(y);
      var point = coord.convertPoint({
        x: x,
        y: y
      });
      rstX = point.x;
      rstY = point.y;
    }
    return [ rstX, rstY ];
  };

  return Position;
}(AttributeBase));

/*
 * @Author: ThinkGIS
 * @Date: 2018-06-14 20:13:18
 * @Last Modified by: ThinkGIS
 * @Last Modified time: 2018-07-02 18:24:58
 */

/**
 * 视觉通道 symbol
 * @class Attr.symbol
 */
var Symbol = /*@__PURE__*/(function (Base) {
  function Symbol(cfg) {
    Base.call(this, cfg);
    this.names = [ 'symbol' ];
    this.type = 'symbol';
    this.gradient = null;
  }

  if ( Base ) Symbol.__proto__ = Base;
  Symbol.prototype = Object.create( Base && Base.prototype );
  Symbol.prototype.constructor = Symbol;

  return Symbol;
}(AttributeBase));

/*
 * @Author: ThinkGIS
 * @Date: 2018-06-14 20:13:18
 * @Last Modified by: mikey.zhaopeng
 * @Last Modified time: 2019-07-08 15:46:28
 */

/**
 * 视觉通道 filter
 * @class Attr.filter
 */
var Filter = /*@__PURE__*/(function (Base) {
  function Filter(cfg) {
    Base.call(this, cfg);
    this.names = [ 'filter' ];
    this.type = 'filter';
    this.gradient = null;
  }

  if ( Base ) Filter.__proto__ = Base;
  Filter.prototype = Object.create( Base && Base.prototype );
  Filter.prototype.constructor = Filter;

  return Filter;
}(AttributeBase));

/**
 * 视觉通道 pattern
 * @class Attr.pattern
 */
var Pattern = /*@__PURE__*/(function (Base) {
  function Pattern(cfg) {
    Base.call(this, cfg);
    this.names = [ 'pattern' ];
    this.type = 'pattern';
    this.gradient = null;
  }

  if ( Base ) Pattern.__proto__ = Base;
  Pattern.prototype = Object.create( Base && Base.prototype );
  Pattern.prototype.constructor = Pattern;

  return Pattern;
}(AttributeBase));

AttributeBase.Color = Color$1;
AttributeBase.Size = Size;
AttributeBase.Opacity = Opacity;
AttributeBase.Shape = Shape;
AttributeBase.Position = Position;
AttributeBase.Symbol = Symbol;
AttributeBase.Filter = Filter;
AttributeBase.Pattern = Pattern;

var helpers = createCommonjsModule$$1(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.370,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius / 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.370,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1 / 1.0936,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, options) {
    switch (type) {
        case "Point": return point(coordinates).geometry;
        case "LineString": return lineString(coordinates).geometry;
        case "Polygon": return polygon(coordinates).geometry;
        case "MultiPoint": return multiPoint(coordinates).geometry;
        case "MultiLineString": return multiLineString(coordinates).geometry;
        case "MultiPolygon": return multiPolygon(coordinates).geometry;
        default: throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return (!!input) && (input.constructor === Object);
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;
// Deprecated methods
function radians2degrees() {
    throw new Error("method has been renamed to `radiansToDegrees`");
}
exports.radians2degrees = radians2degrees;
function degrees2radians() {
    throw new Error("method has been renamed to `degreesToRadians`");
}
exports.degrees2radians = degrees2radians;
function distanceToDegrees() {
    throw new Error("method has been renamed to `lengthToDegrees`");
}
exports.distanceToDegrees = distanceToDegrees;
function distanceToRadians() {
    throw new Error("method has been renamed to `lengthToRadians`");
}
exports.distanceToRadians = distanceToRadians;
function radiansToDistance() {
    throw new Error("method has been renamed to `radiansToLength`");
}
exports.radiansToDistance = radiansToDistance;
function bearingToAngle() {
    throw new Error("method has been renamed to `bearingToAzimuth`");
}
exports.bearingToAngle = bearingToAngle;
function convertDistance() {
    throw new Error("method has been renamed to `convertLength`");
}
exports.convertDistance = convertDistance;
});

unwrapExports$$1(helpers);
var helpers_1 = helpers.earthRadius;
var helpers_2 = helpers.factors;
var helpers_3 = helpers.unitsFactors;
var helpers_4 = helpers.areaFactors;
var helpers_5 = helpers.feature;
var helpers_6 = helpers.geometry;
var helpers_7 = helpers.point;
var helpers_8 = helpers.points;
var helpers_9 = helpers.polygon;
var helpers_10 = helpers.polygons;
var helpers_11 = helpers.lineString;
var helpers_12 = helpers.lineStrings;
var helpers_13 = helpers.featureCollection;
var helpers_14 = helpers.multiLineString;
var helpers_15 = helpers.multiPoint;
var helpers_16 = helpers.multiPolygon;
var helpers_17 = helpers.geometryCollection;
var helpers_18 = helpers.round;
var helpers_19 = helpers.radiansToLength;
var helpers_20 = helpers.lengthToRadians;
var helpers_21 = helpers.lengthToDegrees;
var helpers_22 = helpers.bearingToAzimuth;
var helpers_23 = helpers.radiansToDegrees;
var helpers_24 = helpers.degreesToRadians;
var helpers_25 = helpers.convertLength;
var helpers_26 = helpers.convertArea;
var helpers_27 = helpers.isNumber;
var helpers_28 = helpers.isObject;
var helpers_29 = helpers.validateBBox;
var helpers_30 = helpers.validateId;
var helpers_31 = helpers.radians2degrees;
var helpers_32 = helpers.degrees2radians;
var helpers_33 = helpers.distanceToDegrees;
var helpers_34 = helpers.distanceToRadians;
var helpers_35 = helpers.radiansToDistance;
var helpers_36 = helpers.bearingToAngle;
var helpers_37 = helpers.convertDistance;

var meta = createCommonjsModule$$1(function (module, exports) {

Object.defineProperty(exports, '__esModule', { value: true });



/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) { return; }
    var j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) { continue; }
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) { return false; }
                coordIndex++;
                multiFeatureIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) { return false; }
                    coordIndex++;
                    if (geomType === 'MultiPoint') { multiFeatureIndex++; }
                }
                if (geomType === 'LineString') { multiFeatureIndex++; }
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) { return false; }
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') { multiFeatureIndex++; }
                    if (geomType === 'Polygon') { geometryIndex++; }
                }
                if (geomType === 'Polygon') { multiFeatureIndex++; }
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    geometryIndex = 0;
                    for (k = 0; k < coords[j].length; k++) {
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) { return false; }
                            coordIndex++;
                        }
                        geometryIndex++;
                    }
                    multiFeatureIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    { if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) { return false; } }
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === undefined) { previousValue = currentCoord; }
        else { previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex); }
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) { break; }
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) { previousValue = currentProperties; }
        else { previousValue = callback(previousValue, currentProperties, featureIndex); }
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false) { break; }
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) { previousValue = currentFeature; }
        else { previousValue = callback(previousValue, currentFeature, featureIndex); }
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
            (isFeature ? geojson.bbox : undefined));
        featureId = (isFeatureCollection ? geojson.features[i].id :
            (isFeature ? geojson.id : undefined));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) { return false; }
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) { return false; }
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) { return false; }
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === undefined) { previousValue = currentGeometry; }
        else { previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId); }
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) { return false; }
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) { return false; }
        }
    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) { previousValue = currentFeature; }
        else { previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex); }
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) { return; }
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') { return; }

        // Generate 2-vertex line segments
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) { return false; }
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) { return false; }
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === undefined) { previousValue = currentSegment; }
        else { previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex); }
        started = true;
    });
    return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) { throw new Error('geojson is required'); }

    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) { return; }
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
        case 'LineString':
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) { return false; }
            break;
        case 'Polygon':
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) { return false; }
            }
            break;
        }
    });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === undefined) { previousValue = currentLine; }
        else { previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex); }
    });
    return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) { throw new Error('options is invalid'); }
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) { featureIndex = geojson.features.length + featureIndex; }
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find SegmentIndex
    if (geometry === null) { return null; }
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
        if (segmentIndex < 0) { segmentIndex = coords.length + segmentIndex - 1; }
        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) { geometryIndex = coords.length + geometryIndex; }
        if (segmentIndex < 0) { segmentIndex = coords[geometryIndex].length + segmentIndex - 1; }
        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) { multiFeatureIndex = coords.length + multiFeatureIndex; }
        if (segmentIndex < 0) { segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1; }
        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) { multiFeatureIndex = coords.length + multiFeatureIndex; }
        if (geometryIndex < 0) { geometryIndex = coords[multiFeatureIndex].length + geometryIndex; }
        if (segmentIndex < 0) { segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1; }
        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
    }
    throw new Error('geojson is invalid');
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) { throw new Error('options is invalid'); }
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) { featureIndex = geojson.features.length + featureIndex; }
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find Coord Index
    if (geometry === null) { return null; }
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
        return helpers.point(coords, properties, options);
    case 'MultiPoint':
        if (multiFeatureIndex < 0) { multiFeatureIndex = coords.length + multiFeatureIndex; }
        return helpers.point(coords[multiFeatureIndex], properties, options);
    case 'LineString':
        if (coordIndex < 0) { coordIndex = coords.length + coordIndex; }
        return helpers.point(coords[coordIndex], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) { geometryIndex = coords.length + geometryIndex; }
        if (coordIndex < 0) { coordIndex = coords[geometryIndex].length + coordIndex; }
        return helpers.point(coords[geometryIndex][coordIndex], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) { multiFeatureIndex = coords.length + multiFeatureIndex; }
        if (coordIndex < 0) { coordIndex = coords[multiFeatureIndex].length + coordIndex; }
        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) { multiFeatureIndex = coords.length + multiFeatureIndex; }
        if (geometryIndex < 0) { geometryIndex = coords[multiFeatureIndex].length + geometryIndex; }
        if (coordIndex < 0) { coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex; }
        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error('geojson is invalid');
}

exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.coordAll = coordAll;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.findSegment = findSegment;
exports.findPoint = findPoint;
});

unwrapExports$$1(meta);
var meta_1 = meta.coordEach;
var meta_2 = meta.coordReduce;
var meta_3 = meta.propEach;
var meta_4 = meta.propReduce;
var meta_5 = meta.featureEach;
var meta_6 = meta.featureReduce;
var meta_7 = meta.coordAll;
var meta_8 = meta.geomEach;
var meta_9 = meta.geomReduce;
var meta_10 = meta.flattenEach;
var meta_11 = meta.flattenReduce;
var meta_12 = meta.segmentEach;
var meta_13 = meta.segmentReduce;
var meta_14 = meta.lineEach;
var meta_15 = meta.lineReduce;
var meta_16 = meta.findSegment;
var meta_17 = meta.findPoint;

var invariant = createCommonjsModule$$1(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 && helpers.isNumber(coordinates[0]) && helpers.isNumber(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
exports.getType = getType;
});

unwrapExports$$1(invariant);
var invariant_1 = invariant.getCoord;
var invariant_2 = invariant.getCoords;
var invariant_3 = invariant.containsNumber;
var invariant_4 = invariant.geojsonType;
var invariant_5 = invariant.featureOf;
var invariant_6 = invariant.collectionOf;
var invariant_7 = invariant.getGeom;
var invariant_8 = invariant.getType;

function djb2hash(str) {
  str = str.toString();
  var hash = 5381,
    i = str.length;

  while (i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var RADIUS = 6378137;
var FLATTENING = 1/298.257223563;
var POLAR_RADIUS = 6356752.3142;

var _wgs84_0_0_0_wgs84 = {
	RADIUS: RADIUS,
	FLATTENING: FLATTENING,
	POLAR_RADIUS: POLAR_RADIUS
};

var geometry_1 = geometry;
var ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,
    area = 0,
    coordsLength = coords.length;

    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {// i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength -1;
                upperIndex = 0;
            } else if (i === coordsLength - 1) {// i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            } else { // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i+1;
                upperIndex = i+2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));
        }

        area = area * _wgs84_0_0_0_wgs84.RADIUS * _wgs84_0_0_0_wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

var geojsonArea = {
	geometry: geometry_1,
	ring: ring
};

var geojsonRewind = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'GeometryCollection':
            gj.geometries = gj.geometries.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], !outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}

function geoJSON(data, cfg) {
  // 矢量瓦片图层不做 rewind
  var resultData = [];
  var featureKeys = {};
  data.features = data.features.filter(function (item) {
    return item != null
          && item.geometry
          && item.geometry.type
          && item.geometry.coordinates
          && Array.isArray(item.geometry.coordinates)
          && item.geometry.coordinates.length > 0;
  });
  geojsonRewind(data, true);
  // 数据为空时处理
  var i = 0;
  meta_10(data, function (currentFeature, featureIndex) { // 多个polygon 拆成一个

    var coord = invariant_2(currentFeature);
    if (coord.length === 0) {
      i++;
      return;
    }
    var id = featureIndex + 1;
    if (cfg.idField && currentFeature.properties[cfg.idField]) {
      var value = currentFeature.properties[cfg.idField];
      id = djb2hash(value) % 1000019;
      featureKeys[id] = {
        index: i++,
        idField: value
      };
    }
    var dataItem = Object.assign({}, currentFeature.properties,
      {coordinates: coord,
      _id: id});
    resultData.push(dataItem);
  });
  return {
    dataArray: resultData,
    featureKeys: featureKeys
  };
}

var AJAXError = /*@__PURE__*/(function (Error) {
  function AJAXError(message, status, url) {
    Error.call(this, message);
    this.status = status;
    this.url = url;

    // work around for https://github.com/Rich-Harris/buble/issues/40
    this.name = this.constructor.name;
    this.message = message;
  }

  if ( Error ) AJAXError.__proto__ = Error;
  AJAXError.prototype = Object.create( Error && Error.prototype );
  AJAXError.prototype.constructor = AJAXError;

  AJAXError.prototype.toString = function toString () {
    return ((this.name) + ": " + (this.message) + " (" + (this.status) + "): " + (this.url));
  };

  return AJAXError;
}(Error));

function makeRequest(requestParameters) {
  var xhr = new XMLHttpRequest();

  xhr.open('GET', requestParameters.url, true);
  for (var k in requestParameters.headers) {
    xhr.setRequestHeader(k, requestParameters.headers[k]);
  }
  xhr.withCredentials = requestParameters.credentials === 'include';
  return xhr;
}

var getArrayBuffer = function(requestParameters, callback) {
  var xhr = makeRequest(requestParameters);
  xhr.responseType = 'arraybuffer';
  xhr.onerror = function() {
    callback(new Error(xhr.statusText));
  };
  xhr.onload = function() {
    var response = xhr.response;
    if (response.byteLength === 0 && xhr.status === 200) {
      return callback(new Error('http status 200 returned without content.'));
    }
    if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
      callback(null, {
        data: response,
        cacheControl: xhr.getResponseHeader('Cache-Control'),
        expires: xhr.getResponseHeader('Expires')
      });
    } else {
      callback(new AJAXError(xhr.statusText, xhr.status, requestParameters.url));
    }
  };
  xhr.send();
  return xhr;
};

var transparentPngUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';

var getImage = function(requestParameters, callback) {
  // request the image with XHR to work around caching issues
  // see https://github.com/mapbox/mapbox-gl-js/issues/1470
  return getArrayBuffer(requestParameters, function (err, imgData) {
    if (err) {
      callback(err);
    } else if (imgData) {
      var img = new window.Image();
      var URL = window.URL || window.webkitURL;
      img.onload = function () {
        callback(null, img);
        URL.revokeObjectURL(img.src);
      };
      var blob = new window.Blob([ new Uint8Array(imgData.data) ], { type: 'image/png' });
      img.cacheControl = imgData.cacheControl;
      img.expires = imgData.expires;
      img.src = imgData.data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
    }
  });
};

function image(data, cfg) {
  var extent = cfg.extent;

  var images = new Promise(function (resolve) {
    loadData(data, function (res) {
      resolve(res);
    });
  });
  var resultData = {
    images: images,
    _id: 1,
    dataArray: [{ coordinates: [[ extent[0], extent[1] ], [ extent[2], extent[3] ]] }]
  };
  return resultData;
}
function loadData(data, done) {
  var url = data;
  var image = [];
  if (typeof (url) === 'string') {
    getImage({ url: url }, function (err, img) {
      image = img;
      done(image);
    });
  } else {
    var imageCount = url.length;
    var imageindex = 0;
    url.forEach(function (item) {
      getImage({ url: item }, function (err, img) {
        imageindex++;
        image.push(img);
        if (imageindex === imageCount) {
          done(image);
        }

      });
    });

  }
  return image;
}

var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

function dsv(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) { return convert(row, i - 1); }
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) { --N; }
    if (text.charCodeAt(N - 1) === RETURN) { --N; }

    function token() {
      if (eof) { return EOF; }
      if (eol) { return eol = false, EOL; }

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE){ }
        if ((i = I) >= N) { eof = true; }
        else if ((c = text.charCodeAt(I++)) === NEWLINE) { eol = true; }
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) { ++I; } }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) { eol = true; }
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) { ++I; } }
        else if (c !== DELIMITER) { continue; }
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) { row.push(t), t = token(); }
      if (f && (row = f(row, n++)) == null) { continue; }
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) { columns = inferColumns(rows); }
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) { columns = inferColumns(rows); }
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows
  };
}

var csv = dsv(",");

var csvParse = csv.parse;

var tsv = dsv("\t");

function csv$1(data, cfg) {
  var x = cfg.x;
  var y = cfg.y;
  var x1 = cfg.x1;
  var y1 = cfg.y1;
  var csvdata = csvParse(data);
  var resultdata = [];
  csvdata.forEach(function (col, featureIndex) {
    var coordinates = [];
    if (x && y) { coordinates = [ col[x] * 1, col[y] * 1 ]; } // 点数据
    if (x1 && y1) { // 弧线 或者线段
      coordinates = [[ col[x] * 1, col[y] * 1 ], [ col[x1] * 1, col[y1] * 1 ]];
    }
    col._id = featureIndex + 1;
    var dataItem = Object.assign({}, col,
      {coordinates: coordinates});
    resultdata.push(dataItem);
  });
  return {
    dataArray: resultdata
  };
}

function json(data, cfg) {

  var x = cfg.x;
  var y = cfg.y;
  var x1 = cfg.x1;
  var y1 = cfg.y1;
  var coordinates = cfg.coordinates;
  var resultdata = [];

  data.slice(0).forEach(function (col, featureIndex) {
    var coords = [];
    if (x && y) { coords = [ col[x], col[y] ]; } // 点数据
    if (x1 && y1) { // 弧线 或者线段
      coords = [[ col[x], col[y] ], [ col[x1], col[y1] ]];
    }
    if (coordinates) {
      var type = 'Polygon';
      if (!Array.isArray(coordinates[0])) {
        type = 'Point';
      }
      if (Array.isArray(coordinates[0]) && !Array.isArray(coordinates[0][0])) {
        type = 'LineString';
      }
      var geometry = {
        type: type,
        coordinates: [].concat( col[coordinates] )
      };
      geojsonRewind(geometry, true);
      coords = geometry.coordinates;
    }

    col._id = featureIndex + 1;
    var dataItem = Object.assign({}, col,
      {coordinates: coords});
    resultdata.push(dataItem);
  });
  return {
    dataArray: resultdata
  };
}

function raster(data, cfg) {
  var extent = cfg.extent;
  var width = cfg.width;
  var height = cfg.height;
  var min = cfg.min;
  var max = cfg.max;
  var resultData = {
    _id: 1,
    dataArray: [
      {
        data: Array.from(data),
        width: width,
        height: height,
        min: min,
        max: max,
        coordinates: [[ extent[0], extent[1] ], [ extent[2], extent[3] ]] }]
  };
  return resultData;
}

var read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

var write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var _ieee754_1_1_13_ieee754 = {
	read: read,
	write: write
};

var _pbf_3_2_0_pbf = Pbf;



function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) { this.skip(val); }
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = _ieee754_1_1_13_ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = _ieee754_1_1_13_ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) { return val; }
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) { return val; }
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readVarint(isSigned)); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readVarint(isSigned)); }
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readSVarint()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readSVarint()); }
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readBoolean()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readBoolean()); }
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readFloat()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readFloat()); }
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readDouble()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readDouble()); }
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readFixed32()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readFixed32()); }
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readSFixed32()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readSFixed32()); }
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readFixed64()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readFixed64()); }
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) { return arr.push(this.readSFixed64()); }
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this.readSFixed64()); }
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) { while (this.buf[this.pos++] > 0x7f) {} }
        else if (type === Pbf.Bytes) { this.pos = this.readVarint() + this.pos; }
        else if (type === Pbf.Fixed32) { this.pos += 4; }
        else if (type === Pbf.Fixed64) { this.pos += 8; }
        else { throw new Error('Unimplemented type: ' + type); }
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) { length *= 2; }

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) { return; }
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        _ieee754_1_1_13_ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        _ieee754_1_1_13_ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) { this.buf[this.pos++] = buffer[i]; }
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedVarint, arr); }   },
    writePackedSVarint:  function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedSVarint, arr); }  },
    writePackedBoolean:  function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedBoolean, arr); }  },
    writePackedFloat:    function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedFloat, arr); }    },
    writePackedDouble:   function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedDouble, arr); }   },
    writePackedFixed32:  function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedFixed32, arr); }  },
    writePackedSFixed32: function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedSFixed32, arr); } },
    writePackedFixed64:  function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedFixed64, arr); }  },
    writePackedSFixed64: function(tag, arr) { if (arr.length) { this.writeMessage(tag, writePackedSFixed64, arr); } },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) { return toNum(l, h, s); }

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) { return; }
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) { pbf.buf[i + extraLen] = pbf.buf[i]; }
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) { pbf.writeVarint(arr[i]); }   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeSVarint(arr[i]); }  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) { pbf.writeFloat(arr[i]); }    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) { pbf.writeDouble(arr[i]); }   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeBoolean(arr[i]); }  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeFixed32(arr[i]); }  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) { pbf.writeSFixed32(arr[i]); } }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) { pbf.writeFixed64(arr[i]); }  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) { pbf.writeSFixed64(arr[i]); } }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) { break; }

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

var pointGeometry = Point;

/**
 * A standalone point geometry with useful accessor, comparison, and
 * modification methods.
 *
 * @class Point
 * @param {Number} x the x-coordinate. this could be longitude or screen
 * pixels, or any other sort of unit.
 * @param {Number} y the y-coordinate. this could be latitude or screen
 * pixels, or any other sort of unit.
 * @example
 * var point = new Point(-77, 38);
 */
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {

    /**
     * Clone this point, returning a new point that can be modified
     * without affecting the old one.
     * @return {Point} the clone
     */
    clone: function() { return new Point(this.x, this.y); },

    /**
     * Add this point's x & y coordinates to another point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    add:     function(p) { return this.clone()._add(p); },

    /**
     * Subtract this point's x & y coordinates to from point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    sub:     function(p) { return this.clone()._sub(p); },

    /**
     * Multiply this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    multByPoint:    function(p) { return this.clone()._multByPoint(p); },

    /**
     * Divide this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    divByPoint:     function(p) { return this.clone()._divByPoint(p); },

    /**
     * Multiply this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    mult:    function(k) { return this.clone()._mult(k); },

    /**
     * Divide this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    div:     function(k) { return this.clone()._div(k); },

    /**
     * Rotate this point around the 0, 0 origin by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @return {Point} output point
     */
    rotate:  function(a) { return this.clone()._rotate(a); },

    /**
     * Rotate this point around p point by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @param {Point} p Point to rotate around
     * @return {Point} output point
     */
    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },

    /**
     * Multiply this point by a 4x1 transformation matrix
     * @param {Array<Number>} m transformation matrix
     * @return {Point} output point
     */
    matMult: function(m) { return this.clone()._matMult(m); },

    /**
     * Calculate this point but as a unit vector from 0, 0, meaning
     * that the distance from the resulting point to the 0, 0
     * coordinate will be equal to 1 and the angle from the resulting
     * point to the 0, 0 coordinate will be the same as before.
     * @return {Point} unit vector point
     */
    unit:    function() { return this.clone()._unit(); },

    /**
     * Compute a perpendicular point, where the new y coordinate
     * is the old x coordinate and the new x coordinate is the old y
     * coordinate multiplied by -1
     * @return {Point} perpendicular point
     */
    perp:    function() { return this.clone()._perp(); },

    /**
     * Return a version of this point with the x & y coordinates
     * rounded to integers.
     * @return {Point} rounded point
     */
    round:   function() { return this.clone()._round(); },

    /**
     * Return the magitude of this point: this is the Euclidean
     * distance from the 0, 0 coordinate to this point's x and y
     * coordinates.
     * @return {Number} magnitude
     */
    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
     * Judge whether this point is equal to another point, returning
     * true or false.
     * @param {Point} other the other point
     * @return {boolean} whether the points are equal
     */
    equals: function(other) {
        return this.x === other.x &&
               this.y === other.y;
    },

    /**
     * Calculate the distance from this point to another point
     * @param {Point} p the other point
     * @return {Number} distance
     */
    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    /**
     * Calculate the distance from this point to another point,
     * without the square root step. Useful if you're comparing
     * relative distances.
     * @param {Point} p the other point
     * @return {Number} distance
     */
    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    /**
     * Get the angle from the 0, 0 coordinate to this point, in radians
     * coordinates.
     * @return {Number} angle
     */
    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    /**
     * Get the angle from this point to another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    /**
     * Get the angle between this point and another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    /*
     * Find the angle of the two vectors, solving the formula for
     * the cross product a x b = |a||b|sin(θ) for θ.
     * @param {Number} x the x-coordinate
     * @param {Number} y the y-coordinate
     * @return {Number} the angle in radians
     */
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _multByPoint: function(p) {
        this.x *= p.x;
        this.y *= p.y;
        return this;
    },

    _divByPoint: function(p) {
        this.x /= p.x;
        this.y /= p.y;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _rotateAround: function(angle, p) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

/**
 * Construct a point from an array if necessary, otherwise if the input
 * is already a Point, or an unknown type, return it unchanged
 * @param {Array<Number>|Point|*} a any kind of input value
 * @return {Point} constructed point, or passed-through value.
 * @example
 * // this
 * var point = Point.convert([0, 1]);
 * // is equivalent to
 * var point = new Point(0, 1);
 */
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

var vectortilefeature = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) { feature.id = pbf.readVarint(); }
    else if (tag == 2) { readTag(pbf, feature); }
    else if (tag == 3) { feature.type = pbf.readVarint(); }
    else if (tag == 4) { feature._geometry = pbf.pos; }
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (length <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) { lines.push(line); }
                line = [];
            }

            line.push(new pointGeometry(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) { lines.push(line); }

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (length <= 0) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) { x1 = x; }
            if (x > x2) { x2 = x; }
            if (y < y1) { y1 = y; }
            if (y > y2) { y2 = y; }

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) { return [rings]; }

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) { continue; }

        if (ccw === undefined) { ccw = area < 0; }

        if (ccw === area < 0) {
            if (polygon) { polygons.push(polygon); }
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) { polygons.push(polygon); }

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}

var vectortilelayer = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) { layer.version = pbf.readVarint(); }
    else if (tag === 1) { layer.name = pbf.readString(); }
    else if (tag === 5) { layer.extent = pbf.readVarint(); }
    else if (tag === 2) { layer._features.push(pbf.pos); }
    else if (tag === 3) { layer._keys.push(pbf.readString()); }
    else if (tag === 4) { layer._values.push(readValueMessage(pbf)); }
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) { throw new Error('feature index out of bounds'); }

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new vectortilefeature(this._pbf, end, this.extent, this._keys, this._values);
};

var vectortile = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new vectortilelayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) { layers[layer.name] = layer; }
    }
}

var VectorTile$1 = vectortile;

function mvt(data, cfg) {
  var tile = new VectorTile$1(new _pbf_3_2_0_pbf(data));
  var layerName = cfg.sourceLayer;
  var features = [];
  var vectorLayer = tile.layers[layerName];
  if (vectorLayer === undefined) {
    return null;
  }
  for (var i = 0; i < vectorLayer.length; i++) {
    var feature = vectorLayer.feature(i);
    var geofeature = feature.toGeoJSON(cfg.tile[0], cfg.tile[1], cfg.tile[2]);
    features.push(geofeature);
  }
  var geodata = {
    type: 'FeatureCollection',
    features: features
  };
  return features.length === 0 ? null : geoJSON(geodata, cfg);
}

var Extent = 4096;
function vector(data, cfg) {
  var tile = cfg.tile;
  var resultdata = [];
  var featureKeys = new Int32Array(data.length);
  var x0 = Extent * tile[0];
  var y0 = Extent * tile[1];
  function covertP20(points) {
    return points.map(function (point) {
      var x1 = (x0 + point.x << 20 - tile[2] - 4) - 215440491;
      var y2 = (y0 + point.y << 20 - tile[2] - 4) - 106744817;
      return [ x1, -y2, 0 ];
    });
  }
  for (var i = 0; i < data.length; i++) {
    var feature = data.feature(i);
    var coords = feature.loadGeometry();
    var properties = feature.properties;
    var id = i + 1;
    if (feature.id || (cfg.idField && properties[cfg.idField])) {
      var value = feature.id || properties[cfg.idField];
      id = djb2hash(value) % 1000019;
      featureKeys[i] = id;
    }
    var geocoords = classifyRings$1(coords);
    for (var j = 0; j < geocoords.length; j++) {
      var geo = geocoords[j].map(function (coord) {
        return covertP20(coord);
      });
      resultdata.push(Object.assign({}, properties,
        {_id: id,
        coordinates: geo}));
    }

  }
  return {
    dataArray: resultdata,
    featureKeys: featureKeys
  };


}
function signedArea$1(ring) {
  var sum = 0;
  for (var i = 0, len = ring.length, j = len - 1, p1 = (void 0), p2 = (void 0); i < len; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2.x - p1.x) * (p1.y + p2.y);
  }
  return sum;
}
function classifyRings$1(rings) {
  var len = rings.length;
  if (len <= 1) { return [ rings ]; }
  var polygons = [];
  var polygon;
  var ccw;

  for (var i = 0; i < len; i++) {
    var area = signedArea$1(rings[i]);
    if (area === 0) { continue; }

    if (ccw === undefined) { ccw = area < 0; }

    if (ccw === area < 0) {
      if (polygon) { polygons.push(polygon); }
      polygon = [ rings[i] ];

    } else {
      polygon.push(rings[i]);
    }
  }
  if (polygon) { polygons.push(polygon); }

  return polygons;
}

var TRANSFORMS = {};
var PARSERS = {};
var getParser = function (type) { return PARSERS[type]; };
var registerParser = function (type, parserFunction) {
  PARSERS[type] = parserFunction;
};
var getTransform = function (type) { return TRANSFORMS[type]; };
var registerTransform = function (type, transFunction) {
  TRANSFORMS[type] = transFunction;
};

function max(x) {
  if (x.length === 0) {
    throw new Error('max requires at least one data point');
  }

  var value = x[0];
  for (var i = 1; i < x.length; i++) {
    // On the first iteration of this loop, max is
    // undefined and is thus made the maximum element in the array
    if (x[i] > value) {
      value = x[i];
    }
  }
  return value;
}

function min(x) {
  if (x.length === 0) {
    throw new Error('min requires at least one data point');
  }

  var value = x[0];
  for (var i = 1; i < x.length; i++) {
    // On the first iteration of this loop, min is
    // undefined and is thus made the minimum element in the array
    if (x[i] < value) {
      value = x[i];
    }
  }
  return value;
}

function sum(x) {
  // If the array is empty, we needn't bother computing its sum
  if (x.length === 0) {
    return 0;
  }

  // Initializing the sum as the first number in the array
  var sum = x[0];

  // Keeping track of the floating-point error correction
  var correction = 0;

  var transition;

  for (var i = 1; i < x.length; i++) {
    transition = sum + x[i];

    // Here we need to update the correction in a different fashion
    // if the new absolute value is greater than the absolute sum
    if (Math.abs(sum) >= Math.abs(x[i])) {
      correction += sum - transition + x[i];
    } else {
      correction += x[i] - transition + sum;
    }

    sum = transition;
  }

  // Returning the corrected sum
  return sum + correction;
}
function mean(x) {
  if (x.length === 0) {
    throw new Error('mean requires at least one data point');
  }
  return sum(x) / x.length;
}

var statistics = /*#__PURE__*/Object.freeze({
sum: sum,
max: max,
min: min,
mean: mean
});

/**
 * 生成四边形热力图
 */

var R_EARTH = 6378000;

function aggregatorToGrid(data, option) {
  var dataArray = data.dataArray;
  var size = option.size; if ( size === void 0 ) size = 10;
  var ref = _pointsGridHash(dataArray, size);
  var gridHash = ref.gridHash;
  var gridOffset = ref.gridOffset;
  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset, option);
  return {
    yOffset: gridOffset.xOffset / 360 * (256 << 20) / 2,
    xOffset: gridOffset.xOffset / 360 * (256 << 20) / 2,
    radius: gridOffset.xOffset / 360 * (256 << 20) / 2,
    dataArray: layerData
  };
}

function _pointsGridHash(dataArray, size) {
  var pLat;
  for (var index = 0; index < dataArray.length; index++) {
    var point = dataArray[index];
    pLat = point.coordinates[1];

  }
  // const centerLat = (latMin + latMax) / 2;
  var centerLat = 34.54083;
  var gridOffset = _calculateGridLatLonOffset(size, centerLat);
  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset: gridOffset };
  }
  var gridHash = {};
  for (var index$1 = 0; index$1 < dataArray.length; index$1++) {
    var point$1 = dataArray[index$1];
    var lat = point$1.coordinates[1];
    var lng = point$1.coordinates[0];

    if (Number.isFinite(lat) && Number.isFinite(lng)) {
      var latIdx = Math.floor((lat + 90) / gridOffset.yOffset);
      var lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);
      var key = latIdx + "-" + lonIdx;

      gridHash[key] = gridHash[key] || { count: 0, points: [] };
      gridHash[key].count += 1;
      gridHash[key].points.push(point$1);
    }
  }

  return { gridHash: gridHash, gridOffset: gridOffset };
}
// 计算网格偏移量
function _calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = _calculateLatOffset(cellSize);
  var xOffset = _calculateLonOffset(latitude, cellSize);
  return { yOffset: yOffset, xOffset: xOffset };
}

function _calculateLatOffset(dy) {
  return (dy / R_EARTH) * (180 / Math.PI);
}

function _calculateLonOffset(lat, dx) {
  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);
}
function _getGridLayerDataFromGridHash(gridHash, gridOffset, option) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);
    var item = {};
    if (option.field && option.method) {
      var columns = getColumn(gridHash[key].points, option.field);
      item[option.method] = statistics[option.method](columns);
    }
    Object.assign(item, {
      _id: i + 1,
      coordinates: [ -180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx ],
      count: gridHash[key].count
    });
    accu.push(item);
    return accu;
  }, []);
}
function getColumn(data, columnName) {
  return data.map(function (item) {
    return item[columnName];
  });
}

var thirdPi = Math.PI / 3,
    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

function pointX(d) {
  return d[0];
}

function pointY(d) {
  return d[1];
}

function hexbin() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      x = pointX,
      y = pointY,
      r,
      dx,
      dy;

  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;

    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point = points[i], i, points))
          || isNaN(py = +y.call(null, point, i, points))) { continue; }

      var point,
          px,
          py,
          pj = Math.round(py = py / dy),
          pi = Math.round(px = px / dx - (pj & 1) / 2),
          py1 = py - pj;

      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi,
            pi2 = pi + (px < pi ? -1 : 1) / 2,
            pj2 = pj + (py < pj ? -1 : 1),
            px2 = px - pi2,
            py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) { pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2; }
      }

      var id = pi + "-" + pj, bin = binsById[id];
      if (bin) { bin.push(point); }
      else {
        bins.push(bin = binsById[id] = [point]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }

    return bins;
  }

  function hexagon(radius) {
    var x0 = 0, y0 = 0;
    return angles.map(function(angle) {
      var x1 = Math.sin(angle) * radius,
          y1 = -Math.cos(angle) * radius,
          dx = x1 - x0,
          dy = y1 - y0;
      x0 = x1, y0 = y1;
      return [dx, dy];
    });
  }

  hexbin.hexagon = function(radius) {
    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
  };

  hexbin.centers = function() {
    var centers = [],
        j = Math.round(y0 / dy),
        i = Math.round(x0 / dx);
    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
        centers.push([x, y]);
      }
    }
    return centers;
  };

  hexbin.mesh = function() {
    var fragment = hexagon(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
  };

  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };

  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };

  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };

  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };

  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };

  return hexbin.radius(1);
}

function aProjectFlat(lnglat) {
  var maxs = 85.0511287798;
  var lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
  var scale = 256 << 20;
  var d = Math.PI / 180;
  var x = lnglat[0] * d;
  var y = lat * d;
  y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

  var a = 0.5 / Math.PI,
    b = 0.5,
    c = -0.5 / Math.PI;
  d = 0.5;
  x = scale * (a * x + b) - 215440491;
  y = scale * (c * y + d) - 106744817;
  return { x: parseInt(x), y: parseInt(y) };
}
function unProjectFlat(px) {
  var a = 0.5 / Math.PI,
    b = 0.5,
    c = -0.5 / Math.PI;
  var d = 0.5;
  var scale = 256 << 20;
  var x = px[0];
  var y = px[1];
  x = ((x + 215440491) / scale - b) / a;
  y = ((y + 106744817) / scale - d) / c;
  y = (Math.atan(Math.pow(Math.E, y)) - (Math.PI / 4)) * 2;
  d = Math.PI / 180;
  var lat = y / d;
  var lng = x / d;
  return [ lng, lat ];
}

var R_EARTH$1 = 6378000;
function pointToHexbin(data, option) {
  var dataArray = data.dataArray;
  var size = option.size; if ( size === void 0 ) size = 10;
  var pixlSize = size / (2 * Math.PI * R_EARTH$1) * (256 << 20) / 2;
  var screenPoints = dataArray.map(function (point) {
    var ref = aProjectFlat(point.coordinates);
    var x = ref.x;
    var y = ref.y;
    return Object.assign({}, point,
      {coordinates: [ x, y ]});
  });

  var newHexbin = hexbin()
    .radius(pixlSize)
    .x(function (d) { return d.coordinates[0]; })
    .y(function (d) { return d.coordinates[1]; });
  var hexbinBins = newHexbin(screenPoints);
  var result = {
    radius: pixlSize
  };
  result.dataArray = hexbinBins.map(function (hex, index) {
    if (option.field && option.method) {
      var columns = getColumn$1(hex, option.field);
      hex[option.method] = statistics[option.method](columns);
    }
    var item = {};
    item[option.method] = hex[option.method];
    return Object.assign({}, item,
      {count: hex.length,
      coordinates: unProjectFlat([ hex.x, hex.y ]),
      _id: index + 1});
  });
  return result;
}
function getColumn$1(data, columnName) {
  return data.map(function (item) {
    return item[columnName];
  });
}

function map(data, options) {
  var callback = options.callback;
  if (callback) {
    data.dataArray = data.dataArray.map(callback);
  }
  return data;
}

// source parser

registerParser('geojson', geoJSON);
registerParser('image', image);
registerParser('csv', csv$1);
registerParser('json', json);
registerParser('raster', raster);
registerParser('mvt', mvt);
registerParser('vector', vector);
// 注册transform

registerTransform('grid', aggregatorToGrid);
registerTransform('hexagon', pointToHexbin);
registerTransform('map', map);

var supercluster = createCommonjsModule$$1(function (module, exports) {
(function (global, factory) {
 module.exports = factory() ;
}(this, function () {
function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) { return; }

    var m = (left + right) >> 1;

    select(ids, coords, m, left, right, depth % 2);

    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
}

function select(ids, coords, k, left, right, inc) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
        }

        var t = coords[2 * k + inc];
        var i = left;
        var j = right;

        swapItem(ids, coords, left, k);
        if (coords[2 * right + inc] > t) { swapItem(ids, coords, left, right); }

        while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) { i++; }
            while (coords[2 * j + inc] > t) { j--; }
        }

        if (coords[2 * left + inc] === t) { swapItem(ids, coords, left, j); }
        else {
            j++;
            swapItem(ids, coords, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var x, y;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                x = coords[2 * i];
                y = coords[2 * i + 1];
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[i]); }
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        x = coords[2 * m];
        y = coords[2 * m + 1];

        if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[m]); }

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function within(ids, coords, qx, qy, r, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var r2 = r * r;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) { result.push(ids[i]); }
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        var x = coords[2 * m];
        var y = coords[2 * m + 1];

        if (sqDist(x, y, qx, qy) <= r2) { result.push(ids[m]); }

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function sqDist(ax, ay, bx, by) {
    var dx = ax - bx;
    var dy = ay - by;
    return dx * dx + dy * dy;
}

var defaultGetX = function (p) { return p[0]; };
var defaultGetY = function (p) { return p[1]; };

var KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {
    if ( getX === void 0 ) { getX = defaultGetX; }
    if ( getY === void 0 ) { getY = defaultGetY; }
    if ( nodeSize === void 0 ) { nodeSize = 64; }
    if ( ArrayType === void 0 ) { ArrayType = Float64Array; }

    this.nodeSize = nodeSize;
    this.points = points;

    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;

    var ids = this.ids = new IndexArrayType(points.length);
    var coords = this.coords = new ArrayType(points.length * 2);

    for (var i = 0; i < points.length; i++) {
        ids[i] = i;
        coords[2 * i] = getX(points[i]);
        coords[2 * i + 1] = getY(points[i]);
    }

    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
};

KDBush.prototype.range = function range$1 (minX, minY, maxX, maxY) {
    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
};

KDBush.prototype.within = function within$1 (x, y, r) {
    return within(this.ids, this.coords, x, y, r, this.nodeSize);
};

var defaultOptions = {
    minZoom: 0,   // min zoom to generate clusters on
    maxZoom: 16,  // max zoom level to cluster the points on
    radius: 40,   // cluster radius in pixels
    extent: 512,  // tile extent (radius is calculated relative to it)
    nodeSize: 64, // size of the KD-tree leaf node, affects performance
    log: false,   // whether to log timing info

    // a reduce function for calculating custom cluster properties
    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }

    // properties to use for individual points when running the reducer
    map: function (props) { return props; } // props => ({sum: props.my_value})
};

var Supercluster = function Supercluster(options) {
    this.options = extend(Object.create(defaultOptions), options);
    this.trees = new Array(this.options.maxZoom + 1);
};

Supercluster.prototype.load = function load (points) {
    var ref = this.options;
        var log = ref.log;
        var minZoom = ref.minZoom;
        var maxZoom = ref.maxZoom;
        var nodeSize = ref.nodeSize;

    if (log) { console.time('total time'); }

    var timerId = "prepare " + (points.length) + " points";
    if (log) { console.time(timerId); }

    this.points = points;

    // generate a cluster object for each point and index input points into a KD-tree
    var clusters = [];
    for (var i = 0; i < points.length; i++) {
        if (!points[i].geometry) { continue; }
        clusters.push(createPointCluster(points[i], i));
    }
    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

    if (log) { console.timeEnd(timerId); }

    // cluster points on max zoom, then cluster the results on previous zoom, etc.;
    // results in a cluster hierarchy across zoom levels
    for (var z = maxZoom; z >= minZoom; z--) {
        var now = +Date.now();

        // create a new set of clusters for the zoom and index them with a KD-tree
        clusters = this._cluster(clusters, z);
        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

        if (log) { console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now); }
    }

    if (log) { console.timeEnd('total time'); }

    return this;
};

Supercluster.prototype.getClusters = function getClusters (bbox, zoom) {
    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
    var minLat = Math.max(-90, Math.min(90, bbox[1]));
    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
    var maxLat = Math.max(-90, Math.min(90, bbox[3]));

    if (bbox[2] - bbox[0] >= 360) {
        minLng = -180;
        maxLng = 180;
    } else if (minLng > maxLng) {
        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
        return easternHem.concat(westernHem);
    }

    var tree = this.trees[this._limitZoom(zoom)];
    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
    var clusters = [];
    for (var i = 0, list = ids; i < list.length; i += 1) {
        var id = list[i];

            var c = tree.points[id];
        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
    }
    return clusters;
};

Supercluster.prototype.getChildren = function getChildren (clusterId) {
    var originId = clusterId >> 5;
    var originZoom = clusterId % 32;
    var errorMsg = 'No cluster with the specified id.';

    var index = this.trees[originZoom];
    if (!index) { throw new Error(errorMsg); }

    var origin = index.points[originId];
    if (!origin) { throw new Error(errorMsg); }

    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
    var ids = index.within(origin.x, origin.y, r);
    var children = [];
    for (var i = 0, list = ids; i < list.length; i += 1) {
        var id = list[i];

            var c = index.points[id];
        if (c.parentId === clusterId) {
            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
        }
    }

    if (children.length === 0) { throw new Error(errorMsg); }

    return children;
};

Supercluster.prototype.getLeaves = function getLeaves (clusterId, limit, offset) {
    limit = limit || 10;
    offset = offset || 0;

    var leaves = [];
    this._appendLeaves(leaves, clusterId, limit, offset, 0);

    return leaves;
};

Supercluster.prototype.getTile = function getTile (z, x, y) {
    var tree = this.trees[this._limitZoom(z)];
    var z2 = Math.pow(2, z);
    var ref = this.options;
        var extent = ref.extent;
        var radius = ref.radius;
    var p = radius / extent;
    var top = (y - p) / z2;
    var bottom = (y + 1 + p) / z2;

    var tile = {
        features: []
    };

    this._addTileFeatures(
        tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),
        tree.points, x, y, z2, tile);

    if (x === 0) {
        this._addTileFeatures(
            tree.range(1 - p / z2, top, 1, bottom),
            tree.points, z2, y, z2, tile);
    }
    if (x === z2 - 1) {
        this._addTileFeatures(
            tree.range(0, top, p / z2, bottom),
            tree.points, -1, y, z2, tile);
    }

    return tile.features.length ? tile : null;
};

Supercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom (clusterId) {
    var clusterZoom = (clusterId % 32) - 1;
    while (clusterZoom <= this.options.maxZoom) {
        var children = this.getChildren(clusterId);
        clusterZoom++;
        if (children.length !== 1) { break; }
        clusterId = children[0].properties.cluster_id;
    }
    return clusterZoom;
};

Supercluster.prototype._appendLeaves = function _appendLeaves (result, clusterId, limit, offset, skipped) {
    var children = this.getChildren(clusterId);

    for (var i = 0, list = children; i < list.length; i += 1) {
        var child = list[i];

            var props = child.properties;

        if (props && props.cluster) {
            if (skipped + props.point_count <= offset) {
                // skip the whole cluster
                skipped += props.point_count;
            } else {
                // enter the cluster
                skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
                // exit the cluster
            }
        } else if (skipped < offset) {
            // skip a single point
            skipped++;
        } else {
            // add a single point
            result.push(child);
        }
        if (result.length === limit) { break; }
    }

    return skipped;
};

Supercluster.prototype._addTileFeatures = function _addTileFeatures (ids, points, x, y, z2, tile) {
    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {
        var i = list[i$1];

            var c = points[i];
        var f = {
            type: 1,
            geometry: [[
                Math.round(this.options.extent * (c.x * z2 - x)),
                Math.round(this.options.extent * (c.y * z2 - y))
            ]],
            tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties
        };
        var id = c.numPoints ? c.id : this.points[c.index].id;
        if (id !== undefined) {
            f.id = id;
        }
        tile.features.push(f);
    }
};

Supercluster.prototype._limitZoom = function _limitZoom (z) {
    return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));
};

Supercluster.prototype._cluster = function _cluster (points, zoom) {
    var clusters = [];
    var ref = this.options;
        var radius = ref.radius;
        var extent = ref.extent;
        var reduce = ref.reduce;
    var r = radius / (extent * Math.pow(2, zoom));

    // loop through each point
    for (var i = 0; i < points.length; i++) {
        var p = points[i];
        // if we've already visited the point at this zoom level, skip it
        if (p.zoom <= zoom) { continue; }
        p.zoom = zoom;

        // find all nearby points
        var tree = this.trees[zoom + 1];
        var neighborIds = tree.within(p.x, p.y, r);

        var numPoints = p.numPoints || 1;
        var wx = p.x * numPoints;
        var wy = p.y * numPoints;

        var clusterProperties = reduce && numPoints > 1 ? this._map(p, true) : null;

        // encode both zoom and point index on which the cluster originated
        var id = (i << 5) + (zoom + 1);

        for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {
            var neighborId = list[i$1];

                var b = tree.points[neighborId];
            // filter out neighbors that are already processed
            if (b.zoom <= zoom) { continue; }
            b.zoom = zoom; // save the zoom (so it doesn't get processed twice)

            var numPoints2 = b.numPoints || 1;
            wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center
            wy += b.y * numPoints2;

            numPoints += numPoints2;
            b.parentId = id;

            if (reduce) {
                if (!clusterProperties) { clusterProperties = this._map(p, true); }
                reduce(clusterProperties, this._map(b));
            }
        }

        if (numPoints === 1) {
            clusters.push(p);
        } else {
            p.parentId = id;
            clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));
        }
    }

    return clusters;
};

Supercluster.prototype._map = function _map (point, clone) {
    if (point.numPoints) {
        return clone ? extend({}, point.properties) : point.properties;
    }
    var original = this.points[point.index].properties;
    var result = this.options.map(original);
    return clone && result === original ? extend({}, result) : result;
};

function createCluster(x, y, id, numPoints, properties) {
    return {
        x: x, // weighted cluster center
        y: y,
        zoom: Infinity, // the last zoom the cluster was processed at
        id: id, // encodes index of the first child of the cluster and its zoom level
        parentId: -1, // parent cluster id
        numPoints: numPoints,
        properties: properties
    };
}

function createPointCluster(p, id) {
    var ref = p.geometry.coordinates;
    var x = ref[0];
    var y = ref[1];
    return {
        x: lngX(x), // projected point coordinates
        y: latY(y),
        zoom: Infinity, // the last zoom the point was processed at
        index: id, // index of the source feature in the original input array,
        parentId: -1 // parent cluster id
    };
}

function getClusterJSON(cluster) {
    return {
        type: 'Feature',
        id: cluster.id,
        properties: getClusterProperties(cluster),
        geometry: {
            type: 'Point',
            coordinates: [xLng(cluster.x), yLat(cluster.y)]
        }
    };
}

function getClusterProperties(cluster) {
    var count = cluster.numPoints;
    var abbrev =
        count >= 10000 ? ((Math.round(count / 1000)) + "k") :
        count >= 1000 ? ((Math.round(count / 100) / 10) + "k") : count;
    return extend(extend({}, cluster.properties), {
        cluster: true,
        cluster_id: cluster.id,
        point_count: count,
        point_count_abbreviated: abbrev
    });
}

// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    var sin = Math.sin(lat * Math.PI / 180);
    var y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return y < 0 ? 0 : y > 1 ? 1 : y;
}

// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    var y2 = (180 - y * 360) * Math.PI / 180;
    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
}

function extend(dest, src) {
    for (var id in src) { dest[id] = src[id]; }
    return dest;
}

function getX(p) {
    return p.x;
}
function getY(p) {
    return p.y;
}

return Supercluster;

}));
});

function cluster(data, option) {
  var radius = option.radius; if ( radius === void 0 ) radius = 80;
  var maxZoom = option.maxZoom; if ( maxZoom === void 0 ) maxZoom = 18;
  var minZoom = option.minZoom; if ( minZoom === void 0 ) minZoom = 0;
  var field = option.field;
  var zoom = option.zoom; if ( zoom === void 0 ) zoom = 2;
  if (data.pointIndex) {
    var clusterPoint$1 = data.pointIndex.getClusters(data.extent, zoom);
    data.dataArray = formatData(clusterPoint$1);
    return data;
  }
  var pointIndex = new supercluster({
    radius: radius,
    minZoom: minZoom,
    maxZoom: maxZoom,
    map: function (props) { return ({ sum: props[field] }); },
    reduce: function (accumulated, props) { accumulated.sum += props.sum; }
  });
  var geojson = {
    type: 'FeatureCollection'
  };
  geojson.features = data.dataArray.map(function (item) {
    var obj;

    return {
      type: 'Feature',
      properties: ( obj = {}, obj[field] = item[field], obj ),
      geometry: {
        type: 'Point',
        coordinates: item.coordinates
      }
    };
  });
  pointIndex.load(geojson.features);
  var clusterPoint = pointIndex.getClusters(data.extent, zoom);
  var resultData = clusterPoint.map(function (point, index) {
    return Object.assign({}, {coordinates: point.geometry.coordinates,
      _id: index + 1},
      point.properties);
  });
  data.dataArray = resultData;
  return { data: data, pointIndex: pointIndex };
}
function formatData(clusterPoint) {
  return clusterPoint.map(function (point, index) {
    return Object.assign({}, {coordinates: point.geometry.coordinates,
      _id: index + 1},
      point.properties);
  });
}

/**
 * 计算地理数据范围
 * @param {dataArray} data 地理坐标数据
 * @return {Array} extent
 */
function extent(data) {
  var extent = [ Infinity, Infinity, -Infinity, -Infinity ];
  data.forEach(function (item) {
    var coordinates = item.coordinates;
    calcExtent(extent, coordinates);
  });
  return extent;
}
function calcExtent(extent, coords) {
  if (Array.isArray(coords[0])) {
    coords.forEach(function (coord) {
      calcExtent(extent, coord);
    });
  } else {
    if (extent[0] > coords[0]) { extent[0] = coords[0]; }
    if (extent[1] > coords[1]) { extent[1] = coords[1]; }
    if (extent[2] < coords[0]) { extent[2] = coords[0]; }
    if (extent[3] < coords[1]) { extent[3] = coords[1]; }
  }
  return extent;
}

function tranfrormCoord(data, cb) {
  return transform(data, cb);
}
function transform(item, cb) {
  if (Array.isArray(item[0])) {
    return item.map(function (coord) {
      return transform(coord, cb);
    });
  }
  return cb(item);

}

var WORLD_SIZE = 512;
var MERCATOR_A = 6378137.0;
var WORLD_SCALE = 1 / 100;
var PROJECTION_WORLD_SIZE = WORLD_SIZE / (MERCATOR_A * Math.PI) / 2;
var MapBox = /*@__PURE__*/(function (Base) {
  function MapBox(cfg) {
    var this$1 = this;

    Base.call(this, cfg);
    this.container = this.get('container');
    this.initMap();
    this.addOverLayer();
    setTimeout(function () {
      this$1.emit('mapLoad');
    }, 10);

  }

  if ( Base ) MapBox.__proto__ = Base;
  MapBox.prototype = Object.create( Base && Base.prototype );
  MapBox.prototype.constructor = MapBox;

  MapBox.prototype.getDefaultCfg = function getDefaultCfg () {
    return Util.assign(Global.scene, {
      resizeEnable: true,
      viewMode: '3D'
    });
  };
  MapBox.project = function project (lnglat) {
    var d = Math.PI / 180;
    var x = -MERCATOR_A * lnglat[0] * d * PROJECTION_WORLD_SIZE;
    var y = -MERCATOR_A * Math.log(Math.tan((Math.PI * 0.25) + (0.5 * lnglat[1] * d))) * PROJECTION_WORLD_SIZE;
    return { x: x, y: y };
  };

  MapBox.prototype.initMap = function initMap () {
    mapboxgl.accessToken = 'pk.eyJ1IjoibHp4dWUiLCJhIjoiYnhfTURyRSJ9.Ugm314vAKPHBzcPmY1p4KQ';
    this.map = new mapboxgl.Map(this._attrs);
  };
  MapBox.prototype.asyncCamera = function asyncCamera (engine) {
    var this$1 = this;

    this.engine = engine;
    var camera = engine._camera;
    var scene = engine.world;
    var pickScene = engine._picking.world;
    camera.matrixAutoUpdate = false;
    scene.position.x = scene.position.y = WORLD_SIZE / 2;
    scene.matrixAutoUpdate = false;
    pickScene.position.x = pickScene.position.y = WORLD_SIZE / 2;
    pickScene.matrixAutoUpdate = false;
    this.updateCamera();
    this.map.on('move', function () {
      this$1.updateCamera();
    });
  };
  MapBox.prototype.updateCamera = function updateCamera () {
    var engine = this.engine;
    var scene = engine.world;
    var pickScene = engine._picking.world;
    var camera = engine._camera;
    // Build a projection matrix, paralleling the code found in Mapbox GL JS
    var fov = 0.6435011087932844;
    var cameraToCenterDistance = 0.5 / Math.tan(fov / 2) * this.map.transform.height * WORLD_SCALE;
    var halfFov = fov / 2;
    var groundAngle = Math.PI / 2 + this.map.transform._pitch;
    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov);

    // Calculate z distance of the farthest fragment that should be rendered.
    var furthestDistance = Math.cos(Math.PI / 2 - this.map.transform._pitch) * topHalfSurfaceDistance + cameraToCenterDistance;

    // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance`
    var farZ = furthestDistance * 1.1;
    if (this.pitch > 50) {
      farZ = 1000;
    }
    var ref = this.map.transform.point;
    var x = ref.x;
    var y = ref.y;
    camera.projectionMatrix = this.makePerspectiveMatrix(fov, this.map.transform.width / this.map.transform.height, 1, farZ);
    var cameraWorldMatrix = new Matrix4();
    var cameraTranslateZ = new Matrix4().makeTranslation(0, 0, cameraToCenterDistance);
    var cameraRotateX = new Matrix4().makeRotationX(this.map.transform._pitch);
    var cameraRotateZ = new Matrix4().makeRotationZ(this.map.transform.angle);
    var cameraTranslateXY = new Matrix4().makeTranslation(x * WORLD_SCALE, -y * WORLD_SCALE, 0);
    // const cameraTranslateCenter = new THREE.Matrix4().makeTranslation(0, 0, cameraToCenterDistance);
    // Unlike the Mapbox GL JS camera, separate camera translation and rotation out into its world matrix
    // If this is applied directly to the projection matrix, it will work OK but break raycasting
    cameraWorldMatrix
      .premultiply(cameraTranslateZ)
      .premultiply(cameraRotateX)
      .premultiply(cameraRotateZ)
      .premultiply(cameraTranslateXY);

    camera.matrixWorld.copy(cameraWorldMatrix);

    var zoomPow = this.map.transform.scale * WORLD_SCALE;
    // Handle scaling and translation of objects in the map in the world's matrix transform, not the camera
    var scale = new Matrix4();
    var translateCenter = new Matrix4();
    var translateMap = new Matrix4();
    var rotateMap = new Matrix4();
    scale
      .makeScale(zoomPow, zoomPow, 1.0);
    translateCenter
      .makeTranslation(WORLD_SIZE / 2, -WORLD_SIZE / 2, 0);
    translateMap
      .makeTranslation(-this.map.transform.x, this.map.transform.y, 0);
    rotateMap
      .makeRotationZ(Math.PI);
    scene.matrix = new Matrix4();
    scene.matrix
      .premultiply(rotateMap)
      .premultiply(translateCenter)
      .premultiply(scale);
    pickScene.matrix = new Matrix4();
    pickScene.matrix
      .premultiply(rotateMap)
      .premultiply(translateCenter)
      .premultiply(scale);
  };
  MapBox.prototype.makePerspectiveMatrix = function makePerspectiveMatrix (fovy, aspect, near, far) {
    var out = new Matrix4();
    var f = 1.0 / Math.tan(fovy / 2),
      nf = 1 / (near - far);
    var newMatrix = [
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (far + near) * nf, -1,
      0, 0, (2 * far * near) * nf, 0
    ];
    out.elements = newMatrix;
    return out;
  };

  MapBox.prototype.projectFlat = function projectFlat (lnglat) {
    return this.map.lngLatToGeodeticCoord(lnglat);
  };
  MapBox.prototype.getCenter = function getCenter () {
    return this.map.getCenter();
  };
  MapBox.prototype.getCenterFlat = function getCenterFlat () {
    return this.projectFlat(this.getCenter());
  };
  MapBox.prototype.addOverLayer = function addOverLayer () {
    var canvasContainer = document.getElementById(this.container);
    this.canvasContainer = canvasContainer;
    this.renderDom = document.createElement('div');
    this.renderDom.style.cssText += 'position: absolute;top: 0; z-index:10;height: 100%;width: 100%;pointer-events: none;';
    this.renderDom.id = 'l7_canvaslayer';
    canvasContainer.appendChild(this.renderDom);
  };
  MapBox.prototype.mixMap = function mixMap (scene) {
    var map = this.map;
    scene.getZoom = function () { return map.getZoom(); };
    scene.getCenter = function () { return map.getCenter(); };
    scene.getPitch = function () { return map.getPitch(); };
    scene.containerToLngLat = function (point) { return map.unproject(point); };

  };

  return MapBox;
}(Base));

var DarkTheme = {
  mapStyle: 'amap://styles/ba3e9759545cd618392ef073c0dfda8c?isPublic=true'
};

var LightTheme = {
  mapStyle: 'amap://styles/a80c558f91b29cf56fa47f895fb1773c?isPublic=true'
};

var BlankTheme = {
  mapStyle: 'amap://styles/07c17002b38775b32a7a76c66cf90e99?isPublic=true'
};

var DEG2RAD = Math.PI / 180;
var GaodeMap = /*@__PURE__*/(function (Base) {
  function GaodeMap(cfg) {
    Base.call(this, cfg);
    this.container = document.getElementById(this.get('id'));
    this.initMap();
  }

  if ( Base ) GaodeMap.__proto__ = Base;
  GaodeMap.prototype = Object.create( Base && Base.prototype );
  GaodeMap.prototype.constructor = GaodeMap;

  GaodeMap.prototype.getDefaultCfg = function getDefaultCfg () {
    return Util.assign(Global.scene, {
      resizeEnable: true,
      viewMode: '3D'
    });
  };
  GaodeMap.project = function project (lnglat) {
    var maxs = 85.0511287798;
    var lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
    var scale = 256 << 20;
    var d = Math.PI / 180;
    var x = lnglat[0] * d;
    var y = lat * d;
    y = Math.log(Math.tan(Math.PI / 4 + y / 2));
    var a = 0.5 / Math.PI,
      b = 0.5,
      c = -0.5 / Math.PI;
    d = 0.5;
    x = scale * (a * x + b) - 215440491;
    y = -(scale * (c * y + d) - 106744817);
    return { x: x, y: y };
  };

  GaodeMap.prototype.initMap = function initMap () {
    var this$1 = this;

    var mapStyle = this.get('mapStyle');
    if (mapStyle) {
      switch (mapStyle) {
        case 'dark':
          this.set('mapStyle', DarkTheme.mapStyle);
          break;
        case 'light':
          this.set('mapStyle', LightTheme.mapStyle);
          break;
        case 'blank':
          this.set('mapStyle', BlankTheme.mapStyle);
          break;
        default:
          this.set('mapStyle', mapStyle);
      }
    }
    this.set('zooms', [ this.get('minZoom'), this.get('maxZoom') ]);
    var map = this.get('map');
    if (map instanceof AMap.Map) {
      this.map = map;
      this.container = map.getContainer();
      this.setMapStyle(mapStyle);
      this.addOverLayer();
      setTimeout(function () { this$1.emit('mapLoad'); }, 50);
    } else {
      this.map = new AMap.Map(this.container, this._attrs);
      this.map.on('complete', function () {
        this$1.setMapStyle(mapStyle);
        this$1.addOverLayer();
        this$1.emit('mapLoad');
      });
    }

  };
  GaodeMap.prototype.asyncCamera = function asyncCamera (engine) {
    this._engine = engine;
    this.updateCamera();
    this.map.on('camerachange', this.updateCamera.bind(this));
  };
  GaodeMap.prototype.updateCamera = function updateCamera () {
    var camera = this._engine._camera;
    var mapCamera = this.map.getCameraState();
    var fov = mapCamera.fov;
    var near = mapCamera.near;
    var far = mapCamera.far;
    var height = mapCamera.height;
    var pitch = mapCamera.pitch;
    var rotation = mapCamera.rotation;
    var aspect = mapCamera.aspect;
    pitch *= DEG2RAD;
    rotation *= DEG2RAD;
    camera.fov = (180 * fov) / Math.PI;
    camera.aspect = aspect;
    camera.near = near;
    camera.far = far;
    camera.updateProjectionMatrix();
    camera.position.z = height * Math.cos(pitch);
    camera.position.x = height * Math.sin(pitch) * Math.sin(rotation);
    camera.position.y = -height * Math.sin(pitch) * Math.cos(rotation);
    camera.up.x = -Math.cos(pitch) * Math.sin(rotation);
    camera.up.y = Math.cos(pitch) * Math.cos(rotation);
    camera.up.z = Math.sin(pitch);
    camera.lookAt(0, 0, 0);
    camera.position.x += mapCamera.position.x;
    camera.position.y += -mapCamera.position.y;
  };

  GaodeMap.prototype.projectFlat = function projectFlat (lnglat) {
    return this.map.lngLatToGeodeticCoord(lnglat);
  };
  GaodeMap.prototype.getCenter = function getCenter () {
    return this.map.getCenter();
  };
  GaodeMap.prototype.getCenterFlat = function getCenterFlat () {
    return this.projectFlat(this.getCenter());
  };
  GaodeMap.prototype.addOverLayer = function addOverLayer () {
    this.amapContainer = this.map.getContainer().getElementsByClassName('amap-maps')[0];
    this.renderDom = document.createElement('div');
    this.renderDom.style.cssText +=
      'position: absolute;top: 0;height: 100%;width: 100%;pointer-events: none;';
    this.renderDom.id = 'l7_canvaslayer';

    this.amapContainer.appendChild(this.renderDom);
    this.l7_marker_Container = document.createElement('div');
    this.l7_marker_Container.className = 'l7_marker';
    this.amapContainer.appendChild(this.l7_marker_Container);
  };
  GaodeMap.prototype.setMapStyle = function setMapStyle (style) {
    var map = this.map;
    switch (style) {
      case 'dark':
        this.set('mapStyle', DarkTheme.mapStyle);
        break;
      case 'light':
        this.set('mapStyle', LightTheme.mapStyle);
        break;
      case 'blank':
        this.set('mapStyle', BlankTheme.mapStyle);
        break;
      default:
        this.set('mapStyle', style);
    }
    map.setMapStyle(this.get('mapStyle'));
    if (style === 'blank') {
      map.setLayers([]);
    }
    return;
  };
  GaodeMap.prototype.mixMap = function mixMap (scene) {
    var this$1 = this;

    var map = this.map;
    scene.project = GaodeMap.project;
    scene.getZoom = function () {
      return map.getZoom();
    };
    scene.getCenter = function () {
      return map.getCenter();
    };
    scene.getSize = function () {
      return map.getSize();
    };
    scene.getPitch = function () {
      return map.getPitch();
    };
    scene.getRotation = function () {
      return map.getRotation();
    };
    scene.getStatus = function () {
      return map.getStatus();
    };
    scene.getScale = function () {
      return map.getScale();
    };
    scene.setZoom = function (zoom) {
      return map.setZoom(zoom);
    };
    scene.getBounds = function () {
      return map.getBounds();
    };
    scene.setMapStyle = function (style) {
      return this$1.setMapStyle(style);
    };
    scene.setZoomAndCenter = function (zoom, center) {
      var lnglat = new AMap.LngLat(center[0], center[1]);
      return map.setZoomAndCenter(zoom, lnglat);
    };
    scene.setFeature = function (features) {
      return map.setFeature(features);
    };
    scene.setBounds = function (extent) {
      return map.setBounds(new AMap.Bounds([ extent[0], extent[1] ], [ extent[2], extent[3] ]));
    };
    scene.setRotation = function (rotation) {
      return map.setRotation(rotation);
    };
    scene.setStatus = function (status) {
      return map.setStatus(status);
    };
    scene.zoomIn = function () {
      return map.zoomIn();
    };
    scene.zoomOut = function () {
      return map.zoomOut();
    };
    scene.panTo = function (lnglat) {
      return map.panTo(new AMap.LngLat(lnglat[0], lnglat[1]));
    };
    scene.panBy = function (x, y) {
      return map.panBy(x, y);
    };
    scene.setPitch = function (pitch) {
      return map.setPitch(pitch);
    };
    scene.pixelToLngLat = function (pixel) {
      var ll = new AMap.Pixel(pixel[0], pixel[1]);
      return map.pixelToLngLat(ll);
    };
    scene.lngLatToPixel = function (lnglat) {
      return map.lnglatToPixel(new AMap.LngLat(lnglat[0], lnglat[1]));
    };
    scene.fitBounds = function (extent) {
      return map.setBounds(
        new AMap.Bounds([ extent[0], extent[1] ], [ extent[2], extent[3] ])
      );
    };
    scene.containerToLngLat = function (pixel) {
      var ll = new AMap.Pixel(pixel.x, pixel.y);
      return map.containerToLngLat(ll);
    };
    scene.lngLatToContainer = function (lnglat) {
      var ll = new AMap.LngLat(lnglat[0], lnglat[1]);
      return map.lngLatToContainer(ll);
    };
    scene.lngLatToGeodeticCoord = function (lnglat) {
      var ll = new AMap.LngLat(lnglat[0], lnglat[1]);
      return map.lngLatToGeodeticCoord(ll);
    };
  };

  return GaodeMap;
}(Base));

var MapType = {
  amap: GaodeMap,
  mapbox: MapBox
};
var getMap = function (type) {
  return MapType[type.toLowerCase()];
};

var Source = /*@__PURE__*/(function (Base) {
  function Source(cfg) {
    Base.call(this, cfg);
    var transform = this.get('transforms');
    this._transforms = transform || [];
    var mapType = this.get('mapType') || 'AMap';
    this.projectFlat = getMap(mapType).project;
    // 数据解析
    this._init();

  }

  if ( Base ) Source.__proto__ = Base;
  Source.prototype = Object.create( Base && Base.prototype );
  Source.prototype.constructor = Source;
  Source.prototype.getDefaultCfg = function getDefaultCfg () {
    return {
      data: null,
      parser: {},
      transforms: [],
      options: {}
    };
  };

  Source.prototype._init = function _init () {
    this._excuteParser();
    var isCluster = this.get('isCluster') || false;
    isCluster && this._executeCluster();
    // 数据转换 统计，聚合，分类
    this._executeTrans();
    // 坐标转换
    if (!this.get('projected')) {
      this._projectCoords();
    }
  };
  Source.prototype.setData = function setData (data, cfg) {
    if ( cfg === void 0 ) cfg = {};

    Object.assign(this._attrs, cfg);
    var transform = this.get('transforms');
    this._transforms = transform || [];
    this.set('data', data);
    this._init();
    this.emit('SourceUpdate');
  };
  // 数据更新
  Source.prototype.updateTransfrom = function updateTransfrom (cfg) {
    var transforms = cfg.transforms;
    this._transforms = transforms;
    this.data = lib_83(this.originData);
    this._executeTrans();
    this._projectCoords();
  };

  Source.prototype._excuteParser = function _excuteParser () {
    var parser = this.get('parser');
    var type = parser.type; if ( type === void 0 ) type = 'geojson';
    var data = this.get('data');
    this.originData = getParser(type)(data, parser);
    // this.data = {
    //   dataArray: clone(this.originData.dataArray)
    // }; // TODO 关闭数据备份
    this.data = this.originData;
    if (this.data !== null && !this.get('projected')) {
      this.data.extent = extent(this.data.dataArray);
    }
  };
  /**
   * 数据统计
   */
  Source.prototype._executeTrans = function _executeTrans () {
    var this$1 = this;

    var trans = this._transforms;
    trans.forEach(function (tran) {
      var type = tran.type;
      var data = getTransform(type)(this$1.data, tran);
      Object.assign(this$1.data, data);
    });
    this._transforms = trans;
  };
  Source.prototype.transform = function transform (option) {
    var data = getTransform(option.type)(this.data, option);
    Object.assign(this.data, data);
  };
  Source.prototype._executeCluster = function _executeCluster () {
    var clusterCfg = this.get('Cluster') || {};
    var zoom = this.get('zoom');
    clusterCfg.zoom = Math.floor(zoom);
    this.set('cluster', clusterCfg);
    var clusterData = cluster(this.data, clusterCfg);
    this.data = clusterData.data;
    this.pointIndex = clusterData.pointIndex;
  };
  Source.prototype.updateCusterData = function updateCusterData (zoom, bbox) {
    var clusterPoint = this.pointIndex.getClusters(bbox, zoom);
    this.data.dataArray = formatData(clusterPoint);
    var clusterCfg = this.get('Cluster') || {};
    clusterCfg.zoom = Math.floor(zoom);
    clusterCfg.bbox = bbox;
    this.set('cluster', clusterCfg);
    this._projectCoords();
    this.emit('SourceUpdate');
  };
  Source.prototype._projectCoords = function _projectCoords () {
    var this$1 = this;

    if (this.data === null) {
      return;
    }
    this.data.dataArray.forEach(function (data) {
      // data.coordinates = this._coordProject(data.coordinates);
      data.coordinates = tranfrormCoord(data.coordinates, this$1._coorConvert.bind(this$1));
    });
  };
  Source.prototype._getCoord = function _getCoord (geo) {
    if (geo.geometry) {
      // GeoJSON feature
      geo = geo.geometry.coordinates;
    } else if (geo.coordinates) {
      // GeoJSON geometry
      geo = geo.coordinates;
    }
    return geo;
  };
  Source.prototype._coordProject = function _coordProject (geo) {
    var this$1 = this;

    if (Array.isArray(geo[0][0])) {
      return geo.map(function (coor) {
        return this$1._coordProject(coor);
      });
    }
    if (!Array.isArray(geo[0])) {
      return this._coorConvert(geo);
    }
    return geo.map(function (coor) {
      return this$1._coorConvert(coor);
    });
  };
  Source.prototype._coorConvert = function _coorConvert (geo) {
    var ll = this.projectFlat(geo);
    return [ ll.x, ll.y, geo[2] || 0 ];
  };
  Source.prototype.getSelectFeature = function getSelectFeature (featureId) {
    var data = this.get('data');
    // 如果是GeoJSON 数据返回原数
    // 颜色编码从1开始，要素索引从0开始，所以颜色转变要素需要减1
    var isCluster = this.get('isCluster') || false;
    return (data.features && !isCluster)
      ? data.features[featureId - 1]
      : this.data.dataArray[featureId - 1];
  };
  Source.prototype.getSeletFeatureIndex = function getSeletFeatureIndex (featureId) {
    var data = this.get('data');
    if (!data.features) {
      return featureId - 1;
    }
    var featureIndex = 0;
    for (var i = 0; i < this.data.dataArray.length; i++) {
      var item = this.data.dataArray[i];
      if (item._id === featureId) {
        break;
      }
      featureIndex++;
    }
    return featureIndex;
  };
  Source.prototype.destroy = function destroy () {
    this.data = null;
    this.originData = null;
  };

  return Source;
}(Base));

var BufferBase = /*@__PURE__*/(function (Base) {
  function BufferBase(cfg) {
    Base.call(this, cfg);
    this.attributes = {
    };
    this.verticesCount = 0;
    this.indexCount = 0;
    this.indexArray = new Int32Array(0);
    this._init();
  }

  if ( Base ) BufferBase.__proto__ = Base;
  BufferBase.prototype = Object.create( Base && Base.prototype );
  BufferBase.prototype.constructor = BufferBase;
  BufferBase.prototype._init = function _init () {
    this._calculateFeatures();
    this._initAttributes();
    this._buildFeatures();
  };
  BufferBase.prototype._initAttributes = function _initAttributes () {
    this.attributes.positions = new Float32Array(this.verticesCount * 3);
    this.attributes.colors = new Float32Array(this.verticesCount * 4);
    this.attributes.pickingIds = new Float32Array(this.verticesCount);
    this.attributes.sizes = new Float32Array(this.verticesCount);
    this.attributes.pickingIds = new Float32Array(this.verticesCount);
    if (this.get('uv')) {
      this.attributes.uv = new Float32Array(this.verticesCount * 2);
    }
    this.indexArray = new Int32Array(this.indexCount);
  };
  BufferBase.prototype.addFeature = function addFeature () {

  };
  // 更新渲染
  BufferBase.prototype.upload = function upload () {

  };
  BufferBase.prototype.destroy = function destroy () {

  };
  BufferBase.prototype.resize = function resize () {

  };
  BufferBase.prototype.checkIsClosed = function checkIsClosed (points) {
    var p1 = points[0][0];
    var p2 = points[0][points[0].length - 1];
    return (p1[0] === p2[0] && p1[1] === p2[1]);
  };
  BufferBase.prototype.concat = function concat (arrayType, arrays) {
    var totalLength = 0;
    for (var i = 0, list = arrays; i < list.length; i += 1) {
      var arr = list[i];

      totalLength += arr.length;
    }
    var arrayBuffer = new ArrayBuffer(totalLength * arrayType.BYTES_PER_ELEMENT);
    var offset = 0;
    var result = new arrayType(arrayBuffer);
    for (var i$1 = 0, list$1 = arrays; i$1 < list$1.length; i$1 += 1) {
      var arr$1 = list$1[i$1];

      result.set(arr$1, offset);
      offset += arr$1.length;
    }
    return result;
  };
  BufferBase.prototype._encodeArray = function _encodeArray (feature, num) {
    var color = feature.color;
    var id = feature.id;
    var pattern = feature.pattern;
    var size = feature.size;
    var ref = feature.bufferInfo;
    var verticesOffset = ref.verticesOffset;
    var imagePos = this.get('imagePos');
    var start1 = verticesOffset;
    for (var i = 0; i < num; i++) {
      if (feature.hasOwnProperty('color')) {
        this.attributes.colors[start1 * 4 + i * 4] = color[0];
        this.attributes.colors[start1 * 4 + i * 4 + 1] = color[1];
        this.attributes.colors[start1 * 4 + i * 4 + 2] = color[2];
        this.attributes.colors[start1 * 4 + i * 4 + 3] = color[3];

      }
      if (feature.hasOwnProperty('id')) {
        this.attributes.pickingIds[start1 + i] = id;
      }
      if (feature.hasOwnProperty('size')) {
        var size2 = size;
        if (Array.isArray(size) && size.length === 2) {
          size2 = [ size[0] ];
        }
        if (!Array.isArray(size)) {
          size2 = [ size ];
        }
        this.attributes.sizes.set(size2, (start1 + i) * size2.length);
      }
      if (feature.hasOwnProperty('pattern')) {

        var patternPos = imagePos[pattern] || { x: 0, y: 0 };
        this.attributes.patterns[start1 * 2 + i * 2 ] = patternPos.x;
        this.attributes.patterns[start1 * 2 + i * 2 + 1] = patternPos.y;
      }
    }

  };
  BufferBase.prototype._calculateWall = function _calculateWall (feature) {
    var size = feature.size;
    var ref = feature.bufferInfo;
    var vertices = ref.vertices;
    var indexOffset = ref.indexOffset;
    var verticesOffset = ref.verticesOffset;
    var faceNum = ref.faceNum;
    this._encodeArray(feature, faceNum * 4);
    for (var i = 0; i < faceNum; i++) {
      var prePoint = vertices.slice(i * 3, i * 3 + 3);
      var nextPoint = vertices.slice(i * 3 + 3, i * 3 + 6);
      this._calculateExtrudeFace(prePoint, nextPoint, verticesOffset + i * 4, indexOffset + i * 6, size);
      feature.bufferInfo.verticesOffset += 4;
      feature.bufferInfo.indexOffset += 6;
    }
  };

  BufferBase.prototype._calculateExtrudeFace = function _calculateExtrudeFace (prePoint, nextPoint, positionOffset, indexOffset, size) {
    this.attributes.positions.set([
      prePoint[0], prePoint[1], size,
      nextPoint[0], nextPoint[1], size,
      prePoint[0], prePoint[1], 0,
      nextPoint[0], nextPoint[1], 0
    ],
    positionOffset * 3);
    var indexArray = [ 1, 2, 0, 3, 2, 1 ].map(function (v) { return v + positionOffset; });
    if (this.get('uv')) {
      this.attributes.uv.set([ 0.1, 0, 0, 0, 0.1, size / 2000, 0, size / 2000 ], positionOffset * 2);
    }
    this.indexArray.set(indexArray, indexOffset);
  };

  return BufferBase;
}(Base));

var earcut_1 = earcut;
var default_1 = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) { return triangles; }

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) { outerNode = eliminateHoles(data, holeIndices, outerNode, dim); }

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) { minX = x; }
            if (y < minY) { minY = y; }
            if (x > maxX) { maxX = x; }
            if (y > maxY) { maxY = y; }
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea$2(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) { last = insertNode(i, data[i], data[i + 1], last); }
    } else {
        for (i = end - dim; i >= start; i -= dim) { last = insertNode(i, data[i], data[i + 1], last); }
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) { return start; }
    if (!end) { end = start; }

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) { break; }
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) { return; }

    // interlink polygon nodes in z-order
    if (!pass && invSize) { indexCurve(ear, minX, minY, invSize); }

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) { return false; } // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) { return false; }
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) { return false; } // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) { return false; }
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) { return false; }
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) { return false; }
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) { return false; }
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) { list.steiner = true; }
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) { return p; }
                    if (hy === p.next.y) { return p.next; }
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) { return null; }

    if (hx === qx) { return m.prev; } // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) { p.z = zOrder(p.x, p.y, minX, minY, invSize); }
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) { break; }
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) { tail.nextZ = e; }
                else { list = e; }

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) { leftmost = p; }
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) { return true; }
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) { return true; }
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            { inside = !inside; }
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) { p.prevZ.nextZ = p.nextZ; }
    if (p.nextZ) { p.nextZ.prevZ = p.prevZ; }
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea$2(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea$2(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea$2(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) { result.vertices.push(data[i][j][d]); }
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};
earcut_1.default = default_1;

var FillBuffer = /*@__PURE__*/(function (BufferBase) {
  function FillBuffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) FillBuffer.__proto__ = BufferBase;
  FillBuffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  FillBuffer.prototype.constructor = FillBuffer;

  FillBuffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    layerData.forEach(function (feature) {
      this$1._calculateFill(feature);
      delete feature.bufferInfo;
    });
  };

  FillBuffer.prototype._calculateFill = function _calculateFill (feature) {
    var ref = feature.bufferInfo;
    var indexArray = ref.indexArray;
    var vertices = ref.vertices;
    var indexOffset = ref.indexOffset;
    var verticesOffset = ref.verticesOffset;
    var pointCount = vertices.length / 3;
    this._encodeArray(feature, vertices.length / 3);
    // 添加顶点
    for (var i = 0; i < pointCount; i++) {
      this.attributes.positions.set([ vertices[ i * 3 ], vertices[i * 3 + 1 ], 0 ], (verticesOffset + i) * 3);
      if (this.get('uv')) {
        // TODO 用过BBox计算纹理坐标
        this.attributes.uv.set([ 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0 ], (verticesOffset + i) * 3);
      }
    }
    feature.bufferInfo.verticesOffset += pointCount;
    // 添加顶点索引
    this.indexArray.set(indexArray, indexOffset); // 顶部坐标
    feature.bufferInfo.indexOffset += indexArray.length;
  };

  FillBuffer.prototype._calculateFeatures = function _calculateFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    // 计算长
    layerData.forEach(function (feature) {
      var coordinates = feature.coordinates;
      var bufferInfo = {};
      var flattengeo = earcut_1.flatten(coordinates);
      var vertices = flattengeo.vertices;
      var dimensions = flattengeo.dimensions;
      var holes = flattengeo.holes;
      var indexArray = earcut_1(vertices, holes, dimensions).map(function (v) { return this$1.verticesCount + v; });
      bufferInfo.vertices = vertices;
      bufferInfo.indexArray = indexArray;
      bufferInfo.verticesOffset = this$1.verticesCount + 0;
      bufferInfo.indexOffset = this$1.indexCount + 0;
      this$1.indexCount += indexArray.length;
      this$1.verticesCount += vertices.length / 3;
      feature.bufferInfo = bufferInfo;

    });
  };

  return FillBuffer;
}(BufferBase));

var LineBuffer = /*@__PURE__*/(function (BufferBase) {
  function LineBuffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) LineBuffer.__proto__ = BufferBase;
  LineBuffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  LineBuffer.prototype.constructor = LineBuffer;

  LineBuffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    var offsetVertices = 0;
    var offsetIndex = 0;
    var offset = 0;
    layerData.forEach(function (feature) {
      var coordinates = feature.coordinates;
      coordinates.forEach(function (coord) {
        var n = coord.length;
        feature.bufferInfo = {
          verticesOffset: offsetVertices
        };
        this$1._encodeArray(feature, n);
        for (var i = 0; i < n; i++) {
          this$1.attributes.positions[offsetVertices * 3] = coord[i][0];
          this$1.attributes.positions[offsetVertices * 3 + 1] = coord[i][1];
          this$1.attributes.positions[offsetVertices * 3 + 2] = coord[i][2];
          this$1.indexArray[offsetIndex * 2] = i + offset;
          this$1.indexArray[offsetIndex * 2 + 1] = i + offset + 1;
          if (i === n - 1) {
            this$1.indexArray[offsetIndex * 2 + 1] = offsetVertices - n + 1;
          }
          offsetVertices++;
          offsetIndex++;
        }
        offset += n;
      });
    });
  };

  LineBuffer.prototype._calculateBufferLength = function _calculateBufferLength () {
    var this$1 = this;

    var layerData = this.get('layerData');
    layerData.forEach(function (feature) {
      var coordinates = feature.coordinates;
      coordinates.forEach(function (coord) {
        this$1.verticesCount += coord.length;
        this$1.indexCount += (coord.length * 2 - 2);
      });
    });
  };

  LineBuffer.prototype._calculateFeatures = function _calculateFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    layerData.forEach(function (feature) {
      var coordinates = feature.coordinates;
      coordinates.forEach(function (coord) {
        this$1.verticesCount += coord.length;
        this$1.indexCount += (coord.length * 2);
      });
    });
  };
  LineBuffer.prototype._calculateLine = function _calculateLine (feature) {
    var this$1 = this;

    var ref = feature.bufferInfo;
    var indexOffset = ref.indexOffset;
    var verticesOffset = ref.verticesOffset;
    feature.coordinates.forEach(function (coord) {
      var n = coord.length;
      this$1._encodeArray(feature, n);
      for (var i = 0; i < n; i++) {
        this$1.attributes.positions[(verticesOffset + i) * 3] = coord[i][0];
        this$1.attributes.positions[(verticesOffset + i) * 3 + 1] = coord[i][1];
        this$1.attributes.positions[(verticesOffset + i) * 3 + 2] = coord[i][2];
        this$1.indexArray[(indexOffset + i) * 2] = i + verticesOffset * 2;
        this$1.indexArray[(indexOffset + i) * 2 + 1] = i + verticesOffset * 2 + 1;
        if (i === n - 1) {
          this$1.indexArray[(indexOffset + i) * 2 + 1] = verticesOffset + 1;
        }

      }
      verticesOffset += n;
      indexOffset += n;
    });
  };

  return LineBuffer;
}(BufferBase));

var ExtrudeButffer = /*@__PURE__*/(function (BufferBase) {
  function ExtrudeButffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) ExtrudeButffer.__proto__ = BufferBase;
  ExtrudeButffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  ExtrudeButffer.prototype.constructor = ExtrudeButffer;

  ExtrudeButffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    layerData.forEach(function (feature) {
      this$1._calculateTop(feature);
      this$1._calculateWall(feature);
      delete feature.bufferInfo;
    });
  };

  ExtrudeButffer.prototype._calculateFeatures = function _calculateFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    // 计算长
    layerData.forEach(function (feature) {
      var coordinates = feature.coordinates;
      var bufferInfo = {};
      var flattengeo = earcut_1.flatten(coordinates);
      var n = this$1.checkIsClosed(coordinates[0]) ? coordinates[0].length - 1 : coordinates[0].length;
      var vertices = flattengeo.vertices;
      var dimensions = flattengeo.dimensions;
      var holes = flattengeo.holes;
      var indexArray = earcut_1(vertices, holes, dimensions).map(function (v) { return this$1.verticesCount + v; });
      bufferInfo.vertices = vertices;
      bufferInfo.indexArray = indexArray;
      bufferInfo.verticesOffset = this$1.verticesCount + 0;
      bufferInfo.indexOffset = this$1.indexCount + 0;
      bufferInfo.faceNum = n;
      this$1.indexCount += indexArray.length + n * 6;
      this$1.verticesCount += vertices.length / 3 + n * 4;
      feature.bufferInfo = bufferInfo;

    });
  };
  ExtrudeButffer.prototype._calculateTop = function _calculateTop (feature) {
    var size = feature.size;
    var ref = feature.bufferInfo;
    var indexArray = ref.indexArray;
    var vertices = ref.vertices;
    var indexOffset = ref.indexOffset;
    var verticesOffset = ref.verticesOffset;
    var pointCount = vertices.length / 3;
    this._encodeArray(feature, vertices.length / 3);
    // 添加顶点
    for (var i = 0; i < pointCount; i++) {
      this.attributes.positions.set([ vertices[ i * 3 ], vertices[i * 3 + 1 ], size ], (verticesOffset + i) * 3);
      // 顶部文理坐标计算
      if (this.get('uv')) {
        // TODO 用过BBox计算纹理坐标
        this.attributes.uv.set([ -1, -1 ], (verticesOffset + i) * 2);
      }
    }
    feature.bufferInfo.verticesOffset += pointCount;
    // 添加顶点索引
    this.indexArray.set(indexArray, indexOffset); // 顶部坐标
    feature.bufferInfo.indexOffset += indexArray.length;

  };

  return ExtrudeButffer;
}(BufferBase));

function fillPolygon(points) {
  var flattengeo = earcut_1.flatten(points);
  var triangles = earcut_1(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  return {
    positions: flattengeo.vertices,
    indexArray: triangles
  };
}

function extrude_Polygon(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    points[0] = points[0].slice(0, points[0].length - 1);
  }
  var n = points[0].length;
  var flattengeo = earcut_1.flatten(points);
  var positions = [];
  var indexArray = [];
  var normals = [];
  // 设置顶部z值
  for (var j = 0; j < flattengeo.vertices.length / 3; j++) {
    flattengeo.vertices[j * 3 + 2] = 1;
    normals.push(0, 0, 1);
  }
  positions.push.apply(positions, flattengeo.vertices);
  var triangles = earcut_1(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push.apply(indexArray, triangles);
  var loop = function ( i ) {
    var prePoint = flattengeo.vertices.slice(i * 3, i * 3 + 3);
    var nextPoint = flattengeo.vertices.slice(i * 3 + 3, i * 3 + 6);
    nextPoint.length === 0 && (nextPoint = flattengeo.vertices.slice(0, 3));
    var indexOffset = positions.length / 3;
    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);
    var normal = computeNormal([ nextPoint[0], nextPoint[1], 1 ], [ prePoint[0], prePoint[1], 0 ], [ prePoint[0], prePoint[1], 1 ]);
    normals.push.apply(normals, normal.concat( normal, normal, normal ));
    indexArray.push.apply(indexArray, [ 1, 2, 0, 3, 2, 1 ].map(function (v) { return v + indexOffset; }));
  };

  for (var i = 0; i < n; i++) loop( i );
  return {
    positions: positions,
    indexArray: indexArray,
    normals: normals
  };
}

function computeNormal(v1, v2, v3) {
  var pA = new Vector3();
  var pB = new Vector3();
  var pC = new Vector3();
  var cb = new Vector3();
  var ab = new Vector3();
  pA.set.apply(pA, v1);
  pB.set.apply(pB, v2);
  pC.set.apply(pC, v3);
  cb.subVectors(pC, pB);
  ab.subVectors(pA, pB);
  cb.cross(ab);
  cb.normalize();
  var x = cb.x;
  var y = cb.y;
  var z = cb.z;
  return [ x, y, z ];
}

/**
 * @author lzxue
 * @email lzx199065@gmail.com
 * @create date 2018-11-28 11:01:33
 * @modify date 2018-11-28 11:01:33
 * @desc 点,线,面 coordinates
*/

function circle() {
  return polygonPath(30);
}
function square() {
  return polygonPath(4);
}
function triangle() {
  return polygonPath(3);
}
function hexagon() {
  return polygonPath(6, 1);
}

function polygonPath(pointCount, start) {
  if ( start === void 0 ) start = 0;

  var step = Math.PI * 2 / pointCount;
  var line = [];
  for (var i = 0; i < pointCount; i++) {
    line.push(step * i + start * Math.PI / 12);
  }
  var path = line.map(function (t) {
    var x = Math.sin(t + Math.PI / 4),
      y = Math.cos(t + Math.PI / 4);
    return [ x, y, 0 ];
  });
  path.push(path[0]);
  return path;
}

var polygonPath$1 = /*#__PURE__*/Object.freeze({
circle: circle,
square: square,
triangle: triangle,
hexagon: hexagon,
cylinder: circle,
triangleColumn: triangle,
hexagonColumn: hexagon,
squareColumn: square,
polygonPath: polygonPath
});

var pointShape = Global.pointShape;
var PointFillBuffer = /*@__PURE__*/(function (BufferBase) {
  function PointFillBuffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) PointFillBuffer.__proto__ = BufferBase;
  PointFillBuffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  PointFillBuffer.prototype.constructor = PointFillBuffer;

  PointFillBuffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    this._offset = 0;
    this._indexOffset = 0;

    layerData.forEach(function (feature) {
      this$1._calculateFill(feature);
    });
  };
  PointFillBuffer.prototype._initAttributes = function _initAttributes () {
    BufferBase.prototype._initAttributes.call(this);
    this.attributes.miters = new Float32Array(this.verticesCount * 2);
    this.attributes.sizes = new Float32Array(this.verticesCount);
    this.attributes.shapes = new Float32Array(this.verticesCount);
  };
  PointFillBuffer.prototype._calculateFeatures = function _calculateFeatures () {
    var layerData = this.get('layerData');
    this.verticesCount = layerData.length * 4;
    this.indexCount = layerData.length * 6;
  };
  PointFillBuffer.prototype._calcultateGeometry = function _calcultateGeometry () {
    var shape = this.get('shapeType');
    var hexgonFill = this.getShapeFunction(shape)([ this._getPoints(6) ]);
    this.instanceGeometry = hexgonFill;
  };
  PointFillBuffer.prototype._calculateFill = function _calculateFill (feature) {
    var this$1 = this;


    feature.bufferInfo = { verticesOffset: this._offset };
    var coordinates = feature.coordinates;
    var shape = feature.shape;
    var shapeIndex = pointShape['2d'].indexOf(shape) || 0;
    var newCoord = coordinates;
    if (coordinates.length === 1) {
      newCoord = coordinates[0][0];
    }
    feature.bufferInfo = {
      verticesOffset: this._offset
    };
    this._encodeArray(feature, 4);
    this.attributes.shapes.set([ shapeIndex, shapeIndex, shapeIndex, shapeIndex ], this._offset);
    this.attributes.miters.set([ -1, -1, 1, -1, 1, 1, -1, 1 ], this._offset * 2);
    var indexArray = [ 0, 1, 2, 0, 2, 3 ].map(function (n) { return n + this$1._offset; });
    this.indexArray.set(indexArray, this._offset * 1.5);

    var position = [];
    for (var i = 0; i < 4; i++) {
      position.push.apply(position, newCoord);
    }
    this.attributes.positions.set(position, this._offset * 3);
    this._offset += 4;
  };
  PointFillBuffer.prototype._getPoints = function _getPoints (num) {
    return polygonPath(num, 1);
  };
  PointFillBuffer.prototype.getShape = function getShape (shape) {
    var pointShape = Global.pointShape;

    if (this.geometryMap[shape]) {
      return this.geometryMap[shape];
    }
    var geometry = null;
    if (pointShape['3d'].indexOf(shape) !== -1) {
      geometry = extrude_Polygon([ polygonPath$1[shape]() ]);
    } else if (pointShape['2d'].indexOf(shape) !== -1) {
      geometry = fillPolygon([ polygonPath$1[shape]() ]);
    } else {
      geometry = fillPolygon([ polygonPath$1[shape]() ]);
    }
    this.geometryMap[shape] = geometry;
    return geometry;
  };

  return PointFillBuffer;
}(BufferBase));

var add_1 = add;

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out
}

var set_1 = set$1;

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set$1(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out
}

var normalize_1 = normalize;

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out
}

var subtract_1 = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out
}

var dot_1 = dot;

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1]
}

var tmp = [0, 0];

var computeMiter = function computeMiter(tangent, miter, lineA, lineB, halfThick) {
    //get tangent line
    add_1(tangent, lineA, lineB);
    normalize_1(tangent, tangent);

    //get miter as a unit vector
    set_1(miter, -tangent[1], tangent[0]);
    set_1(tmp, -lineA[1], lineA[0]);

    //get the necessary length of our miter
    return halfThick / dot_1(miter, tmp)
};

var normal = function normal(out, dir) {
    //get perpendicular
    set_1(out, -dir[1], dir[0]);
    return out
};

var direction = function direction(out, a, b) {
    //get unit dir of two lines
    subtract_1(out, a, b);
    normalize_1(out, out);
    return out
};

var epsilon = 0.000001;

var create_1 = create;

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
    var out = new Float32Array(2);
    out[0] = 0;
    out[1] = 0;
    return out
}

var clone_1$1 = clone;

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
    var out = new Float32Array(2);
    out[0] = a[0];
    out[1] = a[1];
    return out
}

var fromValues_1 = fromValues;

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
    var out = new Float32Array(2);
    out[0] = x;
    out[1] = y;
    return out
}

var copy_1 = copy;

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out
}

var equals_1 = equals$1;



/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals$1(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return (Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)))
}

var exactEquals_1 = exactEquals;

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1]
}

var sub = subtract_1;

var multiply_1 = multiply;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out
}

var mul = multiply_1;

var divide_1 = divide;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out
}

var div = divide_1;

var inverse_1 = inverse;

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out
}

var min_1 = min$1;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min$1(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out
}

var max_1 = max$1;

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max$1(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out
}

var rotate_1 = rotate;

/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */
function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];

  out[0] = x * c - y * s;
  out[1] = x * s + y * c;

  return out
}

var floor_1 = floor;

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out
}

var ceil_1 = ceil;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out
}

var round_1 = round;

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out
}

var scale_1 = scale;

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out
}

var scaleAndAdd_1 = scaleAndAdd;

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out
}

var distance_1 = distance;

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y)
}

var dist = distance_1;

var squaredDistance_1 = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y
}

var sqrDist = squaredDistance_1;

var length_1 = length;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y)
}

var len = length_1;

var squaredLength_1 = squaredLength;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y
}

var sqrLen = squaredLength_1;

var negate_1 = negate;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out
}

var cross_1 = cross;

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out
}

var lerp_1 = lerp;

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out
}

var random_1 = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
    scale = scale || 1.0;
    var r = Math.random() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out
}

var transformMat2_1 = transformMat2;

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out
}

var transformMat2d_1 = transformMat2d;

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out
}

var transformMat3_1 = transformMat3;

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out
}

var transformMat4_1 = transformMat4;

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out
}

var forEach_1 = forEach;

var vec = create_1();

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach(a, stride, offset, count, fn, arg) {
    var i, l;
    if(!stride) {
        stride = 2;
    }

    if(!offset) {
        offset = 0;
    }
    
    if(count) {
        l = Math.min((count * stride) + offset, a.length);
    } else {
        l = a.length;
    }

    for(i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i+1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i+1] = vec[1];
    }
    
    return a
}

var limit_1 = limit;

/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */
function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

var _glVec2_1_3_0_glVec2 = {
  EPSILON: epsilon
  , create: create_1
  , clone: clone_1$1
  , fromValues: fromValues_1
  , copy: copy_1
  , set: set_1
  , equals: equals_1
  , exactEquals: exactEquals_1
  , add: add_1
  , subtract: subtract_1
  , sub: sub
  , multiply: multiply_1
  , mul: mul
  , divide: divide_1
  , div: div
  , inverse: inverse_1
  , min: min_1
  , max: max_1
  , rotate: rotate_1
  , floor: floor_1
  , ceil: ceil_1
  , round: round_1
  , scale: scale_1
  , scaleAndAdd: scaleAndAdd_1
  , distance: distance_1
  , dist: dist
  , squaredDistance: squaredDistance_1
  , sqrDist: sqrDist
  , length: length_1
  , len: len
  , squaredLength: squaredLength_1
  , sqrLen: sqrLen
  , negate: negate_1
  , normalize: normalize_1
  , dot: dot_1
  , cross: cross_1
  , lerp: lerp_1
  , random: random_1
  , transformMat2: transformMat2_1
  , transformMat2d: transformMat2d_1
  , transformMat3: transformMat3_1
  , transformMat4: transformMat4_1
  , forEach: forEach_1
  , limit: limit_1
};
var _glVec2_1_3_0_glVec2_2 = _glVec2_1_3_0_glVec2.create;
var _glVec2_1_3_0_glVec2_5 = _glVec2_1_3_0_glVec2.copy;
var _glVec2_1_3_0_glVec2_35 = _glVec2_1_3_0_glVec2.dot;

/**
 * 对于 polyline-normal 的改进
 * 超过阈值，miter 转成 bevel 接头，
 * 要注意 Three.js 中默认 THREE.FrontFaceDirectionCCW
 * @see https://zhuanlan.zhihu.com/p/59541559
 */

function extrusions(positions, out, miters, point, normal, scale) {
  addNext(out, miters, normal, -scale);
  addNext(out, miters, normal, scale);
  positions.push.apply(positions, point);
  positions.push.apply(positions, point);
}

function addNext(out, miters, normal, length) {
  out.push(normal[0], normal[1], 0);
  miters.push(length);
}

function lineSegmentDistance(end, start) {
  var dx = start[0] - end[0];
  var dy = start[1] - end[1];
  var dz = start[2] - end[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function getNormals(points, closed, indexOffset) {
  var lineA = [ 0, 0 ];
  var lineB = [ 0, 0 ];
  var tangent = [ 0, 0 ];
  var miter = [ 0, 0 ];
  var _started = false;
  var _normal = null;
  var tmp = _glVec2_1_3_0_glVec2_2();
  var count = indexOffset || 0;
  var miterLimit = 3;

  var out = [];
  var attrPos = [];
  var attrIndex = [];
  var miters = [];
  var attrDistance = [ 0, 0 ];
  if (closed) {
    points = points.slice();
    points.push(points[0]);
  }

  var total = points.length;

  for (var i = 1; i < total; i++) {
    var index = count;
    var last = points[i - 1];
    var cur = points[i];
    var next = i < points.length - 1 ? points[i + 1] : null;
    // 如果当前点和前一点相同，跳过
    if (isPointEqual(last, cur)) {
      continue;
    }
    if (next) {
      var nextIndex = i + 1;
      // 找到不相同的下一点
      while (next && isPointEqual(cur, next)) {
        next = nextIndex < points.length - 1 ? points[++nextIndex] : null;
      }
    }
    var lineDistance = lineSegmentDistance(cur, last);
    var d = lineDistance + attrDistance[attrDistance.length - 1];

    direction(lineA, cur, last);

    if (!_normal) {
      _normal = [ 0, 0 ];
      normal(_normal, lineA);
    }

    if (!_started) {
      _started = true;
      extrusions(attrPos, out, miters, last, _normal, 1);
    }

    attrIndex.push(index + 0, index + 2, index + 1);

    // no miter, simple segment
    if (!next) {
      // reset normal
      normal(_normal, lineA);
      extrusions(attrPos, out, miters, cur, _normal, 1);
      attrDistance.push(d, d);
      attrIndex.push(index + 1, index + 2, index + 3);
      count += 2;
    } else {
      // get unit dir of next line
      direction(lineB, next, cur);

      // stores tangent & miter
      var miterLen = computeMiter(tangent, miter, lineA, lineB, 1);

      // get orientation
      var flip = (_glVec2_1_3_0_glVec2_35(tangent, _normal) < 0) ? -1 : 1;
      var bevel = Math.abs(miterLen) > miterLimit;

      // 处理前后两条线段重合的情况，这种情况不需要使用任何接头（miter/bevel）。
      // 理论上这种情况下 miterLen = Infinity，本应通过 isFinite(miterLen) 判断，
      // 但是 AMap 投影变换后丢失精度，只能通过一个阈值（1000）判断。
      if (Math.abs(miterLen) > 1000) {
        extrusions(attrPos, out, miters, cur, _normal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        attrIndex.push(index + 2, index + 4, index + 3);
        normal(tmp, lineB);
        _glVec2_1_3_0_glVec2_5(_normal, tmp); // store normal for next round

        extrusions(attrPos, out, miters, cur, _normal, 1);
        attrDistance.push(d, d, d, d);

        // the miter is now the normal for our next join
        count += 4;
        continue;
      }

      if (bevel) {
        miterLen = miterLimit;

        // next two points in our first segment
        extrusions(attrPos, out, miters, cur, _normal, 1);

        attrIndex.push(index + 1, index + 2, index + 3);

        // now add the bevel triangle
        attrIndex.push.apply(attrIndex, (flip === 1 ? [ index + 2, index + 4, index + 5 ] : [ index + 4, index + 5, index + 3 ]));

        normal(tmp, lineB);
        _glVec2_1_3_0_glVec2_5(_normal, tmp); // store normal for next round

        extrusions(attrPos, out, miters, cur, _normal, 1);
        attrDistance.push(d, d, d, d);

        // the miter is now the normal for our next join
        count += 4;
      } else {
        // next two points in our first segment
        extrusions(attrPos, out, miters, cur, _normal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);

        // now add the miter triangles
        addNext(out, miters, miter, miterLen * -flip);
        attrPos.push.apply(attrPos, cur);
        attrIndex.push(index + 2, index + 4, index + 3);
        attrIndex.push(index + 4, index + 5, index + 6);
        normal(tmp, lineB);
        _glVec2_1_3_0_glVec2_5(_normal, tmp); // store normal for next round

        extrusions(attrPos, out, miters, cur, _normal, 1);
        attrDistance.push(d, d, d, d, d);

        // the miter is now the normal for our next join
        count += 5;
      }
    }
  }

  return {
    normals: out,
    attrIndex: attrIndex,
    attrPos: attrPos,
    attrDistance: attrDistance,
    miters: miters
  };
}

var MeshLineBuffer = /*@__PURE__*/(function (BufferBase) {
  function MeshLineBuffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) MeshLineBuffer.__proto__ = BufferBase;
  MeshLineBuffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  MeshLineBuffer.prototype.constructor = MeshLineBuffer;

  MeshLineBuffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    layerData.forEach(function (feature) {
      this$1._calculateLine(feature);
      delete feature.bufferInfo;
    });
    this.hasPattern = layerData.some(function (layer) {
      return layer.pattern;
    });
  };
  MeshLineBuffer.prototype._initAttributes = function _initAttributes () {
    BufferBase.prototype._initAttributes.call(this);
    this.attributes.dashArray = new Float32Array(this.verticesCount);
    this.attributes.attrDistance = new Float32Array(this.verticesCount);
    this.attributes.totalDistances = new Float32Array(this.verticesCount);
    this.attributes.patterns = new Float32Array(this.verticesCount * 2);
    this.attributes.miters = new Float32Array(this.verticesCount);
    this.attributes.normals = new Float32Array(this.verticesCount * 3);
  };
  MeshLineBuffer.prototype._calculateFeatures = function _calculateFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    // 计算长
    layerData.forEach(function (feature) {
      var bufferInfo = {};
      var coordinates = feature.coordinates;
      if (Array.isArray(coordinates[0][0])) {
        coordinates = coordinates[0];
      }
      var ref = getNormals(coordinates, false, this$1.verticesCount);
      var normals = ref.normals;
      var attrIndex = ref.attrIndex;
      var attrPos = ref.attrPos;
      var attrDistance = ref.attrDistance;
      var miters = ref.miters;
      bufferInfo.normals = normals;
      bufferInfo.arrayIndex = attrIndex;
      bufferInfo.positions = attrPos;
      bufferInfo.attrDistance = attrDistance;
      bufferInfo.miters = miters;
      bufferInfo.verticesOffset = this$1.verticesCount;
      bufferInfo.indexOffset = this$1.indexCount;
      this$1.verticesCount += attrPos.length / 3;
      this$1.indexCount += attrIndex.length;
      feature.bufferInfo = bufferInfo;
    });
  };
  MeshLineBuffer.prototype._calculateLine = function _calculateLine (feature) {
    var ref = feature.bufferInfo;
    var normals = ref.normals;
    var arrayIndex = ref.arrayIndex;
    var positions = ref.positions;
    var attrDistance = ref.attrDistance;
    var miters = ref.miters;
    var verticesOffset = ref.verticesOffset;
    var indexOffset = ref.indexOffset;
    var ref$1 = this.get('style');
    var dashArray = ref$1.dashArray; if ( dashArray === void 0 ) dashArray = 200;

    this._encodeArray(feature, positions.length / 3);
    var totalLength = attrDistance[attrDistance.length - 1];
    // 增加长度
    var totalDistances = Array(positions.length / 3).fill(totalLength);
    // 虚线比例
    var ratio = dashArray / totalLength;
    var dashArrays = Array(positions.length / 3).fill(ratio);
    this.attributes.positions.set(positions, verticesOffset * 3);
    this.indexArray.set(arrayIndex, indexOffset);
    this.attributes.miters.set(miters, verticesOffset);
    this.attributes.normals.set(normals, verticesOffset * 3);
    this.attributes.attrDistance.set(attrDistance, verticesOffset);
    this.attributes.totalDistances.set(totalDistances, verticesOffset);
    this.attributes.dashArray.set(dashArrays, verticesOffset);
  };

  return MeshLineBuffer;
}(BufferBase));

var ArcLineBuffer = /*@__PURE__*/(function (BufferBase) {
  function ArcLineBuffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) ArcLineBuffer.__proto__ = BufferBase;
  ArcLineBuffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  ArcLineBuffer.prototype.constructor = ArcLineBuffer;

  ArcLineBuffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    layerData.forEach(function (feature, index) {
      this$1._calculateArc(feature, index);
    });
    this.hasPattern = layerData.some(function (layer) {
      return layer.pattern;
    });
  };
  ArcLineBuffer.prototype._initAttributes = function _initAttributes () {
    BufferBase.prototype._initAttributes.call(this);
    this.attributes.instanceArray = new Float32Array(this.verticesCount * 4);
  };
  ArcLineBuffer.prototype._calculateArc = function _calculateArc (feature, offset) {
    var this$1 = this;

    var ref = this.get('style');
    var segNum = ref.segNum; if ( segNum === void 0 ) segNum = 30;
    var coordinates = feature.coordinates;
    var loop = function ( i ) {
      this$1.attributes.positions.set([ i, 1, i, i, -1, i ], offset * segNum * 6 + i * 6);
      this$1.attributes.instanceArray.set([ coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1],
        coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1] ], offset * segNum * 8 + i * 8);
      if (i !== segNum - 1) {
        var indexArray = [ 0, 1, 2, 1, 3, 2 ].map(function (v) { return offset * segNum * 2 + i * 2 + v; });
        this$1.indexArray.set(indexArray, offset * segNum * 6 + i * 6 - offset * 6);
      }
    };

    for (var i = 0; i < segNum; i++) loop( i );
    feature.bufferInfo = { verticesOffset: offset * segNum * 2 };
    this._encodeArray(feature, segNum * 2);

  };
  ArcLineBuffer.prototype._calculateFeatures = function _calculateFeatures () {
    var layerData = this.get('layerData');
    var segNum = this.get('segNum') || 30;
    this.verticesCount = layerData.length * segNum * 2;
    this.indexCount = this.verticesCount * 3 - layerData.length * 6;
  };

  return ArcLineBuffer;
}(BufferBase));

/**
 * instantcebufferGeometry的组装方式
 */

var Hexagon3D = /*@__PURE__*/(function (BufferBase) {
  function Hexagon3D () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) Hexagon3D.__proto__ = BufferBase;
  Hexagon3D.prototype = Object.create( BufferBase && BufferBase.prototype );
  Hexagon3D.prototype.constructor = Hexagon3D;

  Hexagon3D.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    this._offset = 0;

    layerData.forEach(function (feature) {
      this$1._calculateFill(feature);
    });
  };
  Hexagon3D.prototype._calculateFeatures = function _calculateFeatures () {
    var shape = this.get('shapeType');
    var hexgonFill = this.getShape(shape);
    var layerData = this.get('layerData');
    this.verticesCount = layerData.length;
    this.indexCount = 0;
    this.instanceGeometry = hexgonFill;
  };
  Hexagon3D.prototype._calculateFill = function _calculateFill (feature) {

    feature.bufferInfo = { verticesOffset: this._offset };
    var coordinates = feature.coordinates;
    this._encodeArray(feature, 1);
    this.attributes.positions.set(coordinates, this._offset * 3);
    this._offset++;
  };
  Hexagon3D.prototype.getShape = function getShape (shape) {
    var pointShape = Global.pointShape;
    if (pointShape['3d'].indexOf(shape) !== -1) { return extrude_Polygon([ polygonPath$1[shape]() ]); }
    if (pointShape['2d'].indexOf(shape) !== -1) { return fillPolygon([ polygonPath$1[shape]() ]); }
    return fillPolygon([ polygonPath$1[shape]() ]);
  };

  return Hexagon3D;
}(BufferBase));

/**
 * bufferGeometry的顶点组装方式
 */
var ExtrudeBuffer = /*@__PURE__*/(function (BufferBase) {
  function ExtrudeBuffer () {
    BufferBase.apply(this, arguments);
  }

  if ( BufferBase ) ExtrudeBuffer.__proto__ = BufferBase;
  ExtrudeBuffer.prototype = Object.create( BufferBase && BufferBase.prototype );
  ExtrudeBuffer.prototype.constructor = ExtrudeBuffer;

  ExtrudeBuffer.prototype._buildFeatures = function _buildFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    this._offset = 0;
    this._indexOffset = 0;

    layerData.forEach(function (feature) {
      this$1._calculateFill(feature);
    });
  };
  ExtrudeBuffer.prototype._initAttributes = function _initAttributes () {
    BufferBase.prototype._initAttributes.call(this);
    this.attributes.miters = new Float32Array(this.verticesCount * 3);
    this.attributes.normals = new Float32Array(this.verticesCount * 3);
    this.attributes.sizes = new Float32Array(this.verticesCount * 3);
  };
  ExtrudeBuffer.prototype._calculateFeatures = function _calculateFeatures () {
    var this$1 = this;

    var layerData = this.get('layerData');
    this.geometryMap = {};
    layerData.forEach(function (feature) {
      var shape = feature.shape;
      var ref = this$1.getShape(shape);
      var positions = ref.positions;
      var indexArray = ref.indexArray;
      this$1.verticesCount += positions.length / 3;
      this$1.indexCount += indexArray.length;
    });
  };
  ExtrudeBuffer.prototype._calcultateGeometry = function _calcultateGeometry () {
    var shape = this.get('shapeType');
    var hexgonFill = this.getShapeFunction(shape)([ this._getPoints(6) ]);
    this.instanceGeometry = hexgonFill;
  };
  ExtrudeBuffer.prototype._calculateFill = function _calculateFill (feature) {
    var this$1 = this;


    feature.bufferInfo = { verticesOffset: this._offset };
    var coordinates = feature.coordinates;
    var shape = feature.shape;
    var instanceGeometry = this.getShape(shape);
    var numPoint = instanceGeometry.positions.length / 3;
    this._encodeArray(feature, numPoint);
    this.attributes.miters.set(instanceGeometry.positions, this._offset * 3);
    var indexArray = instanceGeometry.indexArray.map(function (v) { return v + this$1._offset; });
    this.indexArray.set(indexArray, this._indexOffset);
    if (instanceGeometry.normals) {
      this.attributes.normals.set(instanceGeometry.normals, this._offset * 3);
    }
    var position = [];
    for (var i = 0; i < numPoint; i++) {
      position.push.apply(position, coordinates);
    }
    this.attributes.positions.set(position, this._offset * 3);
    this._offset += numPoint;
    this._indexOffset += indexArray.length;
  };
  ExtrudeBuffer.prototype._getPoints = function _getPoints (num) {
    return polygonPath(num, 1);
  };
  ExtrudeBuffer.prototype.getShape = function getShape (shape) {
    var pointShape = Global.pointShape;

    if (this.geometryMap[shape]) {
      return this.geometryMap[shape];
    }
    var geometry = null;
    if (pointShape['3d'].indexOf(shape) !== -1) {
      geometry = extrude_Polygon([ polygonPath$1[shape]() ]);
    } else if (pointShape['2d'].indexOf(shape) !== -1) {
      geometry = fillPolygon([ polygonPath$1[shape]() ]);
    } else {
      geometry = fillPolygon([ polygonPath$1[shape]() ]);
    }
    this.geometryMap[shape] = geometry;
    return geometry;
  };

  return ExtrudeBuffer;
}(BufferBase));

var Buffer_MAP = {};
var getBuffer = function (bufferType, shapeType) {
  return Buffer_MAP[bufferType.toLowerCase()] && Buffer_MAP[bufferType.toLowerCase()][shapeType.toLowerCase()];
};
var registerBuffer = function (bufferType, shapeType, render) {
  if (getBuffer(bufferType, shapeType)) {
    throw new Error(("Render shapeType '" + shapeType + "' existed."));
  }
  // 存储到 map 中
  if (!Buffer_MAP[bufferType.toLowerCase()]) { Buffer_MAP[bufferType.toLowerCase()] = {}; }
  Buffer_MAP[bufferType.toLowerCase()][shapeType.toLowerCase()] = render;
};

// Point
registerBuffer('point', 'fill', PointFillBuffer);

// polygon
registerBuffer('polygon', 'fill', FillBuffer);
registerBuffer('polygon', 'extrude', ExtrudeButffer);
registerBuffer('polygon', 'line', LineBuffer);

// line
registerBuffer('line', 'line', MeshLineBuffer);
registerBuffer('line', 'arc', ArcLineBuffer);
registerBuffer('line', 'greatCircle', ArcLineBuffer);

// heatmap

// registerBuffer('heatmap', 'square', Grid3D);
// registerBuffer('heatmap', 'squareColumn', Grid3D);
registerBuffer('heatmap', 'shape', Hexagon3D);
registerBuffer('point', 'shape', Hexagon3D);
// 3D Shape

registerBuffer('shape', 'extrude', ExtrudeBuffer);

function serialize(input, transferables) {
  if (input === null ||
    input === undefined ||
    typeof input === 'boolean' ||
    typeof input === 'number' ||
    typeof input === 'string' ||
    input instanceof Boolean ||
    input instanceof Number ||
    input instanceof String ||
    input instanceof Date ||
    input instanceof RegExp) {
    return input;
  }
  if (input instanceof ArrayBuffer) {
    if (transferables) {
      transferables.push(input);
    }
    return input;
  }
  if (ArrayBuffer.isView(input)) {
    var view = input;
    if (transferables) {
      transferables.push(view.buffer);
    }
    return view;
  }

  if (input instanceof ImageData) {
    if (transferables) {
      transferables.push(input.data.buffer);
    }
    return input;
  }
  if (Array.isArray(input)) {
    var serialized = [];
    for (var i = 0, list = input; i < list.length; i += 1) {
      var item = list[i];

      serialized.push(serialize(item, transferables));
    }
    return serialized;
  }
  if (typeof input === 'object') {
    var properties = {};
    for (var key in input) {
      if (!input.hasOwnProperty(key)) {
        continue;
      }
      var property = input[key];
      properties[key] = serialize(property, transferables);
    }
    return properties;
  }

}

function bindAll(fns, context) {
  fns.forEach(function (fn) {
    if (!context[fn]) { return; }
    context[fn] = context[fn].bind(context);
  });
}

var Actor = function Actor(target, parent, mapId) {
  this.target = target;
  this.parent = parent;
  this.mapId = mapId;
  this.callbacks = {};
  this.callbackID = 0;
  bindAll([ 'receive' ], this);
  this.target.addEventListener('message', this.receive, false);

};
Actor.prototype.send = function send (type, data, callback, targetMapId) {
    var this$1 = this;

  var id = callback ? ((this.mapId) + "_" + (this.callbackID++)) : null;
  if (callback) { this.callbacks[id] = callback; }
  var buffer = [];
  this.target.postMessage({
    targetMapId: targetMapId,
    sourceMapId: this.mapId,
    type: type,
    id: String(id),
    data: data
  }, buffer);
  if (callback) {
    return {
      cancel: function () { return this$1.target.postMessage({
        targetMapId: targetMapId,
        sourceMapId: this$1.mapId,
        type: '<cancel>',
        id: String(id)
      }); }
    };
  }
};
Actor.prototype.receive = function receive (message) {
    var this$1 = this;

  // TODO 处理中断Worker
  var data = message.data;
  var id = data.id;
  var callback;
  var done = function (err, data) {
    delete this$1.callbacks[id];
    var buffers = [];
    this$1.target.postMessage({ // 发送结果数据
      sourceMapId: this$1.mapId,
      type: '<response>',
      id: String(id),
      error: err ? JSON.stringify(err) : null,
      data: serialize(data, buffers)
    }, buffers);
  };
  if (data.type === '<response>' || data.type === '<cancel>') {
    callback = this.callbacks[data.id];
    delete this.callbacks[data.id];
    if (callback && data.error) {
      callback(data.error);
    } else if (callback) {
      callback(null, data.data);
    }

  } else if (typeof data.id !== 'undefined' && this.parent[data.type]) { // loadTile
    this.parent[data.type](data.sourceMapId, data.data, done);

  } else if (typeof data.id !== 'undefined' && this.parent.getWorkerSource) {
    var keys = data.type.split('.');
    var params = data.data;
    var workerSource = (this.parent).getWorkerSource(data.sourceMapId, keys[0], params.source);
    workerSource[keys[1]](params, done);
  } else {
    this.parent[data.type](data.data);
  }

};
Actor.prototype.remove = function remove () {
  this.target.removeEventListener('message', this.receive, false);
};

exports.Actor = Actor;
exports.AdditiveBlending = AdditiveBlending;
exports.AlphaFormat = AlphaFormat;
exports.Attr = AttributeBase;
exports.Base = Base;
exports.BufferGeometry = BufferGeometry;
exports.CanvasTexture = CanvasTexture;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
exports.Clock = Clock;
exports.Color = Color;
exports.ColorUtil = ColorUtil;
exports.DataTexture = DataTexture;
exports.DoubleSide = DoubleSide;
exports.EventEmitter = EventEmitter;
exports.Float32BufferAttribute = Float32BufferAttribute$1;
exports.FloatType = FloatType;
exports.Global = Global;
exports.Group = Group;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.LineSegments = LineSegments;
exports.LinearFilter = LinearFilter;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
exports.LuminanceFormat = LuminanceFormat;
exports.Matrix4 = Matrix4;
exports.Mesh = Mesh;
exports.NearestFilter = NearestFilter;
exports.NormalBlending = NormalBlending;
exports.Object3D = Object3D;
exports.OrthographicCamera = OrthographicCamera;
exports.PBF = _pbf_3_2_0_pbf;
exports.PerspectiveCamera = PerspectiveCamera;
exports.PlaneBufferGeometry = PlaneBufferGeometry;
exports.Points = Points;
exports.RGBAFormat = RGBAFormat;
exports.ScaleController = ScaleController;
exports.Scene = Scene;
exports.ShaderMaterial = ShaderMaterial;
exports.Source = Source;
exports.THREE = THREE$1;
exports.Texture = Texture;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.UniformsUtils = UniformsUtils;
exports.UnsignedByteType = UnsignedByteType;
exports.Util = Util;
exports.Vector4 = Vector4;
exports.VectorTile = VectorTile$1;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderer = WebGLRenderer;
exports.bindAll = bindAll;
exports.createCommonjsModule = createCommonjsModule$$1;
exports.flatten = flatten$1;
exports.getArrayBuffer = getArrayBuffer;
exports.getBuffer = getBuffer;
exports.getImage = getImage;
exports.getMap = getMap;
exports.getNormals = getNormals;
exports.isString = isString$1;
exports.lib = lib;
exports.lib_29 = lib_29;
exports.lib_3 = lib_3;
exports.lib_51 = lib_51;
exports.lib_73 = lib_73;
exports.lib_87 = lib_87;
exports.lib_91 = lib_91;
exports.merge = merge;
exports.polygonPath = polygonPath$1;
exports.registerParser = registerParser;
exports.registerTransform = registerTransform;
exports.uniq = uniq;
exports.unwrapExports = unwrapExports$$1;

});

define(['./shared'], function (actor) {
var TileMapping = /*@__PURE__*/(function (Base) {
  function TileMapping(source, cfg) {
    Base.call(this, cfg);
    this.source = source;
    this._init();
  }

  if ( Base ) TileMapping.__proto__ = Base;
  TileMapping.prototype = Object.create( Base && Base.prototype );
  TileMapping.prototype.constructor = TileMapping;
  TileMapping.prototype._init = function _init () {
    this._initControllers();
    this._initTileAttrs();
    this._mapping();
  };
  TileMapping.prototype.update = function update () {
    this.set('scales', {});
    this._initTileAttrs();
    this._updateMaping();
  };
  TileMapping.prototype._initControllers = function _initControllers () {
    var scalesOption = this.get('scaleOptions');
    var scaleController = new actor.ScaleController({
      defs: Object.assign({}, scalesOption)
    });
    this.set('scaleController', scaleController);
  };
  TileMapping.prototype._createScale = function _createScale (field) {
    var scales = this.get('scales');
    this._initControllers(); // scale更新
    var scale = scales[field];
    if (!scale) {
      scale = this.createScale(field);
      scales[field] = scale;
    }
    return scale;
  };
  TileMapping.prototype.createScale = function createScale (field) {
    var data = this.source.data.dataArray;
    var scales = this.get('scales');
    var scale = scales[field];
    var scaleController = this.get('scaleController');
    if (!scale) {
      scale = scaleController.createScale(field, data);
      scales[field] = scale;
    }
    return scale;
  };
  // 获取属性映射的值
  TileMapping.prototype._getAttrValues = function _getAttrValues (attr, record) {
    var scales = attr.scales;
    var params = [];
    for (var i = 0; i < scales.length; i++) {
      var scale = scales[i];
      var field = scale.field;
      if (scale.type === 'identity') {
        params.push(scale.value);
      } else {
        params.push(record[field]);
      }
    }
    var indexZoom = params.indexOf('zoom');
    indexZoom !== -1 ? params[indexZoom] = attr.zoom : null;
    var values = attr.mapping.apply(attr, params);
    return values;
  };
  TileMapping.prototype._mapping = function _mapping () {
    var attrs = this.get('attrs');
    var mappedData = [];
    var data = this.source.data.dataArray;
    for (var i = 0; i < data.length; i++) {
      var record = data[i];
      var newRecord = {};
      newRecord.id = data[i]._id;
      for (var k in attrs) {
        if (attrs.hasOwnProperty(k)) {
          var attr = attrs[k];
          var names = attr.names;
          var values = this._getAttrValues(attr, record);
          if (names.length > 1) { // position 之类的生成多个字段的属性
            for (var j = 0; j < values.length; j++) {
              var val = values[j];
              var name = names[j];
              newRecord[name] = (actor.Util.isArray(val) && val.length === 1) ? val[0] : val; // 只有一个值时返回第一个属性值
            }
          } else {
            newRecord[names[0]] = values.length === 1 ? values[0] : values;

          }
        }
      }
      newRecord.coordinates = record.coordinates;
      mappedData.push(newRecord);
    }
    // 通过透明度过滤数据
    if (attrs.hasOwnProperty('filter')) {
      mappedData.forEach(function (item) {
        if (item.filter === false) {
          (item.color[3] = 0);
          item.id = -item.id;
        }
      });
    }
    this.layerData = mappedData;
  };

  TileMapping.prototype._updateMaping = function _updateMaping () {
    var attrs = this.get('attrs');

    var data = this.source.data.dataArray;
    var layerData = this.layerData;
    for (var i = 0; i < data.length; i++) {
      var record = data[i];
      for (var attrName in attrs) {
        if (attrs.hasOwnProperty(attrName) && attrs[attrName].neadUpdate) {
          var attr = attrs[attrName];
          var names = attr.names;
          var values = this._getAttrValues(attr, record);
          if (names.length > 1) { // position 之类的生成多个字段的属性
            for (var j = 0; j < values.length; j++) {
              var val = values[j];
              var name = names[j];
              layerData[i][name] = (actor.Util.isArray(val) && val.length === 1) ? val[0] : val; // 只有一个值时返回第一个属性值
            }
          } else {
            layerData[i][names[0]] = values.length === 1 ? values[0] : values;

          }
          attr.neadUpdate = true;
        }
      }
    }
  };


  TileMapping.prototype._initTileAttrs = function _initTileAttrs () {
    var attrOptions = this.get('attrOptions');
    for (var type in attrOptions) {
      if (attrOptions.hasOwnProperty(type)) {
        this._updateTileAttr(type);
      }
    }
  };
  TileMapping.prototype._updateTileAttr = function _updateTileAttr (type) {
    var self = this;
    var attrs = this.get('attrs');
    var attrOptions = this.get('attrOptions');
    var option = attrOptions[type];
    option.neadUpdate = true;
    var className = actor.Util.upperFirst(type);
    var fields = this._parseFields(option.field);
    var scales = [];
    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      var scale = self._createScale(field);

      if (type === 'color' && actor.Util.isNil(option.values)) { // 设置 color 的默认色值
        option.values = actor.Global.colors;
      }
      scales.push(scale);
    }
    option.scales = scales;
    var attr = new actor.Attr[className](option);
    attrs[type] = attr;
  };
  TileMapping.prototype._parseFields = function _parseFields (field) {
    if (actor.Util.isArray(field)) {
      return field;
    }
    if (actor.Util.isString(field)) {
      return field.split('*');
    }
    return [ field ];
  };

  return TileMapping;
}(actor.Base));

var pointShape = actor.Global.pointShape;

var WorkerTile = function WorkerTile(params) {
  this.tileID = params.id;
  this.source = params.sourceID;
  this.params = params;
};
WorkerTile.prototype.parse = function parse (data, layerstyle, actor$1, callback) {
  this.status = 'parsing';
  this.data = data;
  var sourceStyle = this._layerStyleGroupBySourceID(layerstyle)[this.source];
  var tile = this.tileID.split('_');
  var sourceLayerData = {};
  // 数据源解析
  for (var sourcelayer in sourceStyle) { // sourceLayer
    var vectorLayer = data.layers[sourcelayer];
    if (vectorLayer === undefined) {
      return null;
    }
    var style = sourceStyle[sourcelayer][0];
    style.sourceOption.parser.type = 'vector';
    style.sourceOption.parser.tile = tile;
    var tileSource = new actor.Source(Object.assign({}, style.sourceOption,
      {mapType: style.mapType,
      projected: true,
      data: data.layers[sourcelayer]}));
    for (var i = 0; i < sourceStyle[sourcelayer].length; i++) {
      var style$1 = sourceStyle[sourcelayer][i];
      var tileMapping = new TileMapping(tileSource, style$1);
      if (style$1.type === 'point') {
        style$1.shape = this._getPointShape(tileMapping);
      }
      var geometryBuffer = actor.getBuffer(style$1.type, style$1.shape);
      var buffer = new geometryBuffer({
        layerData: tileMapping.layerData,
        shape: style$1.shape,
        style: style$1
      });
      sourceLayerData[style$1.layerId] = {
        buffer: {
          attributes: buffer.attributes,
          indexArray: buffer.indexArray
        },
        // layerData: tileMapping.layerData,
        // sourceData: tileSource.data,
        shape: style$1.shape,
        layerId: style$1.layerId,
        sourcelayer: sourcelayer,
        tileId: this.tileID,
        featureKey: tileSource.data.featureKeys.slice(0)
      };
    }
  }
  this.status = 'done';

  callback(null, Object.assign({}, sourceLayerData));
};
WorkerTile.prototype._layerStyleGroupBySourceID = function _layerStyleGroupBySourceID (layerStyles) {
  var sourceStyles = {};
  // 支持VectorLayer
  for (var layerId in layerStyles) {
    var sourceID = layerStyles[layerId].sourceOption.id;
    var sourcelayer = layerStyles[layerId].sourceOption.parser.sourceLayer;
    if (!sourceStyles[sourceID]) { sourceStyles[sourceID] = {}; }
    if (!sourceStyles[sourceID][sourcelayer]) { sourceStyles[sourceID][sourcelayer] = []; }
    sourceStyles[sourceID][sourcelayer].push(layerStyles[layerId]);
  }
  return sourceStyles;
};
WorkerTile.prototype._getPointShape = function _getPointShape (tileMapping) {
  var shape = null;
  if (!tileMapping.layerData[0].hasOwnProperty('shape')) {
    return 'normal';
  }
  for (var i = 0; i < tileMapping.layerData.length; i++) {
    shape = tileMapping.layerData[i].shape;
    if (shape !== undefined) {
      break;
    }
  }

  // 2D circle 特殊处理
  if (pointShape['2d'].indexOf(shape) !== -1) {
    return 'fill';
  } else if (pointShape['3d'].indexOf(shape) !== -1) {
    return 'extrude';
  }
  // TODO 图片支持
  //else if (this.scene.image.imagesIds.indexOf(shape) !== -1) {
  // return 'image';
  // }
  return 'text';
};

// import WorkerTile from '../worker/workerTile';

function loadVectorTile(params, callback) {
  var request = actor.getArrayBuffer({ url: params.url }, function (err, data) {
    if (err) {
      callback(err);
    } else if (data) {
      callback(null, {
        vectorTile: new actor.VectorTile(new actor.PBF(data.data)),
        rawData: data.data
      });
    }
  });
  return function () {
    request.abort();
    callback();
  };
}
var VectorTileWorkerSource = function VectorTileWorkerSource(actor, layerStyle, loadVectorData) {
  this.actor = actor;
  this.layerStyle = layerStyle;
  this.loadVectorData = loadVectorData || loadVectorTile;
  this.loaded = {};
  this.loading = {};
};
VectorTileWorkerSource.prototype.loadTile = function loadTile (params, callback) {
    var this$1 = this;

  var uid = params.id;
  if (!this.loading) {
    this.loading = {};
  }
  var workerTile = this.loading[uid] = new WorkerTile(params);
  workerTile.abort = this.loadVectorData(params, function (err, response) {
    if (err || !response) {
      workerTile.status = 'done';
      this$1.loaded[uid] = workerTile;
      return callback(err);
    }
    workerTile.vectorTile = response.vectorTile;
    var rawTileData = response.rawData;
    workerTile.parse(response.vectorTile, this$1.layerStyle, this$1.actor, function (err, result) {
      if (err || !result) { return callback(err); }
      // Transferring a copy of rawTileData because the worker needs to retain its copy.
      callback(null, {
        buffer: result,
        rawTileData: rawTileData.slice(0)
      });
    });

    this$1.loaded = this$1.loaded || {};
    this$1.loaded[uid] = workerTile;
  });


};
VectorTileWorkerSource.prototype.abortTile = function abortTile (params, callback) {
  var loading = this.loading;
  var uid = params.id;
  if (loading && loading[uid] && loading[uid].abort) {
    loading[uid].abort();
    delete loading[uid];
  }
  callback();
};
VectorTileWorkerSource.prototype.reloadTile = function reloadTile (params, callback) { // 重新加载 tile
  var loaded = this.loaded,
    uid = params.id,
    vtSource = this;
  if (loaded && loaded[uid]) {
    var workerTile = loaded[uid];
    var done = function (err, data) {
      var reloadCallback = workerTile.reloadCallback;
      if (reloadCallback) {
        delete workerTile.reloadCallback;
        workerTile.parse(workerTile.vectorTile, vtSource.layerStyle, vtSource.actor, reloadCallback);
      }
      callback(err, data);
    };

    if (workerTile.status === 'parsing') {
      workerTile.reloadCallback = done;
    } else if (workerTile.status === 'done') {
      // if there was no vector tile data on the initial load, don't try and re-parse tile
      if (workerTile.vectorTile) {
        workerTile.parse(workerTile.vectorTile, this.layerIndex, this.actor, done);
      } else {
        done();
      }
    }
  }
};
VectorTileWorkerSource.prototype.removeTile = function removeTile (params, callback) {
  var loaded = this.loaded,
    uid = params.id;
  if (loaded && loaded[uid]) {
    delete loaded[uid];
  }
  callback();
};
VectorTileWorkerSource.prototype.unloadTile = function unloadTile () {

};
VectorTileWorkerSource.prototype.hasTransition = function hasTransition () {

};

// 统一管理workerSource 实例化
var Worker = function Worker(self) {
  var this$1 = this;

  this.self = self;
  this.actor = new actor.Actor(self, this);
  this.workerSourceTypes = {
    vector: VectorTileWorkerSource
  };
  this.workerSources = {};
  this.self.registerWorkerSource = function (name, WorkerSource) {
    if (this$1.workerSourceTypes[name]) {
      throw new Error(("Worker source with name \"" + name + "\" already registered."));
    }
    this$1.workerSourceTypes[name] = WorkerSource;
  };
  this.layerStyles = {};
};

Worker.prototype.loadTile = function loadTile (mapId, params, callback) {
  this.getWorkerSource(mapId, params.type, params.sourceID).loadTile(params, callback);
};
Worker.prototype.abortTile = function abortTile (mapId, params, callback) {
  this.getWorkerSource(mapId, params.type, params.sourceID).abortTile(params, callback);
};
Worker.prototype.removeTile = function removeTile (mapId, params, callback) {
  this.getWorkerSource(mapId, params.type, params.sourceID).removeTile(params, callback);
};
Worker.prototype.setLayers = function setLayers (mapId, layercfgs, callback) {
  this.layerStyles[mapId] = layercfgs; // mapid layerID
  if (this.workerSources[mapId]) {
    for (var sourceId in this.workerSources[mapId].vector) {
      this.workerSources[mapId].vector[sourceId].layerStyle = layercfgs;
    }
  }
  callback();
};
// updateLayers(id, params, callback) {

// }
/**
 * 获取workerSource
 * @param {string} mapId WorkerPool Id
 * @param {string} type 瓦片类型 目前支持Vector
 * @param {string} source souce ID
 * @return {*} WorkerSource
 */
Worker.prototype.getWorkerSource = function getWorkerSource (mapId, type, source) {
    var this$1 = this;

  if (!this.workerSources[mapId]) {
    this.workerSources[mapId] = {};
  }
  if (!this.workerSources[mapId][type]) {
    this.workerSources[mapId][type] = {};
  }
  if (!this.workerSources[mapId][type][source]) {
    // use a wrapped actor so that we can attach a target mapId param
    // to any messages invoked by the WorkerSource
    var actor = {
      send: function (type, data, callback) {
        this$1.actor.send(type, data, callback, mapId);
      }
    };
    this.workerSources[mapId][type][source] = new this.workerSourceTypes[type](actor, this.layerStyles[mapId]);
  }
  return this.workerSources[mapId][type][source];
};
self.worker = new Worker(self);

return Worker;

});

define(['./shared'], function (actor) {
function styleInject(css, ref) {
  if ( ref === void 0 ) { ref = {}; }
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".l7-marker {\n\tposition: absolute !important;\n\ttop: 0;\n\tleft: 0;\n\tz-index: 5;\n}\n.l7-popup-anchor-top,\n.l7-popup-anchor-top-left,\n.l7-popup-anchor-top-right {\n    -webkit-flex-direction: column;\n    flex-direction: column;\n}\n\n.l7-popup-anchor-bottom,\n.l7-popup-anchor-bottom-left,\n.l7-popup-anchor-bottom-right {\n    -webkit-flex-direction: column-reverse;\n    flex-direction: column-reverse;\n}\n\n.l7-popup-anchor-left {\n    -webkit-flex-direction: row;\n    flex-direction: row;\n}\n\n.l7-popup-anchor-right {\n    -webkit-flex-direction: row-reverse;\n    flex-direction: row-reverse;\n}\n.l7-popup {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: -webkit-flex;\n  display: flex;\n  will-change: transform;\n  pointer-events: none;\n  z-index: 5;\n}\n.l7-popup-tip {\n  width: 0;\n  height: 0;\n  border: 10px solid transparent;\n  z-index: 1;\n}\n.l7-popup-anchor-top .l7-popup-tip {\n\t-webkit-align-self: center;\n\talign-self: center;\n\tborder-top: none;\n\tborder-bottom-color: #fff;\n}\n\n.l7-popup-anchor-top-left .l7-popup-tip {\n\t-webkit-align-self: flex-start;\n\talign-self: flex-start;\n\tborder-top: none;\n\tborder-left: none;\n\tborder-bottom-color: #fff;\n}\n\n.l7-popup-anchor-top-right .l7-popup-tip {\n\t-webkit-align-self: flex-end;\n\talign-self: flex-end;\n\tborder-top: none;\n\tborder-right: none;\n\tborder-bottom-color: #fff;\n}\n\n.l7-popup-anchor-bottom .l7-popup-tip {\n\t-webkit-align-self: center;\n\talign-self: center;\n\tborder-bottom: none;\n\tborder-top-color: #fff;\n}\n\n.l7-popup-anchor-bottom-left .l7-popup-tip {\n\t-webkit-align-self: flex-start;\n\talign-self: flex-start;\n\tborder-bottom: none;\n\tborder-left: none;\n\tborder-top-color: #fff;\n}\n\n.l7-popup-anchor-bottom-right .l7-popup-tip {\n\t-webkit-align-self: flex-end;\n\talign-self: flex-end;\n\tborder-bottom: none;\n\tborder-right: none;\n\tborder-top-color: #fff;\n}\n\n.l7-popup-anchor-left .l7-popup-tip {\n\t-webkit-align-self: center;\n\talign-self: center;\n\tborder-left: none;\n\tborder-right-color: #fff;\n}\n\n.l7-popup-anchor-right .l7-popup-tip {\n\t-webkit-align-self: center;\n\talign-self: center;\n\tborder-right: none;\n\tborder-left-color: #fff;\n}\n\n.l7-popup-close-button {\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tborder: 0;\n\tpadding: 0;\n\tfont-size: 25px;\n\tline-height: 20px;\n\tborder-radius: 0 3px 0 0;\n\tcursor: pointer;\n\tbackground-color: transparent;\n}\n\n.l7-popup-close-button:hover {\n\tbackground-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n\tposition: relative;\n\tbackground: #fff;\n\tborder-radius: 3px;\n\tbox-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n\tpadding: 10px 10px 15px;\n\tpointer-events: auto;\n}\n\n.l7-popup-anchor-top-left .l7-popup-content {\n\tborder-top-left-radius: 0;\n}\n\n.l7-popup-anchor-top-right .l7-popup-content {\n\tborder-top-right-radius: 0;\n}\n\n.l7-popup-anchor-bottom-left .l7-popup-content {\n\tborder-bottom-left-radius: 0;\n}\n\n.l7-popup-anchor-bottom-right .l7-popup-content {\n\tborder-bottom-right-radius: 0;\n}\n\n.l7-popup-track-pointer {\n\tdisplay: none;\n}\n\n.l7-popup-track-pointer * {\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.l7-map:hover .l7-popup-track-pointer {\n\tdisplay: flex;\n}\n\n.l7-map:active .l7-popup-track-pointer {\n\tdisplay: none;\n}\n\n.l7-popup-close-button {\n  position: absolute;\n  right: 0;\n  top: 0;\n  border: 0;\n  border-radius: 0 3px 0 0;\n  cursor: pointer;\n  background-color: transparent;\n}\n\n.l7-popup-close-button:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.l7-popup-content {\n  position: relative;\n  background: #fff;\n  border-radius: 3px;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n  padding: 10px 10px 15px;\n  pointer-events: auto;\n}\n\n/* general toolbar styles */\n\n.l7-bar {\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\n\tborder-radius: 4px;\n\t}\n.l7-bar a,\n.l7-bar a:hover {\n\tbackground-color: #fff;\n\tborder-bottom: 1px solid #ccc;\n\twidth: 26px;\n\theight: 26px;\n\tline-height: 26px;\n\tdisplay: block;\n\ttext-align: center;\n\ttext-decoration: none;\n\tcolor: black;\n\t}\n.l7-bar a,\n.l7-control-layers-toggle {\n\tbackground-position: 50% 50%;\n\tbackground-repeat: no-repeat;\n\tdisplay: block;\n\t}\n.l7-bar a:hover {\n\tbackground-color: #f4f4f4;\n\t}\n.l7-bar a:first-child {\n\tborder-top-left-radius: 4px;\n\tborder-top-right-radius: 4px;\n\t}\n.l7-bar a:last-child {\n\tborder-bottom-left-radius: 4px;\n\tborder-bottom-right-radius: 4px;\n\tborder-bottom: none;\n\t}\n.l7-bar a.l7-disabled {\n\tcursor: default;\n\tbackground-color: #f4f4f4;\n\tcolor: #bbb;\n\t}\n\n\n/* control positioning */\n\n.l7-control-container {\n\tfont: 12px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif;\n}\n.l7-control-hide {\n\tdisplay: none;\n}\n.l7-control {\n\tposition: relative;\n\tz-index: 800;\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\n\tpointer-events: auto;\n\t}\n.l7-top,\n.l7-bottom {\n\tposition: absolute;\n\tz-index: 1000;\n\tpointer-events: none;\n\t}\n.l7-top {\n\ttop: 0;\n\t}\n.l7-right {\n\tright: 0;\n\t}\n.l7-bottom {\n\tbottom: 0;\n\t}\n.l7-left {\n\tleft: 0;\n\t}\n.l7-control {\n\tfloat: left;\n\tclear: both;\n\t}\n.l7-right .l7-control {\n\tfloat: right;\n\t}\n.l7-top .l7-control {\n\tmargin-top: 10px;\n\t}\n.l7-bottom .l7-control {\n\tmargin-bottom: 10px;\n\t}\n.l7-left .l7-control {\n\tmargin-left: 10px;\n\t}\n.l7-right .l7-control {\n\tmargin-right: 10px;\n  }\n  \n  /* attribution and scale controls */\n\n.l7-control-container .l7-control-attribution {\n\tbackground: #fff;\n\tbackground: rgba(255, 255, 255, 0.7);\n\tmargin: 0;\n\t}\n.l7-control-attribution,\n.l7-control-scale-line {\n\tpadding: 0 5px;\n\tcolor: #333;\n\t}\n.l7-control-attribution a {\n\ttext-decoration: none;\n\t}\n.l7-control-attribution a:hover {\n\ttext-decoration: underline;\n\t}\n.l7-container .l7-control-attribution,\n.l7-container .l7-control-scale {\n\tfont-size: 11px;\n\t}\n.l7-left .l7-control-scale {\n\tmargin-left: 5px;\n\t}\n.l7-bottom .l7-control-scale {\n\tmargin-bottom: 5px;\n\t}\n.l7-control-scale-line {\n\tborder: 2px solid #777;\n\tborder-top: none;\n\tline-height: 1.1;\n\tpadding: 2px 5px 1px;\n\tfont-size: 11px;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\t-moz-box-sizing: border-box;\n\t     box-sizing: border-box;\n\n\tbackground: #fff;\n\tbackground: rgba(255, 255, 255, 0.5);\n\t}\n.l7-control-scale-line:not(:first-child) {\n\tborder-top: 2px solid #777;\n\tborder-bottom: none;\n\tmargin-top: -2px;\n\t}\n.l7-control-scale-line:not(:first-child):not(:last-child) {\n\tborder-bottom: 2px solid #777;\n\t}\n\n.l7-touch .l7-control-attribution,\n.l7-touch .l7-control-layers,\n.l7-touch .l7-bar {\n\tbox-shadow: none;\n\t}\n.l7-touch .l7-control-layers,\n.l7-touch .l7-bar {\n\tborder: 2px solid rgba(0,0,0,0.2);\n\tbackground-clip: padding-box;\n\t}\n\n\n\t/* layers control */\n\n.l7-control-layers {\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\n\tbackground: #fff;\n\tborder-radius: 5px;\n\t}\n.l7-control-layers-toggle {\n\tbackground-image: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 standalone%3D%22no%22%3F%3E%3C!DOCTYPE svg PUBLIC %22-%2F%2FW3C%2F%2FDTD SVG 1.1%2F%2FEN%22 %22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg t%3D%221566292427369%22 class%3D%22icon%22 viewBox%3D%220 0 1024 1024%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 p-id%3D%228341%22 width%3D%2232%22 height%3D%2232%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cdefs%3E%3Cstyle type%3D%22text%2Fcss%22%3E%3C%2Fstyle%3E%3C%2Fdefs%3E%3Cpath d%3D%22M256 341.333333l256 128 256-128-256-128-256 128z m276.864-208.384l341.034667 173.909334c20.736 10.581333 28.202667 34.56 16.682666 53.632a41.386667 41.386667 0 0 1-16.64 15.317333l-341.077333 173.909333a46.336 46.336 0 0 1-41.728 0L150.101333 375.808c-20.736-10.581333-28.202667-34.56-16.682666-53.632a41.386667 41.386667 0 0 1 16.64-15.317333l341.077333-173.909334c12.970667-6.613333 28.757333-6.613333 41.728 0z m0 587.349334a45.653333 45.653333 0 0 1-41.728 0l-341.034667-176.938667c-20.736-10.752-28.202667-35.157333-16.682666-54.528a41.642667 41.642667 0 0 1 16.64-15.573333 34.901333 34.901333 0 0 1 32.213333 0l308.906667 160.213333c12.928 6.741333 28.714667 6.741333 41.685333 0l308.864-160.213333a34.901333 34.901333 0 0 1 32.170667 0c20.736 10.752 28.202667 35.157333 16.682666 54.528a41.642667 41.642667 0 0 1-16.64 15.573333l-341.077333 176.938667z m0 170.666666a45.653333 45.653333 0 0 1-41.728 0l-341.034667-176.938666c-20.736-10.752-28.202667-35.157333-16.682666-54.528a41.642667 41.642667 0 0 1 16.64-15.573334 34.901333 34.901333 0 0 1 32.213333 0l308.906667 160.213334c12.928 6.741333 28.714667 6.741333 41.685333 0l308.864-160.213334a34.901333 34.901333 0 0 1 32.170667 0c20.736 10.752 28.202667 35.157333 16.682666 54.528a41.642667 41.642667 0 0 1-16.64 15.573334l-341.077333 176.938666z%22 fill%3D%22%23000000%22 p-id%3D%228342%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n\twidth: 36px;\n\theight: 36px;\n\t}\n.l7-retina .l7-control-layers-toggle {\n\tbackground-image: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 standalone%3D%22no%22%3F%3E%3C!DOCTYPE svg PUBLIC %22-%2F%2FW3C%2F%2FDTD SVG 1.1%2F%2FEN%22 %22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg t%3D%221566292427369%22 class%3D%22icon%22 viewBox%3D%220 0 1024 1024%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 p-id%3D%228341%22 width%3D%2232%22 height%3D%2232%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cdefs%3E%3Cstyle type%3D%22text%2Fcss%22%3E%3C%2Fstyle%3E%3C%2Fdefs%3E%3Cpath d%3D%22M256 341.333333l256 128 256-128-256-128-256 128z m276.864-208.384l341.034667 173.909334c20.736 10.581333 28.202667 34.56 16.682666 53.632a41.386667 41.386667 0 0 1-16.64 15.317333l-341.077333 173.909333a46.336 46.336 0 0 1-41.728 0L150.101333 375.808c-20.736-10.581333-28.202667-34.56-16.682666-53.632a41.386667 41.386667 0 0 1 16.64-15.317333l341.077333-173.909334c12.970667-6.613333 28.757333-6.613333 41.728 0z m0 587.349334a45.653333 45.653333 0 0 1-41.728 0l-341.034667-176.938667c-20.736-10.752-28.202667-35.157333-16.682666-54.528a41.642667 41.642667 0 0 1 16.64-15.573333 34.901333 34.901333 0 0 1 32.213333 0l308.906667 160.213333c12.928 6.741333 28.714667 6.741333 41.685333 0l308.864-160.213333a34.901333 34.901333 0 0 1 32.170667 0c20.736 10.752 28.202667 35.157333 16.682666 54.528a41.642667 41.642667 0 0 1-16.64 15.573333l-341.077333 176.938667z m0 170.666666a45.653333 45.653333 0 0 1-41.728 0l-341.034667-176.938666c-20.736-10.752-28.202667-35.157333-16.682666-54.528a41.642667 41.642667 0 0 1 16.64-15.573334 34.901333 34.901333 0 0 1 32.213333 0l308.906667 160.213334c12.928 6.741333 28.714667 6.741333 41.685333 0l308.864-160.213334a34.901333 34.901333 0 0 1 32.170667 0c20.736 10.752 28.202667 35.157333 16.682666 54.528a41.642667 41.642667 0 0 1-16.64 15.573334l-341.077333 176.938666z%22 fill%3D%22%23000000%22 p-id%3D%228342%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");\n\tbackground-size: 26px 26px;\n\t}\n.l7-touch .l7-control-layers-toggle {\n\twidth: 44px;\n\theight: 44px;\n\t}\n.l7-control-layers .l7-control-layers-list,\n.l7-control-layers-expanded .l7-control-layers-toggle {\n\tdisplay: none;\n\t}\n.l7-control-layers-expanded .l7-control-layers-list {\n\tdisplay: block;\n\tposition: relative;\n\t}\n.l7-control-layers-expanded {\n\tpadding: 6px 10px 6px 6px;\n\tcolor: #333;\n\tbackground: #fff;\n\t}\n.l7-control-layers-scrollbar {\n\toverflow-y: scroll;\n\toverflow-x: hidden;\n\tpadding-right: 5px;\n\t}\n.l7-control-layers-selector {\n\tmargin-top: 2px;\n\tposition: relative;\n\ttop: 1px;\n\t}\n.l7-control-layers label {\n\tdisplay: block;\n\t}\n.l7-control-layers-separator {\n\theight: 0;\n\tborder-top: 1px solid #ddd;\n\tmargin: 5px -10px 5px -6px;\n\t}\n\n";
styleInject(css);

var Scene = (function() {
  var scene = new actor.Scene();
  return scene;
})();

var Camera = function Camera(container) {
  this.container = container;
  var camera = new actor.PerspectiveCamera(45, 1, 1, 2000000);
  this.camera = camera;
  this.updateSize();
  window.addEventListener('resize', this.updateSize.bind(this));

};
Camera.prototype.updateSize = function updateSize () {
  var container = this.container;
  this.camera.aspect = container.clientWidth / container.clientHeight;
  this.camera.updateProjectionMatrix();
};

var Renderer = function Renderer(container) {
  this.container = container;
  this.initRender();
  this.updateSize();
  window.addEventListener('resize', this.updateSize.bind(this), false);
};
Renderer.prototype.initRender = function initRender () {
  this.renderer = new actor.WebGLRenderer({
    antialias: true,
    alpha: true,
    autoClear: false
  });
  this.renderer.setClearColor(0xff0000, 0.0);
  this.pixelRatio = window.devicePixelRatio;
  this.renderer.setPixelRatio(this.pixelRatio);
  this.renderer.gammaInput = true;
  this.renderer.gammaOutput = true;
  this.renderer.shadowMap.enabled = false;
  this.container.appendChild(this.renderer.domElement);
};
Renderer.prototype.updateSize = function updateSize () {
  this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);

};

// This can be imported from anywhere and will still reference the same scene,
// though there is a helper reference in Engine.pickingScene

var PickingScene = (function() {
  var scene = new actor.Scene();
  return scene;
})();

function destoryObject(obj) {
  if (!obj) {
    return;
  }
  if (obj.children) {
    for (var i = 0; i < obj.children.length; i++) {
      var child = obj.children[i];
      destoryObject(child);
    }
  }
  if (obj.geometry) {
    obj.geometry.dispose();
    obj.geometry = null;
  }
  if (obj.material) {
    if (obj.material.map) {
      obj.material.map.dispose();
      obj.material.map = null;
    }

    obj.material.dispose();
    obj.material = null;
  }
}
function updateObjecteUniform(obj, newOption) {
  if (!obj) {
    return;
  }
  if (obj.children) {
    for (var i = 0; i < obj.children.length; i++) {
      var child = obj.children[i];
      updateObjecteUniform(child, newOption);
    }
  }
  if (obj.material) {
    obj.material.updateUninform(newOption);
  }
}

var nextId = 1;

var Picking = function Picking(world, renderer, camera) {
  this._world = world;
  this._renderer = renderer;
  this._camera = camera;
  this._pickingScene = PickingScene;
  this.world = new actor.Group();
  this._pickingScene.add(this.world);
  var size = this._renderer.getSize();
  this._width = size.width;
  this._height = size.height;
  var parameters = { minFilter: actor.LinearFilter,
    magFilter: actor.LinearFilter,
    format: actor.RGBAFormat,
    stencilBuffer: false,
    depthBuffer: true
  };

  this._pickingTexture = new actor.WebGLRenderTarget(this._width / 10, this._height / 10, parameters);

  this._nextId = 1;

  this._resizeTexture();
  this._initEvents();
};

Picking.prototype._initEvents = function _initEvents () {
  this._resizeHandler = this._resizeTexture.bind(this);
  window.addEventListener('resize', this._resizeHandler, false);
};
Picking.prototype.pickdata = function pickdata (event) {
  var point = { x: event.offsetX, y: event.offsetY, type: event.type, _parent: event };
  if (event.type.substr(0, 5) === 'touch') {
    if (event.touches.length === 0) {
      return;
    }
    var touch = event.touches[0];
    point = { x: touch.clientX, y: touch.clientY, type: event.type, _parent: touch };
  }
  var normalisedPoint = { x: 0, y: 0 };
  normalisedPoint.x = (point.x / this._width) * 2 - 1;
  normalisedPoint.y = -(point.y / this._height) * 2 + 1;
  this._pickAllObject(point, normalisedPoint);
};
Picking.prototype._resizeTexture = function _resizeTexture () {
  var size = this._renderer.getSize();

  this._width = size.width;
  this._height = size.height;
  this._pickingTexture.setSize(this._width, this._height);
  this._pixelBuffer = new Uint8Array(4 * this._width * this._height);
  this._needUpdate = true;
};
Picking.prototype._update = function _update (point) {
  var texture = this._pickingTexture;
  this._renderer.render(this._pickingScene, this._camera, texture);
  this.pixelBuffer = new Uint8Array(4);
  this._renderer.readRenderTargetPixels(texture, point.x, this._height - point.y, 1, 1, this.pixelBuffer);


};
Picking.prototype._filterObject = function _filterObject (id) {
  this.world.children.forEach(function (object, index) {
    index === id ? object.visible = true : object.visible = false;
  });
};
Picking.prototype._layerIsVisable = function _layerIsVisable (object) {
  var layers = this._world.getLayers();
  var isVisable = false;
  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    if (object.name === layer.layerId) {
      isVisable = layer.get('visible');
      break;
    }
  }
  return isVisable;
};
Picking.prototype._pickAllObject = function _pickAllObject (point, normalisedPoint) {
    var this$1 = this;


  this.world.children.forEach(function (object, index) {
    if (!this$1._layerIsVisable(object)) {
      return;
    }
    this$1._filterObject(index);
    var item = this$1._pick(point, normalisedPoint, object.name);
    item.type = point.type;
    item._parent = point._parent;
    this$1._world.emit('pick', item);
    this$1._world.emit('pick-' + object.name, item);

  });
};
Picking.prototype._pick = function _pick (point, normalisedPoint, layerId) {
  this._update(point);
  var id = (this.pixelBuffer[2] * 255 * 255) + (this.pixelBuffer[1] * 255) + (this.pixelBuffer[0]);
  if (id === 16646655 || this.pixelBuffer[3] === 0) {
    id = -999;
    // return;
  }
  var _point2d = { x: point.x, y: point.y };
  var item = {
    layerId: layerId,
    featureId: id,
    point2d: _point2d
  };
  return item;

};

// Add mesh to picking scene
//
// Picking ID should already be added as an attribute
Picking.prototype.add = function add (mesh) {
  this.world.add(mesh);

  this._needUpdate = true;
};

// Remove mesh from picking scene
Picking.prototype.remove = function remove (mesh) {
  this.world.remove(mesh);
  this._needUpdate = true;
};

// Returns next ID to use for picking
Picking.prototype.getNextId = function getNextId () {
  return nextId++;
};

Picking.prototype.destroy = function destroy () {
  // TODO: Find a way to properly remove these listeners as they stay
  // active at the moment
  window.removeEventListener('resize', this._resizeHandler, false);
  destoryObject(this._pickingScene);

  this._pickingScene = null;
  this._pickingTexture = null;
  this._pixelBuffer = null;

  this._world = null;
  this._renderer = null;
  this._camera = null;
};

// Initialise without requiring new keyword
function Picking$1(world, renderer, camera, scene) {
  return new Picking(world, renderer, camera, scene);
}

var Engine = /*@__PURE__*/(function (EventEmitter) {
  function Engine(container, world) {
    EventEmitter.call(this);
    this._scene = Scene;
    this._camera = new Camera(container).camera;
    this._renderer = new Renderer(container).renderer;
    this._world = world;// 地图场景实例
    // for MapBox
    this.world = new actor.Group();
    this._scene.add(this.world);
    this._picking = Picking$1(this._world, this._renderer, this._camera);
    this.clock = new actor.Clock();
    this.composerLayers = [];
  }

  if ( EventEmitter ) Engine.__proto__ = EventEmitter;
  Engine.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Engine.prototype.constructor = Engine;
  Engine.prototype._initPostProcessing = function _initPostProcessing () {
    this.composerLayers.forEach(function (layer) {
      layer.visible && layer.render();
    });
  };
  Engine.prototype.update = function update () {
    this._renderer.clear();
    this._renderer.render(this._scene, this._camera);
    this._initPostProcessing();
  };
  Engine.prototype.destroy = function destroy () {
    destoryObject(this._scene);
    this.composerLayers.forEach(function (layer) {
      layer.distory();
    });
    destoryObject(this.composerLayers);

    this._picking.destroy();
    this._picking = null;
    this._world = null;
    this.clock = null;
    this._camera = null;
    this._renderer = null;
  };
  // 渲染第三方Scene对象
  Engine.prototype.renderScene = function renderScene (scene) {
    this._renderer.render(scene, this._camera);
  };
  Engine.prototype.run = function run () {
    this.update();
    this.engineID = requestAnimationFrame(this.run.bind(this));
  };
  Engine.prototype.stop = function stop () {
    cancelAnimationFrame(this.engineID);
  };

  return Engine;
}(actor.EventEmitter));

var LAYER_MAP = {};
var getLayer = function (type) {
  return LAYER_MAP[type.toLowerCase()];
};
var registerLayer = function (type, layer) {
  if (getLayer(type)) {
    throw new Error(("Layer type '" + type + "' existed."));
  }
  // 存储到 map 中
  LAYER_MAP[type] = layer;
};

var Mapping = function Mapping(cfg) {
  actor.Util.assign(this, cfg);
  if (!this.mesh) { this.mesh = this.layer; }
  this._init();
};

Mapping.prototype._init = function _init () {
  this._initControllers();
  this._initAttrs();
  this._mapping();
};

Mapping.prototype.update = function update () {
  this.mesh.set('scales', {});
  this._initAttrs();
  this._updateMaping();
};
Mapping.prototype.reMapping = function reMapping () {
  this.mesh.set('scales', {});
  this._initAttrs();
  this._mapping();
};

Mapping.prototype._initControllers = function _initControllers () {
  var scalesOption = this.layer.get('scaleOptions');
  var scaleController = new actor.ScaleController({
    defs: Object.assign({}, scalesOption)
  });
  this.mesh.set('scaleController', scaleController);
};

Mapping.prototype._createScale = function _createScale (field) {
  var scales = this.mesh.get('scales');
  this._initControllers(); // scale更新
  var scale = scales[field];
  if (!scale) {
    scale = this.createScale(field);
    scales[field] = scale;
  }
  return scale;
};

Mapping.prototype.createScale = function createScale (field) {
  var data = this.mesh.layerSource.data.dataArray;
  var scales = this.mesh.get('scales');
  var scale = scales[field];
  var scaleController = this.mesh.get('scaleController');
  if (!scale) {
    scale = scaleController.createScale(field, data);
    scales[field] = scale;
  }
  return scale;
};
// 获取属性映射的值
Mapping.prototype._getAttrValues = function _getAttrValues (attr, record) {
  var scales = attr.scales;
  var params = [];
  for (var i = 0; i < scales.length; i++) {
    var scale = scales[i];
    var field = scale.field;
    if (scale.type === 'identity') {
      params.push(scale.value);
    } else {
      params.push(record[field]);
    }
  }
  var indexZoom = params.indexOf('zoom');
  indexZoom !== -1 ? params[indexZoom] = attr.zoom : null;
  var values = attr.mapping.apply(attr, params);
  return values;
};

Mapping.prototype._mapping = function _mapping () {
  var attrs = this.mesh.get('attrs');
  var mappedData = [];
  var data = this.mesh.layerSource.data.dataArray;
  for (var i = 0; i < data.length; i++) {
    var record = data[i];
    var newRecord = {};
    newRecord.id = data[i]._id;
    if (attrs.hasOwnProperty('filter')) {
      var attr = attrs.filter;
      var values = this._getAttrValues(attr, record);
      if (!values[0]) { continue; }
    }
    for (var k in attrs) {
      if (attrs.hasOwnProperty(k)) {
        var attr$1 = attrs[k];
        var names = attr$1.names;
        var values$1 = this._getAttrValues(attr$1, record);
        if (names.length > 1) { // position 之类的生成多个字段的属性
          for (var j = 0; j < values$1.length; j++) {
            var val = values$1[j];
            var name = names[j];
            newRecord[name] = (actor.Util.isArray(val) && val.length === 1) ? val[0] : val; // 只有一个值时返回第一个属性值
          }
        } else {
          newRecord[names[0]] = values$1.length === 1 ? values$1[0] : values$1;

        }
      }
    }
    newRecord.coordinates = record.coordinates;
    mappedData.push(newRecord);
  }
  this.mesh.layerData = mappedData;
};

Mapping.prototype._updateMaping = function _updateMaping () {
  var attrs = this.mesh.get('attrs');

  var data = this.mesh.layerSource.data.dataArray;
  var layerData = this.mesh.layerData;
  for (var i = 0; i < data.length; i++) {
    var record = data[i];
    for (var attrName in attrs) {
      if (attrs.hasOwnProperty(attrName) && attrs[attrName].neadUpdate) {
        var attr = attrs[attrName];
        var names = attr.names;
        var values = this._getAttrValues(attr, record);
        if (names.length > 1) { // position 之类的生成多个字段的属性
          for (var j = 0; j < values.length; j++) {
            var val = values[j];
            var name = names[j];
            layerData[i][name] = (actor.Util.isArray(val) && val.length === 1) ? val[0] : val; // 只有一个值时返回第一个属性值
          }
        } else {
          layerData[i][names[0]] = values.length === 1 ? values[0] : values;

        }
      }
    }
  }
};


Mapping.prototype._initAttrs = function _initAttrs () {
  var attrOptions = this.layer.get('attrOptions');
  for (var type in attrOptions) {
    if (attrOptions.hasOwnProperty(type)) {
      this._updateTileAttr(type);
    }
  }
};
Mapping.prototype._updateTileAttr = function _updateTileAttr (type) {
  var self = this;
  var attrs = this.mesh.get('attrs');
  var attrOptions = this.layer.get('attrOptions');
  var option = attrOptions[type];
  var className = actor.Util.upperFirst(type);
  var fields = this._parseFields(option.field);
  var scales = [];
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    var scale = self._createScale(field);
    if (type === 'color' && actor.Util.isNil(option.values)) { // 设置 color 的默认色值
      option.values = actor.Global.colors;
    }
    scales.push(scale);
  }
  // option.scales = scales;
  var attr = new actor.Attr[className](Object.assign({}, option, {scales: scales}));
  attrs[type] = attr;
};
Mapping.prototype._parseFields = function _parseFields (field) {
  if (actor.Util.isArray(field)) {
    return field;
  }
  if (actor.Util.isString(field)) {
    return field.split('*');
  }
  return [ field ];
};
/**
 * 获取图例配置项
 * @param {*} field 字段
 * @param {*} type 图例类型 color, size
 * @return {*} 图例配置项
 */
Mapping.prototype.getLegendCfg = function getLegendCfg (field, type) {
    var this$1 = this;
    if ( type === void 0 ) type = 'color';

  // todo heatmap
  if (this.layer.type === 'heatmap' && this.layer.shapeType === 'heatmap') {
    return this.get('styleOptions').rampColors;
  }
  var scales = this.layer.get('scales');
  var scale = scales[field];
  var colorAttrs = this.layer.get('attrs')[type];
  var lengendCfg = {};
  if (scale) {
    var ticks = scale.ticks;
    lengendCfg.value = ticks;
    lengendCfg.type = scale.type;
    var values = ticks.map(function (value) {
        var obj;

      var v = this$1._getAttrValues(colorAttrs, ( obj = {}, obj[field] = value, obj ));
      return type === 'color' ? actor.ColorUtil.colorArray2RGBA(v) : v;
    });
    lengendCfg[type] = values;
  }
  return lengendCfg;
};

var PickContoller = function PickContoller(cfg) {
  actor.Util.assign(this, cfg);
  this.pickObject3D = new actor.Object3D();
  this.addToPicking(this.pickObject3D);
};
PickContoller.prototype.getPickingId = function getPickingId () {
  return this.layer.scene._engine._picking.getNextId();
};
PickContoller.prototype.addToPicking = function addToPicking (object) {
  object.name = this.layer.layerId;
  this.layer.scene._engine._picking.add(object);
};
PickContoller.prototype.removePickingObject = function removePickingObject (object) {
  this.layer.scene._engine._picking.remove(object);
};
PickContoller.prototype.removePickingMesh = function removePickingMesh (mesh) {
  this.pickObject3D.remove(mesh);
  destoryObject(mesh);
};
PickContoller.prototype.removePickMeshByName = function removePickMeshByName (name) {
  for (var i = 0; i < this.pickObject3D.children.length; i++) {
    if (this.pickObject3D.children[i].name === name) {
      this.removePickingMesh(this.pickObject3D.children[i]);
    }
  }
};
PickContoller.prototype.removeAllMesh = function removeAllMesh () {
    var this$1 = this;

  this.pickObject3D.children.forEach(function (element) {

    this$1.pickObject3D.remove(element);
    destoryObject(element);
  });
};
PickContoller.prototype.addPickMesh = function addPickMesh (mesh) {
    var this$1 = this;

  var pickmaterial = mesh.material.clone();
  pickmaterial.defines.PICK = true;
  // pickmaterial.fragmentShader = pickingFragmentShader;
  var pickingMesh = new actor.THREE[mesh.type](mesh.geometry, pickmaterial);
  pickingMesh.name = mesh.name;
  pickingMesh.onBeforeRender = function () {
    var zoom = this$1.layer.scene.getZoom();
    updateObjecteUniform(pickingMesh, { u_zoom: zoom });
  };
  this.pickObject3D.add(pickingMesh);
};

var EVENT_TYPES = [ 'start', 'process', 'end', 'reset' ];

var Interaction = function Interaction(cfg) {
  var defaultCfg = this._getDefaultCfg();
  Object.assign(this, defaultCfg, cfg);
  this._eventHandlers = [];
  this._bindEvents();
};
Interaction.prototype._getDefaultCfg = function _getDefaultCfg () {
  return {
    startEvent: 'mousedown',
    processEvent: 'mousemove',
    endEvent: 'mouseup',
    resetEvent: 'dblclick'
  };
};
Interaction.prototype._start = function _start (ev) {
  this.preStart(ev);
  this.start(ev);
  this.afterStart(ev);
};

Interaction.prototype.preStart = function preStart () {};

Interaction.prototype.start = function start () {};

Interaction.prototype.afterStart = function afterStart () {};

Interaction.prototype._process = function _process (ev) {
  this.preProcess(ev);
  this.process(ev);
  this.afterProcess(ev);
};

Interaction.prototype.preProcess = function preProcess () {};

Interaction.prototype.process = function process () {
};

Interaction.prototype.afterProcess = function afterProcess () {};

Interaction.prototype._end = function _end (ev) {
  this.preEnd(ev);
  this.end(ev);
  this.afterEnd(ev);
};
Interaction.prototype.preEnd = function preEnd () {};

Interaction.prototype.end = function end () {};

Interaction.prototype.afterEnd = function afterEnd () {};

Interaction.prototype._reset = function _reset () {
  this.preReset();
  this.reset();
  this.afterReset();
};

Interaction.prototype.preReset = function preReset () {};

Interaction.prototype.reset = function reset () {};

Interaction.prototype.afterReset = function afterReset () {};

Interaction.prototype._bindEvents = function _bindEvents () {
    var this$1 = this;

  actor.lib_87(EVENT_TYPES, function (type) {
    var eventName = this$1[(type + "Event")];
    var handler = actor.lib_29(this$1, ("_" + type));
    this$1.layer.on(eventName, handler);
    this$1._eventHandlers.push({ type: eventName, handler: handler });
  });
};

Interaction.prototype._unbindEvents = function _unbindEvents () {
    var this$1 = this;

  var eventHandlers = this._eventHandlers;
  actor.lib_87(eventHandlers, function (eh) {
    this$1.layer.off(eh.type, eh.handler);
  });
};

Interaction.prototype.destory = function destory () {
  this._unbindEvents();
  this._reset();
};

var Active = /*@__PURE__*/(function (Interaction) {
  function Active(cfg) {
    Interaction.call(this, Object.assign({}, {processEvent: 'mousemove',
      resetEvent: 'mouseleave'},
      cfg));
  }

  if ( Interaction ) Active.__proto__ = Interaction;
  Active.prototype = Object.create( Interaction && Interaction.prototype );
  Active.prototype.constructor = Active;
  Active.prototype.process = function process (ev) {
    this.layer._addActiveFeature(ev);
    this.layer.scene._engine.update();
  };
  Active.prototype.reset = function reset () {
    this.layer._resetStyle();
    this.layer.scene._engine.update();
  };

  return Active;
}(Interaction));

var Select = /*@__PURE__*/(function (Interaction) {
  function Select(cfg) {
    Interaction.call(this, Object.assign({}, {processEvent: 'click'},
      cfg));
  }

  if ( Interaction ) Select.__proto__ = Interaction;
  Select.prototype = Object.create( Interaction && Interaction.prototype );
  Select.prototype.constructor = Select;
  Select.prototype.process = function process (ev) {
    this.layer._addActiveFeature(ev);
    this.layer.scene._engine.update();
  };

  return Select;
}(Interaction));

function throttle(fn, time) {
  var pending = false;
  var timerId;

  var later = function () {
    timerId = null;
    if (pending) {
      fn();
      timerId = setTimeout(later, time);
      pending = false;
    }
  };

  return function () {
    pending = true;
    if (!timerId) {
      later();
    }
    return timerId;
  };
}

var Hash = /*@__PURE__*/(function (Interaction) {
  function Hash(cfg) {
    Interaction.call(this, Object.assign({}, {endEvent: 'camerachange'},
      cfg));
    window.addEventListener('hashchange', this._onHashChange.bind(this), false);
    this._updateHash = throttle(this._updateHashUnthrottled.bind(this), 30 * 1000 / 100);
  }

  if ( Interaction ) Hash.__proto__ = Interaction;
  Hash.prototype = Object.create( Interaction && Interaction.prototype );
  Hash.prototype.constructor = Hash;
  Hash.prototype.end = function end () {
    this._updateHash();
  };
  Hash.prototype.reset = function reset () {
    // this.layer._resetStyle();
  };
  Hash.prototype._getHashString = function _getHashString () {
    var center = this.layer.getCenter(),
      zoom = Math.round(this.layer.getZoom() * 100) / 100,
      // derived from equation: 512px * 2^z / 360 / 10^d < 0.5px
      precision = Math.ceil((zoom * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10),
      m = Math.pow(10, precision),
      lng = Math.round(center.lng * m) / m,
      lat = Math.round(center.lat * m) / m,
      bearing = this.layer.getRotation(),
      pitch = this.layer.getPitch();
    var hash = '';
    hash += "#" + zoom + "/" + lat + "/" + lng;
    if (bearing || pitch) { hash += (("/" + (Math.round(bearing * 10) / 10))); }
    if (pitch) { hash += (("/" + (Math.round(pitch)))); }
    return hash;
  };
  Hash.prototype._onHashChange = function _onHashChange () {
    var loc = window.location.hash.replace('#', '').split('/');
    if (loc.length >= 3) {
      this.layer.setStatus({
        center: [ +loc[2], +loc[1] ],
        zoom: +loc[0],
        bearing: +(loc[3] || 0),
        pitch: +(loc[4] || 0)
      });
      return true;
    }
    return false;
  };
  Hash.prototype._updateHashUnthrottled = function _updateHashUnthrottled () {
    var hash = this._getHashString();
    window.history.replaceState(window.history.state, '', hash);
  };
  Hash.prototype.destory = function destory () {
    window.removeEventListener('hashchange', this._onHashChange, false);
    this.layer.off('camerachange', this._updateHash);
    clearTimeout(this._updateHash());

    return this;
  };

  return Hash;
}(Interaction));

var INTERACTION_MAP = {};

var getInteraction = function (type) {
  return INTERACTION_MAP[type];
};

var registerInteraction = function (type, ctor) {
  // 注册的时候，需要校验 type 重名，不区分大小写
  if (getInteraction(type)) {
    throw new Error(("Interaction type '" + type + "' existed."));
  }
  // 存储到 map 中
  INTERACTION_MAP[type] = ctor;
};

registerInteraction('active', Active);
registerInteraction('select', Select);
registerInteraction('hash', Hash);

var InteractionController = function InteractionController(cfg) {
  // defs 列定义
  actor.Util.assign(this, cfg);
};
// interaction 方法
InteractionController.prototype.clearAllInteractions = function clearAllInteractions () {
  var interactions = this.layer.get('interactions');
  actor.Util.each(interactions, function (interaction, key) {
    interaction.destory();
    delete interactions[key];
  });
  return this;
};
InteractionController.prototype.clearInteraction = function clearInteraction (type) {
  var interactions = this.layer.get('interactions');
  if (interactions[type]) {
    interactions[type].destory();
    delete interactions[type];
  }
  return this;
};
InteractionController.prototype.addInteraction = function addInteraction (type, cfg) {
    if ( cfg === void 0 ) cfg = {};

  cfg.layer = this.layer;
  var Ctor = getInteraction(type);
  var interaction = new Ctor(cfg);
  this._setInteraction(type, interaction);
  return this;
};
InteractionController.prototype._setInteraction = function _setInteraction (type, interaction) {
  var interactions = this.layer.get('interactions');
  if (interactions[type]) {
    interactions[type].destory();
  }
  interactions[type] = interaction;
};

var EventContoller = function EventContoller(cfg) {
  actor.Util.assign(this, cfg);
  this._init();
  this.startPoint = { x: -1, y: -1 };
  this._selectedId = null;
};
EventContoller.prototype._init = function _init () {
    var this$1 = this;

  this.layer.scene.on('pick-' + this.layer.layerId, function (e) {
    var featureId = e.featureId;
      var point2d = e.point2d;
      var type = e.type;
    if (type === 'click') {
      return;
    }
    if (type === 'mousedown') {
      this$1.startPoint = point2d;
    }
    if (type === 'mouseup') {
      this$1.endPoint = point2d;
      if (this$1.startPoint.x - this$1.endPoint.x === 0 && this$1.startPoint.y - this$1.endPoint.y === 0) {
        type = 'click';
      }
    }
    // TODO 瓦片图层获取选中数据信息
    var lnglat = this$1.layer.scene.containerToLngLat(point2d);
    var feature = null;
    var style = null;
    if (featureId !== -999) {
      var res = this$1.layer.getSelectFeature(featureId, lnglat);
      feature = res.feature;
      style = res.style;
    }
    var target = {
      featureId: featureId,
      feature: feature,
      style: style,
      pixel: point2d,
      type: type,
      lnglat: { lng: lnglat.lng, lat: lnglat.lat }
    };
    if (featureId >= 0) { // 拾取到元素，或者离开元素
      if (type.substr(0, 5) === 'touch') {
        type = 'click';
        this$1.layer.emit('mousemove', target);
      }
      this$1.layer.emit(type, target);
      this$1._selectedId = featureId;
    }
    if (featureId < 0 && this$1._selectedId != null) {
      type = 'mouseleave';
      this$1.layer.emit(type, target);
      this$1._selectedId = null;
    }
    this$1.layer._activeIds = featureId;

  });
};
EventContoller.prototype._initMapEvent = function _initMapEvent () {

};

var BufferController = function BufferController(cfg) {
  // defs 列定义
  actor.Util.assign(this, cfg);
  if (!this.mesh) { this.mesh = this.layer; }
};

BufferController.prototype._updateColorAttributes = function _updateColorAttributes () {
    var this$1 = this;

  var filterData = this.mesh.layerData;
  var colorKey = {};
  for (var e = 0; e < filterData.length; e++) {
    var item = filterData[e];
    colorKey[item.id] = item.color;
  }
  this.layer._activeIds = null; // 清空选中元素xwxw
  var colorAttr = this.mesh.mesh.geometry.attributes.a_color;
  var pickAttr = this.mesh.mesh.geometry.attributes.pickingId;
  pickAttr.array.forEach(function (id, index) {
    var newId = Math.abs(id);
    var item = null;
    var color = null;
    if (this$1.mesh.layerSource.data.featureKeys) { // hash数据映射
      newId = this$1.mesh.layerSource.data.featureKeys[newId].index;
      item = filterData[newId];
      color = colorKey[item.id];
    } else {
      item = filterData[newId - 1];
      color = colorKey[newId];
    }

    if (item.hasOwnProperty('filter') && item.filter === false) {
      colorAttr.array[index * 4 + 0] = 0;
      colorAttr.array[index * 4 + 1] = 0;
      colorAttr.array[index * 4 + 2] = 0;
      colorAttr.array[index * 4 + 3] = 0;
      pickAttr.array[index] = -id; // 通过Id数据过滤 id<0 不显示
    } else {
      colorAttr.array[index * 4 + 0] = color[0];
      colorAttr.array[index * 4 + 1] = color[1];
      colorAttr.array[index * 4 + 2] = color[2];
      colorAttr.array[index * 4 + 3] = color[3];
      pickAttr.array[index] = id;
    }
  });
  colorAttr.needsUpdate = true;
  pickAttr.needsUpdate = true;
};
BufferController.prototype._updateStyle = function _updateStyle (option) {
  var newOption = { };
  for (var key in option) {
    newOption['u_' + key] = option[key];
  }
  updateObjecteUniform(this.mesh._object3D, newOption);
};

var Controller = {
  Scale: actor.ScaleController,
  Mapping: Mapping,
  Picking: PickContoller,
  Interaction: InteractionController,
  Event: EventContoller,
  Buffer: BufferController
};

function diff(a, b) {
  // Throw is a or b are not objects.
  if (!actor.lib_73(a)) {
    throw new Error('First parameter to diff() is not an object');
  }
  if (!actor.lib_73(b)) {
    throw new Error('Second parameter to diff() is not an object');
  }

  var changes = [];
  var keysA = actor.lib_51(a);
  var keysB = actor.lib_51(b);

  // Find the items in A that are not in B.
  actor.lib_87(actor.lib_3(keysA, keysB), function (key) {
    changes.push({ type: 'remove', key: key, value: a[key] });
  });

  // Find the items in B that are not in A.
  actor.lib_87(actor.lib_3(keysB, keysA), function (key) {
    changes.push({ type: 'add', key: key, value: b[key] });
  });

  // Find the items that are in both, but have changed.
  actor.lib_87(intersection(keysA, keysB), function (key) {
    if (!actor.lib_91(a[key], b[key])) {
      changes.push({ type: 'update', key: key, value: b[key] });
    }
  });

  return changes;
}
function intersection(keysA, keysB) {
  return keysA.filter(function (key) {
    return keysB.indexOf(key) > -1;
  });
}

/**
 * @fileOverview Layer基类
 * @author lzx199065@gmail.com
 */
var id = 1;
function parseFields(field) {
  if (actor.Util.isArray(field)) {
    return field;
  }
  if (actor.Util.isString(field)) {
    return field.split('*');
  }
  return [ field ];
}
var Layer = /*@__PURE__*/(function (Base) {
  function Layer(scene, cfg) {
    Base.call(this, cfg);
    this.scene = scene;
    this.map = scene.map;
    this._object3D = new actor.Object3D();
    this._pickObject3D = new actor.Object3D();
    this._object3D.visible = this.get('visible');
    this._object3D.renderOrder = this.get('zIndex') || 0;
    this._mapEventHandlers = [];
    var layerId = this._getUniqueId();
    this.set('layerId', layerId);
    this.set('mapType', this.scene.mapType);
    this.layerId = layerId;
    this._activeIds = null;
    var world = scene._engine.world;
    world.add(this._object3D);
    this.layerMesh = null;
    this.layerLineMesh = null;
  }

  if ( Base ) Layer.__proto__ = Base;
  Layer.prototype = Object.create( Base && Base.prototype );
  Layer.prototype.constructor = Layer;
  /**
   * 将图层添加加到 Object
   * @param {*} object three 物体
   */
  Layer.prototype.getDefaultCfg = function getDefaultCfg () {
    return {
      visible: true,
      zIndex: 0,
      type: '',
      minZoom: 0,
      maxZoom: 22,
      rotation: 0,
      option: {},
      attrOptions: {
      },
      scaleOptions: {},
      preScaleOptions: null,
      scales: {},
      attrs: {},
      // 样式配置项
      styleOptions: {
        stroke: [ 1, 1, 1, 1 ],
        strokeWidth: 1.0,
        opacity: 1.0,
        strokeOpacity: 1.0,
        texture: false,
        blending: 'normal'
      },
      destroyed: false,
      // 选中时的配置项
      selectedOptions: null,
      // active 时的配置项
      activedOptions: {
        fill: [ 1.0, 0, 0, 1.0 ]
      },
      interactions: {},
      animateOptions: {
        enable: false
      }
    };
  };

  Layer.prototype.add = function add (object) {
    var this$1 = this;

    // composer合图层绘制
    if (object.type === 'composer') {
      this._object3D = object;
      this.scene._engine.composerLayers.push(object);
      return;
    }
    this.layerMesh = object;
    this._visibleWithZoom();
    object.onBeforeRender = function () { // 每次渲染前改变状态
      var zoom = this$1.scene.getZoom();
      updateObjecteUniform(this$1._object3D, {
        u_time: this$1.scene._engine.clock.getElapsedTime(),
        u_zoom: zoom
      });
      this$1.preRender();
    };

    object.onAfterRender = function () { // 每次渲染后改变状态
      this$1.afterRender();
    };
    this._object3D.add(object);
    this.get('pickingController').addPickMesh(object);

  };
  Layer.prototype.remove = function remove (object) {
    if (object.type === 'composer') {
      this.scene._engine.composerLayers = this.scene._engine.composerLayers.filter(function (layer) {
        return (layer !== object);
      });
      return;
    }
    this._object3D.remove(object);
  };
  Layer.prototype._getUniqueId = function _getUniqueId () {
    return id++;
  };
  Layer.prototype._visible = function _visible (visible) {
    this.set('visible', visible);
    this._object3D.visible = this.get('visible');
  };
  // 兼容瓦片source，非瓦片source

  Layer.prototype.source = function source$1 (data, cfg) {
    var this$1 = this;
    if ( cfg === void 0 ) cfg = {};

    // 根据Source类型判断，是不是瓦片图层
    if (this.scene.getTileSource(data)) {
      this.set('layerType', 'tile');
      this.set('sourceOption', Object.assign({}, {id: data},
        cfg));
      this.scene.style.addLayer(this);
      // 初始化tiles
      this.tiles = new actor.Object3D();
      this._object3D.add(this.tiles);
      return this;
    }

    if (data instanceof actor.Source) {
      this.layerSource = data;
      this.layerSource.on('SourceUpdate', function () {
        this$1.repaint();
      });
      return this;
    }
    cfg.data = data;
    cfg.mapType = this.scene.mapType;
    cfg.zoom = this.scene.getZoom();
    this.layerSource = new actor.Source(cfg);
    return this;
  };
  Layer.prototype.color = function color (field, values) {
    this._createAttrOption('color', field, values, actor.Global.colors);
    return this;
  };
  Layer.prototype.size = function size (field, values) {
    var fields = parseFields(field);
    if (fields.indexOf('zoom') !== -1) {
      this._zoomScale = true;
    }
    if (actor.Util.isArray(fields) && !values) { values = fields; }
    this._createAttrOption('size', field, values, actor.Global.size);
    return this;
  };
  Layer.prototype.scale = function scale (field, cfg) {
    var options = this.get('scaleOptions');
    var scaleDefs = options;
    if (actor.Util.isObject(field)) {
      actor.Util.mix(scaleDefs, field);
    } else {
      scaleDefs[field] = cfg;
    }
    return this;
  };
  Layer.prototype.shape = function shape (field, values) {
    if (field.split(':').length === 2) {
      this.shapeType = field.split(':')[0];
      field = field.split(':')[1];
    }
    values === 'text' ? this.shapeType = values : null;

    this._createAttrOption('shape', field, values, actor.Global.shape);
    return this;
  };
  Layer.prototype.pattern = function pattern (field, values) {
    this._createAttrOption('pattern', field, values, actor.Global.pattern);
    return this;
  };
  /**
   * 是否允许使用默认的图形激活交互
   * @param  {Boolean} enable 是否允许激活开关
   * @param {Object} cfg 激活的配置项
   * @return {Geom}    返回 geom 自身
   */
  Layer.prototype.active = function active (enable, cfg) {
    if (enable === false) {
      this.set('allowActive', false);
    } else if (actor.Util.isObject(enable) && enable.fill) {
      this.set('allowActive', true);
      if (enable.fill) { enable.fill = actor.ColorUtil.color2RGBA(enable.fill); }
      this.set('activedOptions', enable);
    } else {
      this.set('allowActive', true);
      this.set('activedOptions', cfg || { fill: actor.ColorUtil.color2RGBA(actor.Global.activeColor) });
    }
    return this;
  };

  Layer.prototype.style = function style (field, cfg) {
    var colorItem = [ 'fill', 'stroke', 'strokeColor', 'color', 'baseColor', 'brightColor', 'windowColor' ];
    var styleOptions = this.get('styleOptions');
    if (!styleOptions) {
      styleOptions = {};
      this.set('styleOptions', styleOptions);
    }
    if (actor.Util.isObject(field)) {
      cfg = field;
      field = null;
    }
    var fields;
    if (field) {
      fields = parseFields(field);
    }
    styleOptions.fields = fields;
    actor.Util.assign(styleOptions, cfg);
    for (var item in cfg) {
      if (colorItem.indexOf(item) !== -1 && styleOptions[item] !== 'none') {
        styleOptions[item] = actor.ColorUtil.color2RGBA(styleOptions[item]);
      }
    }
    this.set('styleOptions', styleOptions);
    return this;
  };

  Layer.prototype.filter = function filter (field, values) {
    this._createAttrOption('filter', field, values, true);
    return this;
  };

  Layer.prototype.animate = function animate (field, cfg) {
    var animateOptions = this.get('animateOptions');
    if (!animateOptions) {
      animateOptions = {};
      this.set('animateOptions', animateOptions);
    }
    if (actor.Util.isObject(field)) {
      cfg = field;
      field = null;
    }
    var fields;
    if (field) {
      fields = parseFields(field);
    }
    animateOptions.fields = fields;
    actor.Util.assign(animateOptions, cfg);
    this.set('animateOptions', animateOptions);
    return this;
  };
  Layer.prototype.fitBounds = function fitBounds () {
    var extent = this.layerSource.data.extent;
    this.scene.fitBounds(extent);
  };
  Layer.prototype.hide = function hide () {
    this._visible(false);
    this.scene._engine.update();
    return this;
  };
  Layer.prototype.show = function show () {
    this._visible(true);
    this.scene._engine.update();
    return this;
  };
  Layer.prototype.setData = function setData (data, cfg) {
    this.layerSource.setData(data, cfg);
    this.repaint();
    this.scene._engine.update();
  };
  Layer.prototype._createScale = function _createScale (field) {
    // TODO scale更新
    var scales = this.get('scales');
    var scale = scales[field];
    if (!scale) {
      scale = this.createScale(field);
      scales[field] = scale;
    }
    return scale;
  };
  Layer.prototype._setAttrOptions = function _setAttrOptions (attrName, attrCfg) {
    var options = this.get('attrOptions');
    if (attrName === 'size' && this._zoomScale) {
      attrCfg.zoom = this.map.getZoom();
    }
    options[attrName] = attrCfg;
  };
  Layer.prototype._createAttrOption = function _createAttrOption (attrName, field, cfg, defaultValues) {

    var attrCfg = {};
    attrCfg.field = field;
    if (cfg) {
      if (actor.Util.isFunction(cfg)) {
        attrCfg.callback = cfg;
      } else {
        attrCfg.values = cfg;
      }
    } else if (attrName !== 'color') {
      attrCfg.values = defaultValues;
    }
    this._setAttrOptions(attrName, attrCfg);
  };
  Layer.prototype._initControllers = function _initControllers () {
    var pickCtr = new Controller.Picking({ layer: this });
    var interactionCtr = new Controller.Interaction({ layer: this });
    var eventCtr = new Controller.Event({ layer: this });
    this.set('pickingController', pickCtr);
    this.set('interacionController', interactionCtr);
    this.set('eventController', eventCtr);
  };
  Layer.prototype._mapping = function _mapping () {
    var mappingCtr = new Controller.Mapping({ layer: this });
    this.set('mappingController', mappingCtr);
  };
  Layer.prototype.render = function render () {
    if (this.get('layerType') === 'tile') {
      this._initControllers();
      this._initInteraction();
      this.scene.style.update(this._attrs);
      return this;
    }
    this._updateDraw();
    this.scene._engine.update();
    return this;
  };
  // 重绘 度量， 映射，顶点构建
  Layer.prototype.repaint = function repaint () {
    this.set('scales', {});
    this._mapping();
    if (this.layerData.length === 0) {
      return;
    }
    this.redraw();
  };
  // 初始化图层
  Layer.prototype.init = function init () {
    this._initControllers();
    this._mapping();
  };
  Layer.prototype._initInteraction = function _initInteraction () {
    if (this.get('allowActive')) {
      this.get('interacionController').addInteraction('active');
    }
  };
  Layer.prototype._initMapEvent = function _initMapEvent () {
    var this$1 = this;

    // zoomchange  mapmove resize
    var EVENT_TYPES = [ 'zoomchange', 'dragend' ];
    actor.Util.each(EVENT_TYPES, function (type) {
      var handler = actor.Util.wrapBehavior(this$1, ("" + type));
      this$1.map.on(("" + type), handler);
      this$1._mapEventHandlers.push({ type: type, handler: handler });
    });
  };
  Layer.prototype.clearMapEvent = function clearMapEvent () {
    var this$1 = this;

    var eventHandlers = this._mapEventHandlers;
    actor.Util.each(eventHandlers, function (eh) {
      this$1.map.off(eh.type, eh.handler);
    });
  };
  Layer.prototype.zoomchange = function zoomchange (ev) {
    // 地图缩放等级变化
    this._visibleWithZoom(ev);
  };
  Layer.prototype.dragend = function dragend () {

  };
  Layer.prototype.resize = function resize () {
  };

  Layer.prototype.setActive = function setActive (id, color) {
    this._activeIds = id;
    if (!color) { color = actor.Global.activeColor; }
    if (!Array.isArray(color)) {
      color = actor.ColorUtil.color2RGBA(color);
    }
    updateObjecteUniform(this._object3D, {
      u_activeColor: color,
      u_activeId: id
    });
    this.scene._engine.update();
  };

  Layer.prototype._addActiveFeature = function _addActiveFeature (e) {
    var featureId = e.featureId;
    this._activeIds = featureId;
    updateObjecteUniform(this._object3D, { u_activeId: featureId });
  };

  Layer.prototype._setPreOption = function _setPreOption () {
    var nextAttrs = this.get('attrOptions');
    var nextStyle = this.get('styleOptions');
    this.set('preAttrOptions', actor.Util.clone(nextAttrs));
    this.set('preStyleOption', actor.Util.clone(nextStyle));
  };
  Layer.prototype._updateDraw = function _updateDraw () {
    var preAttrs = this.get('preAttrOptions');
    var nextAttrs = this.get('attrOptions');
    var preStyle = this.get('preStyleOption');
    var nextStyle = this.get('styleOptions');
    if (preAttrs === undefined && preStyle === undefined) { // 首次渲染
      this._setPreOption();
      this.init();
      this._initInteraction();
      this._initMapEvent();
      if (this.layerData.length === 0) {
        return;
      }
      this.draw();
      return;
    }
    if (!actor.Util.isEqual(preAttrs.filter, nextAttrs.filter) ||
      !actor.Util.isEqual(preAttrs.color, nextAttrs.color) ||
      !actor.Util.isEqual(preAttrs.size, nextAttrs.size) ||
      !actor.Util.isEqual(preAttrs.shape, nextAttrs.shape)
    ) {
      this.repaint();
    }
    if (!actor.Util.isEqual(preStyle, nextStyle)) {
      // 判断新增，修改，删除
      var newStyle = {};
      actor.Util.each(diff(preStyle, nextStyle), function (ref) {
        var type = ref.type;
        var key = ref.key;
        var value = ref.value;

        (type !== 'remove') && (newStyle[key] = value);
        // newStyle[key] = type === 'remove' ? null : value;
      });
      this._updateStyle(newStyle);
    }
    this._setPreOption();
  };

  Layer.prototype._updateSize = function _updateSize (zoom) {
    var this$1 = this;

    var sizeOption = this.get('attrOptions').size;
    var fields = parseFields(sizeOption.field);
    var data = this.layerSource.data.dataArray;
    if (!this.zoomSizeCache) { this.zoomSizeCache = {}; }
    if (!this.zoomSizeCache[zoom]) {
      this.zoomSizeCache[zoom] = [];
      var loop = function ( i ) {
        var params = fields.map(function (field) { return data[i][field]; });
        var indexZoom = fields.indexOf('zoom');
        indexZoom !== -1 ? params[indexZoom] = zoom : null;
        this$1.zoomSizeCache[zoom].push(sizeOption.callback.apply(sizeOption, params));

      };

      for (var i = 0; i < data.length; i++) loop( i );
    }
    this.emit('sizeUpdated', this.zoomSizeCache[zoom]);
  };
  Layer.prototype._updateStyle = function _updateStyle (option) {
    var newOption = { };
    for (var key in option) {
      newOption['u_' + key] = option[key];
    }
    updateObjecteUniform(this._object3D, newOption);
  };
  Layer.prototype._scaleByZoom = function _scaleByZoom () {
    var this$1 = this;

    if (this._zoomScale) {
      this.map.on('zoomend', function () {
        var zoom = this$1.map.getZoom();
        this$1._updateSize(Math.floor(zoom));
      });
    }
  };

  Layer.prototype.getSelectFeature = function getSelectFeature (featureId, lnglat) {
    if (this.get('layerType') === 'tile') {
      var sourceCache = this.getSourceCache(this.get('sourceOption').id);
      var feature$1 = sourceCache.getSelectFeature(featureId, this.layerId, lnglat);
      return {
        feature: feature$1
      };
    }
    var feature = this.layerSource && this.layerSource.getSelectFeature(featureId) || {};
    var style = this.layerData[featureId - 1];
    return {
      feature: feature,
      style: style
    };
  };
  Layer.prototype._updateFilter = function _updateFilter () {
    this.get('mappingController').reMapping();
  };
  Layer.prototype._visibleWithZoom = function _visibleWithZoom () {
    if (this._object3D === null) { return; }
    var zoom = this.scene.getZoom();
    var minZoom = this.get('minZoom');
    var maxZoom = this.get('maxZoom');
    // z-fighting
    var offset = 0;
    if (this.type === 'point') {
      offset = 5;

    } else if (this.type === 'polyline' || this.type === 'line') {
      offset = 2;
    } else if (this.type === 'polygon') {
      offset = 1;
    }
    if (this.type === 'text') {
      offset = 10;
    }
    this._object3D.position && (this._object3D.position.z = offset * Math.pow(2, 20 - zoom));
    if (zoom < minZoom || zoom >= maxZoom) {
      this._object3D.visible = false;
    } else if (this.get('visible')) {
      this._object3D.visible = true;
    }
  };

  // 重新构建mesh
  Layer.prototype.redraw = function redraw () {
    var this$1 = this;

    this._object3D.children.forEach(function (child) {
      this$1._object3D.remove(child);
    });
    this.get('pickingController').removeAllMesh();
    this.draw();
  };
  /**
   * 重置高亮要素
   */
  Layer.prototype._resetStyle = function _resetStyle () {
    this._activeIds = null;
    updateObjecteUniform(this._object3D, { u_activeId: 0 });
  };
  /**
   * 销毁Layer对象
   */
  Layer.prototype.destroy = function destroy () {
    this.removeAllListeners();
    this.get('interacionController').clearAllInteractions();
    this.clearMapEvent();
    if (this._object3D.type === 'composer') {
      this.remove(this._object3D);
      return;
    }
    if (this._object3D && this._object3D.children) {
      var child;
      for (var i = 0; i < this._object3D.children.length; i++) {
        child = this._object3D.children[i];
        if (!child) {
          continue;
        }
        this.remove(child);
        if (child.geometry) {
          // child.geometry.dispose();
          child.geometry = null;
        }
        if (child.material) {
          if (child.material.map) {
            child.material.map.dispose();
            child.material.map = null;
          }

          child.material.dispose();
          child.material = null;
        }
        child = null;
      }
    }
    this.layerMesh.geometry = null;
    this.layerMesh.material = null;
    if (this._pickingMesh) {
      this._pickingMesh.children[0].geometry = null;
      this._pickingMesh.children[0].material.dispose();
      this._pickingMesh.children[0].material = null;
    }
    this._buffer = null;
    this._object3D = null;
    this.scene._engine._scene.remove(this._object3D);
    this.layerData.length = 0;
    this.layerSource = null;
    this.scene._engine._picking.remove(this._pickingMesh);
    this.destroyed = true;
  };

  /**
   * 获取图例配置项
   * @param {*} field 字段
   * @param {*} type 图例类型 color, size
   * @return {*} 图例配置项
   */
  Layer.prototype.getLegendCfg = function getLegendCfg (field, type) {
    if ( type === void 0 ) type = 'color';

    var mapCtr = this.get('mappingController');
    return mapCtr.getLegendCfg(field, type);
  };
  Layer.prototype.preRender = function preRender () {

  };

  Layer.prototype.afterRender = function afterRender () {

  };

  // tileLayer
  Layer.prototype.getSourceCache = function getSourceCache (id) {
    return this.scene.style.getSource(id);
  };

  return Layer;
}(actor.Base));

var Render_MAP = {};
var getRender = function (layerType, shapeType) {
  return Render_MAP[layerType.toLowerCase()] && Render_MAP[layerType.toLowerCase()][shapeType.toLowerCase()];
};
var registerRender = function (layerType, shapeType, render) {
  if (getRender(layerType, shapeType)) {
    throw new Error(("Render shapeType '" + shapeType + "' existed."));
  }
  // 存储到 map 中
  if (!Render_MAP[layerType.toLowerCase()]) { Render_MAP[layerType.toLowerCase()] = {}; }
  Render_MAP[layerType.toLowerCase()][shapeType.toLowerCase()] = render;
};

var Material = /*@__PURE__*/(function (superclass) {
  function Material () {
    superclass.apply(this, arguments);
  }

  if ( superclass ) Material.__proto__ = superclass;
  Material.prototype = Object.create( superclass && superclass.prototype );
  Material.prototype.constructor = Material;

  Material.prototype.setUniformsValue = function setUniformsValue (name, value) {
    if (!this.uniforms[name]) { return; }
    this.uniforms[name].value = value;
    this.uniforms.needsUpdate = true;
  };
  Material.prototype.setDefinesvalue = function setDefinesvalue (name, value) {
    this.defines[name] = value;
    this.needsUpdate = true;
  };
  Material.prototype.setUniform = function setUniform (option) {
    var uniforms = {};
    for (var key in option) {
      if (key.substr(0, 2) === 'u_') {
        uniforms[key] = { value: option[key] };
      }
    }
    return uniforms;
  };
  Material.prototype.updateUninform = function updateUninform (option) {
    for (var key in option) {
      if (key.substr(0, 2) === 'u_') {
        this.setUniformsValue(key, option[key]);
      }
    }
  };
  Material.prototype.setBending = function setBending (type) {
    this.blending = actor.THREE[Material.blendingEnum[type]] || actor.NormalBlending;
  };

  return Material;
}(actor.ShaderMaterial));
Material.blendingEnum = {
  normal: 'NormalBlending',
  additive: 'AdditiveBlending',
  subtractive: 'SubtractiveBlending'
};

function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

var SHADER_TYPE = {
  VS: 'vs',
  FS: 'fs'
};
var moduleCache = {};
var rawContentCache = {};
var precisionRegExp = /precision\s+(high|low|medium)p\s+float/;
var globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif\n';
var globalDefaultAttribute = 'attribute float pickingId;\n  #ifdef PICK \n varying vec4 worldId; \n #endif \n';
var globalFSDefaultAttribute = '#ifdef PICK \n varying vec4 worldId; \n #endif \n';
var globalDefaultInclude = '#pragma include "pick_color"\n';
var includeRegExp = /#pragma include (["^+"]?["\ "[a-zA-Z_0-9](.*)"]*?)/g;
var uniformRegExp = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\s\S]*?);/g;

function processModule(rawContent, includeList, type) {
  var compiled = rawContent.replace(includeRegExp, function (_, strMatch) {
    var includeOpt = strMatch.split(' ');
    var includeName = includeOpt[0].replace(/"/g, '');

    if (includeList.indexOf(includeName) > -1) {
      return '';
    }

    var txt = rawContentCache[includeName][type];
    includeList.push(includeName);

    var ref = processModule(txt, includeList, type);
    var content = ref.content;
    return content;
  });

  return {
    content: compiled,
    includeList: includeList
  };
}

function getUniformLengthByType(type) {
  var arrayLength = 0;
  switch (type) {
    case 'vec2':
    case 'ivec2':
      arrayLength = 2;
      break;
    case 'vec3':
    case 'ivec3':
      arrayLength = 3;
      break;
    case 'vec4':
    case 'ivec4':
    case 'mat2':
      arrayLength = 4;
      break;
    case 'mat3':
      arrayLength = 9;
      break;
    case 'mat4':
      arrayLength = 16;
      break;
    default:
  }
  return arrayLength;
}

function extractUniforms(content) {
  var uniforms = {};
  content = content.replace(uniformRegExp, function (_, type, c) {
    var defaultValues = c.split(':');
    var uniformName = defaultValues[0].trim();
    var defaultValue = '';
    if (defaultValues.length > 1) {
      defaultValue = defaultValues[1].trim();
    }

    // set default value for uniform according to its type
    // eg. vec2 u -> [0.0, 0.0]
    switch (type) {
      case 'bool':
        defaultValue = defaultValue === 'true';
        break;
      case 'float':
      case 'int':
        defaultValue = Number(defaultValue);
        break;
      case 'vec2':
      case 'vec3':
      case 'vec4':
      case 'ivec2':
      case 'ivec3':
      case 'ivec4':
      case 'mat2':
      case 'mat3':
      case 'mat4':
        if (defaultValue) {
          defaultValue = defaultValue.replace('[', '').replace(']', '')
            .split(',')
            .reduce(function (prev, cur) {
              prev.push(Number(cur.trim()));
              return prev;
            }, []);
        } else {
          defaultValue = new Array(getUniformLengthByType(type)).fill(0);
        }
        break;
      default:
    }

    uniforms[uniformName] = defaultValue;
    return ("uniform " + type + " " + uniformName + ";\n");
  });
  return {
    content: content,
    uniforms: uniforms
  };
}

function registerModule(moduleName, ref) {
  var obj;

  var vs = ref.vs;
  var fs = ref.fs;
  var declaredUniforms = ref.uniforms;
  var ref$1 = extractUniforms(vs);
  var extractedVS = ref$1.content;
  var vsUniforms = ref$1.uniforms;
  var ref$2 = extractUniforms(fs);
  var extractedFS = ref$2.content;
  var fsUniforms = ref$2.uniforms;

  rawContentCache[moduleName] = ( obj = {}, obj[SHADER_TYPE.VS] = extractedVS, obj[SHADER_TYPE.FS] = extractedFS, obj.uniforms = Object.assign({}, vsUniforms,
      fsUniforms,
      declaredUniforms), obj );
}

function getModule(moduleName) {
  var obj;

  if (moduleCache[moduleName]) {
    return moduleCache[moduleName];
  }

  var rawVS = rawContentCache[moduleName][SHADER_TYPE.VS];
  var rawFS = rawContentCache[moduleName][SHADER_TYPE.FS];

  rawVS = globalDefaultAttribute + globalDefaultInclude + rawVS;
  rawFS = globalFSDefaultAttribute + rawFS;

  var ref = processModule(rawVS, [], SHADER_TYPE.VS);
  var vs = ref.content;
  var vsIncludeList = ref.includeList;
  var ref$1 = processModule(rawFS, [], SHADER_TYPE.FS);
  var fs = ref$1.content;
  var fsIncludeList = ref$1.includeList;
  // TODO: extract uniforms and their default values from GLSL
  var uniforms = actor.uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function (prev, cur) {
    return Object.assign({}, prev,
      rawContentCache[cur].uniforms);
  }, {});

  /**
   * set default precision for fragment shader
   * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader
   */
  if (!precisionRegExp.test(fs)) {
    fs = globalDefaultprecision + fs;
  }

  moduleCache[moduleName] = ( obj = {}, obj[SHADER_TYPE.VS] = vs.trim(), obj[SHADER_TYPE.FS] = fs.trim(), obj.uniforms = uniforms, obj );
  return moduleCache[moduleName];
}

function wrapUniforms(uniforms) {
  return Object.keys(uniforms).reduce(function (prev, cur) {
    prev[cur] = {
      value: uniforms[cur]
    };
    return prev;
  }, {});
}

var DEFAULT_LIGHT = {
  type: 'directional',
  // direction: [ 1, 10.5, 12 ],
  direction: [ 0, -10.5, 1 ],
  ambient: [ 0.2, 0.2, 0.2 ],
  diffuse: [ 0.6, 0.6, 0.6 ],
  specular: [ 0.1, 0.1, 0.1 ]
};

var DEFAULT_DIRECTIONAL_LIGHT = {
  direction: [ 0, 0, 0 ],
  ambient: [ 0, 0, 0 ],
  diffuse: [ 0, 0, 0 ],
  specular: [ 0, 0, 0 ]
};

var DEFAULT_SPOT_LIGHT = {
  position: [ 0, 0, 0 ],
  direction: [ 0, 0, 0 ],
  ambient: [ 0, 0, 0 ],
  diffuse: [ 0, 0, 0 ],
  specular: [ 0, 0, 0 ],
  constant: 1,
  linear: 0,
  quadratic: 0,
  angle: 14,
  exponent: 40,
  blur: 5
};

var COLOR_ATTRIBUTES = [
  'ambient', 'diffuse', 'specular'
];

function generateLightingUniforms(lights) {
  var lightsMap = {
    u_directional_lights: new Array(3).fill(Object.assign({}, DEFAULT_DIRECTIONAL_LIGHT)),
    u_num_of_directional_lights: 0,
    u_spot_lights: new Array(3).fill(Object.assign({}, DEFAULT_SPOT_LIGHT)),
    u_num_of_spot_lights: 0
  };
  if (!lights || !lights.length) {
    lights = [ DEFAULT_LIGHT ];
  }
  lights.forEach(function (ref, i) {
    var type = ref.type;
    var rest$1 = objectWithoutProperties( ref, ["type"] );
    var rest = rest$1;

    var lightsUniformName = "u_" + type + "_lights";
    var lightsNumUniformName = "u_num_of_" + type + "_lights";

    Object.keys(rest).forEach(function (key) {
      if (actor.isString(rest[key]) && COLOR_ATTRIBUTES.indexOf(key) > -1) {
        rest[key] = actor.ColorUtil.color2RGBA(rest[key]).slice(0, 3);
      }
    });

    lightsMap[lightsUniformName][i] = Object.assign({}, lightsMap[lightsUniformName][i], rest);
    lightsMap[lightsNumUniformName]++;
  });
  return lightsMap;
}

var PolygonMaterial = /*@__PURE__*/(function (Material) {
  function PolygonMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = getModule('polygon');
    var vs = ref.vs;
    var fs = ref.fs;
    var uniforms = ref.uniforms;
    this.uniforms = wrapUniforms(actor.merge(uniforms, _uniforms));
    this.type = 'PolygonMaterial';
    this.defines = _defines;

    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) PolygonMaterial.__proto__ = Material;
  PolygonMaterial.prototype = Object.create( Material && Material.prototype );
  PolygonMaterial.prototype.constructor = PolygonMaterial;

  return PolygonMaterial;
}(Material));

function DrawPolygonFill(layerData, layer, buffer) {
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  var config = Object.assign({}, style,
    {activeColor: activeOption.fill});
  var opacity = config.opacity;
  var activeColor = config.activeColor;
  var lights = config.lights;
  if (!buffer) {
    var geometryBuffer = actor.getBuffer(layer.type, layer.shape);
    buffer = new geometryBuffer({
      layerData: layerData
    });

  }
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var geometry = new actor.BufferGeometry();
  if (indexArray) {
    geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  }
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.computeVertexNormals();
  var material = new PolygonMaterial(Object.assign({}, {u_opacity: opacity,
    u_activeColor: activeColor},
    generateLightingUniforms(lights)), {
    SHAPE: false,
    LIGHTING: true
  });
  var fillPolygonMesh = new actor.Mesh(geometry, material);
  delete attributes.vertices;
  delete attributes.colors;
  delete attributes.pickingIds;
  delete attributes.normals;
  return fillPolygonMesh;
}

function LineMaterial(options) {
  var ref = getModule('line');
  var vs = ref.vs;
  var fs = ref.fs;
  var material = new Material({
    uniforms: {
      u_opacity: { value: options.u_opacity || 1.0 },
      u_time: { value: options.u_time || 0 },
      u_zoom: { value: options.u_zoom || 10 },
      u_activeId: { value: options.activeId || 0 },
      u_activeColor: { value: options.activeColor || [ 1.0, 0, 0, 1.0 ] }
    },
    vertexShader: vs,
    fragmentShader: fs,
    transparent: true,
    blending: actor.THREE[Material.blendingEnum[options.blending]]
  });
  return material;
}
// 弧线绘制 大圆航线 3D弧线
function ArcLineMaterial(options) {
  var moduleName = 'arcline';
  if (options.shapeType === 'greatCircle') {
    moduleName = 'greatcircle';
  }
  var ref = getModule(moduleName);
  var vs = ref.vs;
  var fs = ref.fs;
  var uniforms = ref.uniforms;
  var material = new Material({
    uniforms: wrapUniforms(actor.merge(uniforms, {
      u_opacity: options.u_opacity,
      segmentNumber: 30,
      u_time: 0,
      u_zoom: options.u_zoom,
      u_activeId: options.activeId,
      u_activeColor: options.activeColor
    })),
    vertexShader: vs,
    fragmentShader: fs,
    transparent: true,
    side: actor.DoubleSide,
    blending: actor.THREE[Material.blendingEnum[options.blending]]
  });
  return material;
}

function MeshLineMaterial(options, defines) {
  var ref = getModule('meshline');
  var vs = ref.vs;
  var fs = ref.fs;
  var uniforms = ref.uniforms;
  var material = new Material({
    uniforms: wrapUniforms(actor.merge(uniforms, options, {
      u_activeId: options.activeId,
      u_activeColor: options.activeColor
    })),
    defines: defines,
    vertexShader: vs,
    fragmentShader: fs,
    transparent: true
  });
  return material;
}

function DrawPolygonLine(layerData, layer, buffer) {
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  var config = Object.assign({}, style,
    {activeColor: activeOption.fill});
  var opacity = config.opacity;
  if (!buffer) {
    var geometryBuffer = actor.getBuffer(layer.type, layer.shape);
    buffer = new geometryBuffer({
      layerData: layerData
    });

  }
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var geometry = new actor.BufferGeometry();
  if (indexArray) {
    geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  }
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  var lineMaterial = new LineMaterial({
    u_opacity: opacity
  }, {
    SHAPE: false
  });
  var polygonLineMesh = new actor.LineSegments(geometry, lineMaterial);
  return polygonLineMesh;
}

function DrawAnimate(layerData, layer, buffer) {
  var style = layer.get('styleOptions');
  var ref = layer.map.getCameraState();
  var near = ref.near;
  var far = ref.far;
  layer.scene.startAnimate();
  if (!buffer) {
    var geometryBuffer = actor.getBuffer(layer.type, 'extrude');
    buffer = new geometryBuffer({
      layerData: layerData,
      uv: true
    });

  }
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var opacity = style.opacity;
  var baseColor = style.baseColor;
  var brightColor = style.brightColor;
  var windowColor = style.windowColor;
  var lights = style.lights;
  var geometry = new actor.BufferGeometry();
  if (indexArray) {
    geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  }
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('faceUv', new actor.Float32BufferAttribute(attributes.uv, 2));
  // geometry.addAttribute('a_size', new THREE.Float32BufferAttribute(attributes.sizes, 1));
  geometry.computeVertexNormals();
  var material = new PolygonMaterial(Object.assign({}, {u_opacity: opacity,
    u_baseColor: baseColor,
    u_brightColor: brightColor,
    u_windowColor: windowColor,
    u_near: near,
    u_far: far},
    generateLightingUniforms(lights)), {
    SHAPE: false,
    LIGHTING: true,
    ANIMATE: true
  });
  var fillPolygonMesh = new actor.Mesh(geometry, material);
  return fillPolygonMesh;
}

DrawAnimate.prototype.updateStyle = function(style) {
  this.fillPolygonMesh.material.updateUninform({
    u_opacity: style.opacity,
    u_baseColor: style.baseColor,
    u_brightColor: style.brightColor,
    u_windowColor: style.windowColor
  });
};

function Draw3DShape(layerData, layer) {
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  var geometryBuffer = actor.getBuffer('shape', 'extrude');
  var buffer = new geometryBuffer({
    layerData: layerData,
    shapeType: layer.shapeType
  });
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var geometry = new actor.BufferGeometry();
  geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('normal', new actor.Float32BufferAttribute(attributes.normals, 3));
  geometry.addAttribute('a_shape', new actor.Float32BufferAttribute(attributes.miters, 3));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 3));

  var material = new PolygonMaterial(Object.assign({}, {u_opacity: style.opacity,
    u_activeColor: activeOption.fill,
    u_zoom: layer.scene.getZoom()},
    generateLightingUniforms(style.lights)), {
    SHAPE: true,
    LIGHTING: true
  });
  material.setDefinesvalue('SHAPE', true);
  material.setBending(style.blending);
  var fillMesh = new actor.Mesh(geometry, material);
  return fillMesh;
}

function TextMaterial(_uniforms) {
  var ref = getModule('text');
  var vs = ref.vs;
  var fs = ref.fs;
  var uniforms = ref.uniforms;
  var material = new Material({
    defines: {
      SDF_PX: '8.0',
      EDGE_GAMMA: 0.105 / window.devicePixelRatio
    },
    uniforms: wrapUniforms(actor.merge(uniforms, _uniforms)),
    vertexShader: vs,
    fragmentShader: fs,
    transparent: true
  });
  return material;
}

/**
 * 返回文本相对锚点位置
 * @param {string} anchor 锚点位置
 * @return {alignment} alignment
 */
function getAnchorAlignment(anchor) {
  var horizontalAlign = 0.5;
  var verticalAlign = 0.5;

  switch (anchor) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
      horizontalAlign = 1;
      break;
    case 'left':
    case 'top-left':
    case 'bottom-left':
      horizontalAlign = 0;
      break;
    default:
      horizontalAlign = 0.5;
  }

  switch (anchor) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
      verticalAlign = 1;
      break;
    case 'top':
    case 'top-right':
    case 'top-left':
      verticalAlign = 0;
      break;
    default:
      verticalAlign = 0.5;
  }

  return { horizontalAlign: horizontalAlign, verticalAlign: verticalAlign };
}

// justify right = 1, left = 0, center = 0.5
function justifyLine(
  positionedGlyphs,
  glyphMap,
  start,
  end,
  justify) {
  if (!justify) {
    return;
  }

  var lastPositionedGlyph = positionedGlyphs[end];
  var glyph = lastPositionedGlyph.glyph;
  if (glyph) {
    var lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
      positionedGlyphs[j].x -= lineIndent;
    }
  }
}

// justify right=1 left=0 center=0.5
// horizontalAlign right=1 left=0 center=0.5
// verticalAlign right=1 left=0 center=0.5
function align(
  positionedGlyphs,
  justify,
  horizontalAlign,
  verticalAlign,
  maxLineLength,
  lineHeight,
  lineCount
) {
  var shiftX = (justify - horizontalAlign) * maxLineLength;
  var shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;

  for (var j = 0; j < positionedGlyphs.length; j++) {
    positionedGlyphs[j].x += shiftX;
    positionedGlyphs[j].y += shiftY;
  }
}

function shapeLines(
  shaping,
  glyphMap,
  lines,
  lineHeight,
  textAnchor,
  textJustify,
  spacing
) {
  // buffer 为 4
  var yOffset = -8;

  var x = 0;
  var y = yOffset;

  var maxLineLength = 0;
  var positionedGlyphs = shaping.positionedGlyphs;

  var justify =
    textJustify === 'right' ? 1 :
      textJustify === 'left' ? 0 : 0.5;

  var lineStartIndex = positionedGlyphs.length;
  lines.forEach(function (line) {
    line.split('').forEach(function (char) {
      var glyph = glyphMap[char];
      var baselineOffset = 0;

      if (glyph) {
        positionedGlyphs.push({
          glyph: char,
          x: x,
          y: y + baselineOffset,
          vertical: false, // TODO：目前只支持水平方向
          scale: 1,
          metrics: glyph
        });
        x += glyph.advance + spacing;
      }
    });

    // 左右对齐
    if (positionedGlyphs.length !== lineStartIndex) {
      var lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }

    x = 0;
    y += lineHeight;
  });

  var ref = getAnchorAlignment(textAnchor);
  var horizontalAlign = ref.horizontalAlign;
  var verticalAlign = ref.verticalAlign;
  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);

  // 计算包围盒
  var height = y - yOffset;

  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top + height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}

/**
 * 计算文本中每个独立字符相对锚点的位置
 *
 * @param {string} text 原始文本
 * @param {*} glyphs mapping
 * @param {number} lineHeight 行高
 * @param {string} textAnchor 文本相对于锚点的位置
 * @param {string} textJustify 左右对齐
 * @param {number} spacing 字符间距
 * @param {[number, number]} translate 文本水平 & 垂直偏移量
 * @return {boolean|shaping} 每个字符相对于锚点的位置
 */
function shapeText(
  text,
  glyphs,
  lineHeight,
  textAnchor,
  textJustify,
  spacing,
  translate
) {

  // TODO：处理换行
  var lines = text.split('\n');

  var positionedGlyphs = [];
  var shaping = {
    positionedGlyphs: positionedGlyphs,
    top: translate[1],
    bottom: translate[1],
    left: translate[0],
    right: translate[0],
    lineCount: lines.length,
    text: text
  };

  shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);
  if (!positionedGlyphs.length) { return false; }

  return shaping;
}

function getGlyphQuads(
  shaping,
  textOffset,
  alongLine
) {
  var positionedGlyphs = shaping.positionedGlyphs;
  var quads = [];

  for (var k = 0; k < positionedGlyphs.length; k++) {
    var positionedGlyph = positionedGlyphs[k];
    var rect = positionedGlyph.metrics;

    // The rects have an addditional buffer that is not included in their size.
    var rectBuffer = 4;

    var halfAdvance = rect.advance * positionedGlyph.scale / 2;

    var glyphOffset = alongLine ?
      [ positionedGlyph.x + halfAdvance, positionedGlyph.y ] :
      [ 0, 0 ];

    var builtInOffset = alongLine ?
      [ 0, 0 ] :
      [ positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1] ];

    var x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
    var y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
    var x2 = x1 + rect.width * positionedGlyph.scale;
    var y2 = y1 + rect.height * positionedGlyph.scale;

    var tl = { x: x1, y: y1 };
    var tr = { x: x2, y: y1 };
    var bl = { x: x1, y: y2 };
    var br = { x: x2, y: y2 };

    // TODO：处理字符旋转的情况

    quads.push({ tl: tl, tr: tr, bl: bl, br: br, tex: rect, glyphOffset: glyphOffset });
  }

  return quads;
}

/**
 * 为文本构建顶点数据，仅支持点要素自动标注。
 * @see https://zhuanlan.zhihu.com/p/72222549
 * @see https://zhuanlan.zhihu.com/p/74373214
 */

function TextBuffer(
  layerData,
  sourceData,
  options,
  fontAtlasManager,
  collisionIndex,
  mvpMatrix
) {
  var fontWeight = options.fontWeight;
  var fontFamily = options.fontFamily;
  var characterSet = [];
  sourceData.forEach(function (element) {
    // shape 存储了 text-field
    var text = element.shape || '';
    text = text.toString();
    for (var j = 0; j < text.length; j++) {
      // 去重
      if (characterSet.indexOf(text[j]) === -1) {
        characterSet.push(text[j]);
      }
    }
  });
  fontAtlasManager.setProps({
    characterSet: characterSet,
    fontFamily: fontFamily,
    fontWeight: fontWeight
  });
  return drawGlyph(layerData, sourceData, options, fontAtlasManager, collisionIndex, mvpMatrix);
}

function drawGlyph(
  layerData, sourceData,
  ref,
  fontAtlasManager,
  collisionIndex,
  mvpMatrix
) {
  var spacing = ref.spacing; if ( spacing === void 0 ) spacing = 2;
  var textAnchor = ref.textAnchor; if ( textAnchor === void 0 ) textAnchor = 'center';
  var textOffset = ref.textOffset; if ( textOffset === void 0 ) textOffset = [ 0, 0 ];
  var padding = ref.padding; if ( padding === void 0 ) padding = [ 4, 4 ];
  var textAllowOverlap = ref.textAllowOverlap;

  var texture = fontAtlasManager.texture;
  var fontAtlas = fontAtlasManager.fontAtlas;
  var mapping = fontAtlasManager.mapping;

  var attributes = {
    fontAtlas: fontAtlas,
    texture: texture,
    positions: [],
    colors: [],
    pickingIds: [],
    textUVs: [],
    textOffsets: [],
    textSizes: [],
    index: []
  };
  var indexCounter = 0;
  layerData.forEach(function (feature, i) {
    var size = feature.size;
    var coordinates = feature.coordinates;
    // 根据字段获取文本
    var text = "" + (layerData[i].shape || '');
    // sdf 中默认字号为 24
    var fontScale = size / 24;

    // 1. 计算每个字符相对锚点的位置
    var shaping = shapeText(text, mapping, 24, textAnchor, 'center', spacing, textOffset);

    if (shaping) {
      // 2. 尝试加入空间索引，获取碰撞检测结果
      // TODO：按照 feature 中指定字段排序，确定插入权重，保证优先级高的文本优先展示
      var ref = collisionIndex.placeCollisionBox({
        x1: shaping.left * fontScale - padding[0],
        x2: shaping.right * fontScale + padding[0],
        y1: shaping.top * fontScale - padding[1],
        y2: shaping.bottom * fontScale + padding[1],
        // 点要素锚点就是当前点位置
        anchorPointX: coordinates[0],
        anchorPointY: coordinates[1]
      }, mvpMatrix);
      var box = ref.box;

      // 无碰撞则加入空间索引
      if (textAllowOverlap || box && box.length) {
        // TODO：featureIndex
        collisionIndex.insertCollisionBox(box, 0);

        // 3. 计算可供渲染的文本块，其中每个字符都包含纹理坐标
        var glyphQuads = getGlyphQuads(shaping, textOffset, false);

        // 4. 构建顶点数据，四个顶点组成一个 quad
        indexCounter = addAttributeForFeature(feature, attributes, glyphQuads, indexCounter);
      }
    }
  });
  return attributes;
}

function addAttributeForFeature(feature, attributes, glyphQuads, indexCounter) {
  var id = feature.id;
  var size = feature.size;
  var color = feature.color;
  var coordinates = feature.coordinates;
  glyphQuads.forEach(function (quad) {
    var ref;


    attributes.pickingIds.push(
      id,
      id,
      id,
      id
    );

    (ref = attributes.colors).push.apply(
      ref, color.concat( color,
      color,
      color )
    );

    attributes.positions.push(
      coordinates[0], coordinates[1],
      coordinates[0], coordinates[1],
      coordinates[0], coordinates[1],
      coordinates[0], coordinates[1]
    );

    attributes.textUVs.push(
      quad.tex.x, quad.tex.y + quad.tex.height,
      quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height,
      quad.tex.x + quad.tex.width, quad.tex.y,
      quad.tex.x, quad.tex.y
    );

    attributes.textOffsets.push(
      quad.tl.x, quad.tl.y,
      quad.tr.x, quad.tr.y,
      quad.br.x, quad.br.y,
      quad.bl.x, quad.bl.y
    );

    attributes.textSizes.push(
      size,
      size,
      size,
      size
    );

    attributes.index.push(
      0 + indexCounter,
      1 + indexCounter,
      2 + indexCounter,
      2 + indexCounter,
      3 + indexCounter,
      0 + indexCounter
    );
    indexCounter += 4;
  });

  return indexCounter;
}

/**
 * 网格索引，相比 @mapbox/grid-index，在简单计算碰撞检测结果时效率更高
 * @see https://zhuanlan.zhihu.com/p/74373214
 */
var GridIndex = function GridIndex(width, height, cellSize) {
  var boxCells = this.boxCells = [];

  this.xCellCount = Math.ceil(width / cellSize);
  this.yCellCount = Math.ceil(height / cellSize);

  for (var i = 0; i < this.xCellCount * this.yCellCount; i++) {
    boxCells.push([]);
  }
  this.boxKeys = [];
  this.bboxes = [];

  this.width = width;
  this.height = height;
  this.xScale = this.xCellCount / width;
  this.yScale = this.yCellCount / height;
  this.boxUid = 0;
};

GridIndex.prototype.insert = function insert (key, x1, y1, x2, y2) {
  this._forEachCell(x1, y1, x2, y2, this._insertBoxCell, this.boxUid++);
  this.boxKeys.push(key);
  this.bboxes.push(x1);
  this.bboxes.push(y1);
  this.bboxes.push(x2);
  this.bboxes.push(y2);
};

GridIndex.prototype._insertBoxCell = function _insertBoxCell (x1, y1, x2, y2, cellIndex, uid) {
  this.boxCells[cellIndex].push(uid);
};

GridIndex.prototype._query = function _query (x1, y1, x2, y2, hitTest, predicate) {
  if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
    return hitTest ? false : [];
  }
  var result = [];
  if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {
    // 这一步是高效的关键，后续精确碰撞检测结果在计算文本可见性时并不需要
    if (hitTest) {
      return true;
    }
    for (var boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {
      result.push({
        key: this.boxKeys[boxUid],
        x1: this.bboxes[boxUid * 4],
        y1: this.bboxes[boxUid * 4 + 1],
        x2: this.bboxes[boxUid * 4 + 2],
        y2: this.bboxes[boxUid * 4 + 3]
      });
    }
    return predicate ? result.filter(predicate) : result;
  }

  var queryArgs = {
    hitTest: hitTest,
    seenUids: { box: {}, circle: {} }
  };
  this._forEachCell(x1, y1, x2, y2, this._queryCell, result, queryArgs, predicate);
  return hitTest ? result.length > 0 : result;
};

GridIndex.prototype.query = function query (x1, y1, x2, y2, predicate) {
  return this._query(x1, y1, x2, y2, false, predicate);
};

GridIndex.prototype.hitTest = function hitTest (x1, y1, x2, y2, predicate) {
  return this._query(x1, y1, x2, y2, true, predicate);
};

GridIndex.prototype._queryCell = function _queryCell (x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {
  var seenUids = queryArgs.seenUids;
  var boxCell = this.boxCells[cellIndex];
  if (boxCell !== null) {
    var bboxes = this.bboxes;
    for (var i = 0, list = boxCell; i < list.length; i += 1) {
      var boxUid = list[i];

        if (!seenUids.box[boxUid]) {
        seenUids.box[boxUid] = true;
        var offset = boxUid * 4;
        if ((x1 <= bboxes[offset + 2]) &&
          (y1 <= bboxes[offset + 3]) &&
          (x2 >= bboxes[offset + 0]) &&
          (y2 >= bboxes[offset + 1]) &&
          (!predicate || predicate(this.boxKeys[boxUid]))) {
          if (queryArgs.hitTest) {
            result.push(true);
            return true;
          }
          result.push({
            key: this.boxKeys[boxUid],
            x1: bboxes[offset],
            y1: bboxes[offset + 1],
            x2: bboxes[offset + 2],
            y2: bboxes[offset + 3]
          });
        }
      }
    }
  }
  return false;
};

GridIndex.prototype._forEachCell = function _forEachCell (x1, y1, x2, y2, fn, arg1, arg2, predicate) {
  var cx1 = this._convertToXCellCoord(x1);
  var cy1 = this._convertToYCellCoord(y1);
  var cx2 = this._convertToXCellCoord(x2);
  var cy2 = this._convertToYCellCoord(y2);

  for (var x = cx1; x <= cx2; x++) {
    for (var y = cy1; y <= cy2; y++) {
      var cellIndex = this.xCellCount * y + x;
      if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) { return; }
    }
  }
};

GridIndex.prototype._convertToXCellCoord = function _convertToXCellCoord (x) {
  return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));
};

GridIndex.prototype._convertToYCellCoord = function _convertToYCellCoord (y) {
  return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));
};

// import GridIndex from 'grid-index';

// 为 viewport 加上 buffer，避免边缘处的文本无法显示
var viewportPadding = 100;

/**
 * 基于网格实现文本避让，大幅提升包围盒碰撞检测效率
 * @see https://zhuanlan.zhihu.com/p/74373214
 */
var CollisionIndex = function CollisionIndex(width, height) {
  this.width = width;
  this.height = height;
  // 创建网格索引
  this.grid = new GridIndex(width + 2 * viewportPadding, height + 2 * viewportPadding, 25);

  this.screenRightBoundary = width + viewportPadding;
  this.screenBottomBoundary = height + viewportPadding;
  this.gridRightBoundary = width + 2 * viewportPadding;
  this.gridBottomBoundary = height + 2 * viewportPadding;
};

CollisionIndex.prototype.placeCollisionBox = function placeCollisionBox (collisionBox, mvpMatrix) {
  var projectedPoint = this.project(mvpMatrix, collisionBox.anchorPointX, collisionBox.anchorPointY);

  var tlX = collisionBox.x1 + projectedPoint.x;
  var tlY = collisionBox.y1 + projectedPoint.y;
  var brX = collisionBox.x2 + projectedPoint.x;
  var brY = collisionBox.y2 + projectedPoint.y;

  if (!this.isInsideGrid(tlX, tlY, brX, brY) ||
    this.grid.hitTest(tlX, tlY, brX, brY)
  ) {
    return {
      box: []
    };
  }

  return {
    box: [ tlX, tlY, brX, brY ]
  };
};

CollisionIndex.prototype.insertCollisionBox = function insertCollisionBox (collisionBox, featureIndex) {
  var key = { featureIndex: featureIndex };
  this.grid.insert(key, collisionBox[0], collisionBox[1], collisionBox[2], collisionBox[3]);
};

/**
 * 后续碰撞检测都需要投影到 viewport 坐标系
 * @param {THREE.Matrix4} mvpMatrix mvp矩阵
 * @param {number} x P20 平面坐标X
 * @param {number} y P20 平面坐标Y
 * @return {Point} projectedPoint
 */
CollisionIndex.prototype.project = function project (mvpMatrix, x, y) {
  var p = new actor.Vector4(x, y, 0, 1)
    .applyMatrix4(mvpMatrix);

  // GL 坐标系[-1, 1] -> viewport 坐标系[width, height]
  return {
    x: (((p.x / p.w + 1) / 2) * this.width) + viewportPadding,
    y: (((-p.y / p.w + 1) / 2) * this.height) + viewportPadding
  };
};

/**
 * 判断包围盒是否在整个网格内，需要加上 buffer
 * @param {number} x1 x1
 * @param {number} y1 y1
 * @param {number} x2 x2
 * @param {number} y2 y2
 * @return {Point} isInside
 */
CollisionIndex.prototype.isInsideGrid = function isInsideGrid (x1, y1, x2, y2) {
  return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
};

var defaultTextStyle = {
  fontWeight: 500,
  textAnchor: 'center',
  textOffset: [ 0, 0 ],
  spacing: 2,
  padding: [ 4, 4 ],
  stroke: 'white',
  strokeWidth: 2,
  strokeOpacity: 1.0,
  textAllowOverlap: false
};
function DrawText(layerData, layer) {
  var style = Object.assign({}, defaultTextStyle,
    layer.get('styleOptions'));
  layer.set('styleOptions', style);
  var activeOption = layer.get('activedOptions');
  var strokeWidth = style.strokeWidth;
  var stroke = style.stroke;
  var opacity = style.opacity;
  var textAllowOverlap = style.textAllowOverlap;
  var ref = layer.scene.getSize();
  var width = ref.width;
  var height = ref.height;
  var ref$1 = _updateGeometry(layerData, layer);
  var geometry = ref$1.geometry;
  var texture = ref$1.texture;
  var fontAtlas = ref$1.fontAtlas;
  var updateGeometryHander = function () {
    var ref = _updateGeometry(layerData, layer);
    var geometry = ref.geometry;
    layer.layerMesh.geometry = geometry;
    layer.layerMesh.geometry.needsUpdate = true;
  };
  if (!textAllowOverlap) {
    layer.scene.on('camerachange', updateGeometryHander);
  } else {
    layer.scene.off('camerachange', updateGeometryHander);
  }
  var material = new TextMaterial({
    name: layer.layerId,
    u_sdf_map: texture,
    u_stroke: stroke,
    u_strokeWidth: strokeWidth,
    u_halo_blur: 0.5,
    u_opacity: opacity,
    u_sdf_map_size: [ fontAtlas.width, fontAtlas.height ],
    u_viewport_size: [ width, height ],
    u_activeColor: activeOption.fill
  });
  var mesh = new actor.Mesh(geometry, material);
  // 更新 viewport
  window.addEventListener('resize', function () {
    var ref = layer.scene.getSize();
    var width = ref.width;
    var height = ref.height;
    material.uniforms.u_viewport_size.value = [ width, height ];
    material.uniforms.needsUpdate = true;
  }, false);

  // 关闭视锥裁剪
  mesh.frustumCulled = false;
  return mesh;
}

function _updateGeometry(layerData, layer) {
  var style = layer.get('styleOptions');
  var fontFamily = style.fontFamily;
  var fontWeight = style.fontWeight;
  var spacing = style.spacing;
  var textAnchor = style.textAnchor;
  var textOffset = style.textOffset;
  var padding = style.padding;
  var textAllowOverlap = style.textAllowOverlap;
  var ref = layer.scene.getSize();
  var width = ref.width;
  var height = ref.height;
  var collisionIndex = new CollisionIndex(width, height);
  var ref$1 = layer.scene._engine;
  var ref$1_camera = ref$1._camera;
  var projectionMatrix = ref$1_camera.projectionMatrix;
  var matrixWorldInverse = ref$1_camera.matrixWorldInverse;

  // 计算 MVP 矩阵
  var mvpMatrix = new actor.Matrix4()
    .copy(projectionMatrix)
    .multiply(matrixWorldInverse);

  var ref$2 = new TextBuffer(
    layerData,
    layerData,
    {
      fontFamily: fontFamily,
      fontWeight: fontWeight,
      spacing: spacing,
      textAnchor: textAnchor,
      textOffset: textOffset,
      padding: padding,
      textAllowOverlap: textAllowOverlap
    },
    layer.scene.fontAtlasManager,
    collisionIndex,
    mvpMatrix
  );
  var index = ref$2.index;
  var positions = ref$2.positions;
  var pickingIds = ref$2.pickingIds;
  var texture = ref$2.texture;
  var colors = ref$2.colors;
  var textUVs = ref$2.textUVs;
  var textOffsets = ref$2.textOffsets;
  var textSizes = ref$2.textSizes;
  var fontAtlas = ref$2.fontAtlas;

  var geometry = new actor.BufferGeometry();
  geometry.setIndex(index);
  geometry.addAttribute(
    'a_pos',
    new actor.Float32BufferAttribute(positions, 2)
  );
  geometry.addAttribute(
    'pickingId',
    new actor.Float32BufferAttribute(pickingIds, 1)
  );
  geometry.addAttribute(
    'a_color',
    new actor.Float32BufferAttribute(colors, 4)
  );
  geometry.addAttribute(
    'a_tex',
    new actor.Float32BufferAttribute(textUVs, 2)
  );
  geometry.addAttribute(
    'a_offset',
    new actor.Float32BufferAttribute(textOffsets, 2)
  );
  geometry.addAttribute(
    'a_size',
    new actor.Float32BufferAttribute(textSizes, 1)
  );
  return { geometry: geometry, texture: texture, fontAtlas: fontAtlas };
}

function DrawLine(layerData, layer, buffer) {

  var style = layer.get('styleOptions');
  var animateOptions = layer.get('animateOptions');
  var activeOption = layer.get('activedOptions');
  if (!buffer) {
    var geometryBuffer = actor.getBuffer(layer.type, layer.shapeType);
    buffer = new geometryBuffer({
      layerData: layerData,
      shapeType: 'line',
      style: style,
      imagePos: layer.scene.image.imagePos
    });

  }
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var hasPattern = buffer.hasPattern;


  var geometry = new actor.BufferGeometry();
  geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 1));
  geometry.addAttribute('normal', new actor.Float32BufferAttribute(attributes.normals, 3));
  geometry.addAttribute('a_miter', new actor.Float32BufferAttribute(attributes.miters, 1));
  geometry.addAttribute('a_distance', new actor.Float32BufferAttribute(attributes.attrDistance, 1));
  geometry.addAttribute('a_dash_array', new actor.Float32BufferAttribute(attributes.dashArray, 1));
  geometry.addAttribute('a_texture_coord', new actor.Float32BufferAttribute(attributes.patterns, 2));
  geometry.addAttribute('a_total_distance', new actor.Float32BufferAttribute(attributes.totalDistances, 1));
  var lineMaterial = new MeshLineMaterial({
    u_opacity: style.opacity,
    u_zoom: layer.scene.getZoom(),
    u_time: 0,
    u_dash_offset: style.dashOffset,
    u_dash_ratio: style.dashRatio,
    activeColor: activeOption.fill,
    u_pattern_spacing: style.patternSpacing || 0,
    u_texture: hasPattern ? layer.scene.image.texture : null,
    blending: style.blending
  }, {
    SHAPE: false,
    ANIMATE: false,
    DASHLINE: style.lineType === 'dash',
    TEXTURE: hasPattern
  });
  var lineMesh = new actor.Mesh(geometry, lineMaterial);
  if (animateOptions.enable) {
    layer.scene.startAnimate();
    var duration = animateOptions.duration; if ( duration === void 0 ) duration = 2;
    var interval = animateOptions.interval; if ( interval === void 0 ) interval = 0.5;
    var trailLength = animateOptions.trailLength; if ( trailLength === void 0 ) trailLength = 0.5;
    var repeat = animateOptions.repeat; if ( repeat === void 0 ) repeat = Infinity;
    layer.animateDuration =
    layer.scene._engine.clock.getElapsedTime() + duration * repeat;
    lineMaterial.updateUninform({
      u_duration: duration,
      u_interval: interval,
      u_trailLength: trailLength
    });
    lineMaterial.setDefinesvalue('ANIMATE', true);
    // lineMaterial.setDefinesvalue('DASHLINE', true);
  }
  return lineMesh;
}

function DrawArcLine(layerData, layer, buffer) {
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  if (!buffer) {
    var geometryBuffer = actor.getBuffer(layer.type, layer.shapeType);
    buffer = new geometryBuffer({
      layerData: layerData,
      shapeType: layer.shapeType,
      style: style
    });

  }
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var geometry = new actor.BufferGeometry();
  geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('a_instance', new actor.Float32BufferAttribute(attributes.instanceArray, 4));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 1));
  var lineMaterial = new ArcLineMaterial({
    u_opacity: style.opacity,
    u_zoom: layer.scene.getZoom(),
    activeColor: activeOption.fill,
    shapeType: layer.shapeType,
    blending: style.blending
  }, {
    SHAPE: false
  });
  var animateOptions = layer.get('animateOptions');
  if (animateOptions.enable) {
    layer.scene.startAnimate();
    var duration = animateOptions.duration; if ( duration === void 0 ) duration = 2;
    var interval = animateOptions.interval; if ( interval === void 0 ) interval = 0.5;
    var trailLength = animateOptions.trailLength; if ( trailLength === void 0 ) trailLength = 0.5;
    var repeat = animateOptions.repeat; if ( repeat === void 0 ) repeat = Infinity;
    layer.animateDuration =
    layer.scene._engine.clock.getElapsedTime() + duration * repeat;
    lineMaterial.updateUninform({
      u_duration: duration,
      u_interval: interval,
      u_trailLength: trailLength
    });
    lineMaterial.setDefinesvalue('ANIMATE', true);
  }
  var arcMesh = new actor.Mesh(geometry, lineMaterial);
  arcMesh.frustumCulled = false;
  return arcMesh;
}

/**
 * 绘制3D多边形轮廓
 * @param {*} points 点数据组
 * @return {object} 顶点坐标和顶点索引
 */
function extrudeline(points) {
  var positions = [];
  points[0].forEach(function (p) { positions.push([ p[0], p[1], 0 ]); });
  points[0].forEach(function (p) { positions.push([ p[0], p[1], 1 ]); }); // top
  var vertIndex = [];
  var pointCount = points[0].length;
  var vertCount = pointCount - 1;
  for (var i = 0; i < vertCount; i++) {
    vertIndex.push(i, i + 1);
    vertIndex.push(i + pointCount, i + 1 + pointCount);
    vertIndex.push(i, i + pointCount);
  }
  vertIndex.push(vertCount, 0);
  vertIndex.push(vertCount, vertCount + pointCount);
  vertIndex.push(vertCount + pointCount, pointCount);
  var newPositions = [];
  vertIndex.forEach(function (index) {
    newPositions.push(positions[index]);
  });
  return newPositions;
}

// mesh line

function Line(path, props, positionsIndex, lengthPerDashSegment, textureCoord) {
  if ( lengthPerDashSegment === void 0 ) lengthPerDashSegment = 200;

  if (Array.isArray(path[0][0])) {
    path = path[0]; // 面坐标转线坐标
  }
  var positions = [];
  var pickingIds = [];
  var normal = [];
  var miter = [];
  var colors = [];
  var dashArray = [];
  var textureCoordArray = [];
  var ref = actor.getNormals(path, false, positionsIndex);
  var normals = ref.normals;
  var attrIndex = ref.attrIndex;
  var attrPos = ref.attrPos;
  var attrDistance = ref.attrDistance;
  var sizes = [];
  var totalDistances = [];
  var size = props.size;
  var color = props.color;
  var id = props.id;
  !Array.isArray(size) && (size = [ size ]);
  var totalLength = attrDistance[attrDistance.length - 1];
  attrPos.forEach(function (point) {
    colors.push.apply(colors, color);
    pickingIds.push(id);
    sizes.push(size[0]);
    point[2] = size[1] || 0;
    positions.push.apply(positions, point);
    textureCoordArray.push(textureCoord.x, textureCoord.y);
    totalDistances.push(totalLength);
  });

  var ratio = lengthPerDashSegment / totalLength;
  normals.forEach(function (n) {
    var norm = n[0];
    var m = n[1];
    normal.push(norm[0], norm[1], 0);
    miter.push(m);
    dashArray.push(ratio);
  });


  return {
    positions: positions,
    normal: normal,
    indexArray: actor.flatten(attrIndex),
    miter: miter,
    colors: colors,
    sizes: sizes,
    pickingIds: pickingIds,
    attrDistance: attrDistance,
    dashArray: dashArray,
    textureCoordArray: textureCoordArray,
    totalDistances: totalDistances
  };
}

var pointShape = actor.Global.pointShape;
function StrokeBuffer(layerData, style) {
  var attribute = {
    shapes: [],
    normal: [],
    miter: [],
    indexArray: [],
    sizes: [],
    positions: [],
    pickingIds: [],
    colors: []
  };
  var stroke = style.stroke;
  var strokeWidth = style.strokeWidth;
  layerData.forEach(function (item) {
    var size = item.size;
    var shape = item.shape;
    var id = item.id;
    var coordinates = item.coordinates;
    var path = actor.polygonPath[shape]();
    var positionsIndex = attribute.miter.length;
    var polygon = null;
    if (pointShape['2d'].indexOf(shape) !== -1) {
      actor.Util.isArray(size) || (size = [ size, size, 0 ]);
      polygon = Line([ path ], { size: [ strokeWidth, 0 ], color: stroke, id: id }, positionsIndex);
    } else if (pointShape['3d'].indexOf(shape) !== -1) {
      actor.Util.isArray(size) || (size = [ size, size, size ]);
      var polygonExtrudePath = extrudeline([ path ]);
      // TODO 3d line
      polygon = Line([ polygonExtrudePath ], { size: [ strokeWidth, 0 ], color: stroke, id: id }, positionsIndex);


    } else {
      throw new Error('Invalid shape type: ' + shape);
    }
    polygonLineBuffer(polygon, coordinates, size, attribute);

  });
  return attribute;
}
function polygonLineBuffer(polygon, geo, size, attribute) {
  var ref, ref$1, ref$2, ref$3, ref$4, ref$5;

  (ref = attribute.shapes).push.apply(ref, polygon.positions);
  (ref$1 = attribute.normal).push.apply(ref$1, polygon.normal);
  (ref$2 = attribute.miter).push.apply(ref$2, polygon.miter);
  (ref$3 = attribute.pickingIds).push.apply(ref$3, polygon.pickingIds);
  (ref$4 = attribute.indexArray).push.apply(ref$4, polygon.indexArray);
  (ref$5 = attribute.colors).push.apply(ref$5, polygon.colors);
  polygon.miter.forEach(function () {
    var ref, ref$1;

    (ref = attribute.positions).push.apply(ref, geo); // 多边形位置
    (ref$1 = attribute.sizes).push.apply(ref$1, size); // 多边形大小
  });

}

function ImageBuffer(layerData, opt) {
  var attributes = {
    vertices: [],
    colors: [],
    sizes: [],
    shapes: [],
    pickingIds: [],
    uv: []
  };
  layerData.forEach(function (item) {
    var ref$1, ref$2;

    var color = item.color;
    var size = item.size;
    var id = item.id;
    var shape = item.shape;
    var coordinates = item.coordinates;
    var ref = opt.imagePos[shape];
    var x = ref.x;
    var y = ref.y;
    (ref$1 = attributes.vertices).push.apply(ref$1, coordinates);
    (ref$2 = attributes.colors).push.apply(ref$2, color);
    attributes.pickingIds.push(id);
    attributes.sizes.push(size * window.devicePixelRatio); //
    attributes.uv.push(x, y);
    attributes.shapes.push(shape);
  });


  return attributes;
}

function NormalBuffer(layerData) {
  var attributes = {
    vertices: [],
    colors: [],
    sizes: [],
    pickingIds: []
  };
  layerData.forEach(function (item) {
    var ref, ref$1;

    var color = item.color;
    var size = item.size;
    var id = item.id;
    var coordinates = item.coordinates;
    (ref = attributes.vertices).push.apply(ref, coordinates);
    (ref$1 = attributes.colors).push.apply(ref$1, color);
    attributes.pickingIds.push(id);
    attributes.sizes.push(size);

  });
  return attributes;
}

var PointMaterial = /*@__PURE__*/(function (Material) {
  function PointMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var uniforms = ref.uniforms;
    var defines = ref.defines;
    var ref$1 = getModule('point');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    this.uniforms = Object.assign(uniforms, this.setUniform(_uniforms));
    this.defines = Object.assign(defines, _defines);
    this.type = 'PointMaterial';
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
    this.blending = actor.THREE[Material.blendingEnum[_uniforms.blending]];
    if (!this.uniforms.shape) { this.blending = actor.AdditiveBlending; }
    if (this.uniforms.u_texture) {
      this.defines.TEXCOORD_0 = true;
    }
  }

  if ( Material ) PointMaterial.__proto__ = Material;
  PointMaterial.prototype = Object.create( Material && Material.prototype );
  PointMaterial.prototype.constructor = PointMaterial;

  PointMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_opacity: { value: 1 },
        u_stroke: { value: [ 1.0, 1.0, 1.0, 1.0 ] },
        u_strokeWidth: { value: 1 },
        u_activeId: { value: 0 }
      },
      defines: {
        SHAPE: false,
        TEXCOORD_0: false
      }
    };
  };

  return PointMaterial;
}(Material));

function DrawImage(layerData, layer) {
  var geometry = new actor.BufferGeometry();
  var style = layer.get('styleOptions');
  var strokeWidth = style.strokeWidth;
  var stroke = style.stroke;
  var opacity = style.opacity;
  var texture = layer.scene.image.texture;
  var attributes = ImageBuffer(layerData, {
    imagePos: layer.scene.image.imagePos
  });
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.vertices, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('uv', new actor.Float32BufferAttribute(attributes.uv, 2));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 1));
  var material = new PointMaterial({
    u_opacity: opacity,
    u_strokeWidth: strokeWidth,
    u_stroke: stroke,
    u_texture: texture
  }, {
    SHAPE: false,
    TEXCOORD_0: true
  });
  material.depthTest = false;
  var strokeMesh = new actor.Points(geometry, material);
  return strokeMesh;
}

var PointMaterial$1 = /*@__PURE__*/(function (Material) {
  function PointMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var uniforms = ref.uniforms;
    var defines = ref.defines;
    var ref$1 = getModule('pointnormal');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    this.uniforms = Object.assign(uniforms, this.setUniform(_uniforms));
    this.defines = Object.assign(defines, _defines);
    this.type = 'PointMaterial';
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
    if (_uniforms) {
      this.blending = actor.THREE[Material.blendingEnum[_uniforms.blending]];
    }
  }

  if ( Material ) PointMaterial.__proto__ = Material;
  PointMaterial.prototype = Object.create( Material && Material.prototype );
  PointMaterial.prototype.constructor = PointMaterial;

  PointMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_opacity: { value: 1 },
        u_stroke: { value: [ 1.0, 1.0, 1.0, 1.0 ] },
        u_strokeWidth: { value: 1 },
        u_activeId: { value: 0 }
      },
      defines: {
        SHAPE: false,
        TEXCOORD_0: false
      }
    };
  };

  return PointMaterial;
}(Material));

/**
 * 原生点绘制
 */

function DrawNormal(layerData, layer) {
  var geometry = new actor.BufferGeometry();
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  var opacity = style.opacity;
  var attributes = NormalBuffer(layerData);
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.vertices, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 1));
  var material = new PointMaterial$1({
    u_opacity: opacity,
    u_activeColor: activeOption.fill,
    blending: style.blending
  }, {
  }, style);
  var strokeMesh = new actor.Points(geometry, material);
  return strokeMesh;
}

var PointLineMaterial = /*@__PURE__*/(function (Material) {
  function PointLineMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var uniforms = ref.uniforms;
    var ref$1 = getModule('pointline');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    this.uniforms = Object.assign(uniforms, this.setUniform(_uniforms));
    this.type = 'PointLineMaterial';
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) PointLineMaterial.__proto__ = Material;
  PointLineMaterial.prototype = Object.create( Material && Material.prototype );
  PointLineMaterial.prototype.constructor = PointLineMaterial;

  PointLineMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_strokeOpacity: { value: 1 },
        u_stroke: { value: [ 1.0, 1.0, 1.0, 1.0 ] },
        u_strokeWidth: { value: 1.0 },
        u_zoom: { value: 10 },
        u_activeId: { value: 0 },
        u_activeColor: { value: [ 1.0, 0, 0, 1.0 ] }

      }
    };
  };

  return PointLineMaterial;
}(Material));

/**
 * @author lzxue
 * @email lzx199065@gmail.com
 * @create date 2018-11-29 16:35:34
 * @modify date 2018-11-29 16:35:34
 * @desc [description] 绘制图形的边框
*/
function DrawStroke(layerData, layer) {
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  var strokeWidth = style.strokeWidth;
  var stroke = style.stroke;
  var strokeOpacity = style.strokeOpacity;
  var attributes = StrokeBuffer(layerData, style);
  var geometry = new actor.BufferGeometry();
  geometry.setIndex(attributes.indexArray);
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_shape', new actor.Float32BufferAttribute(attributes.shapes, 3));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 3));
  geometry.addAttribute('normal', new actor.Float32BufferAttribute(attributes.normal, 3));
  geometry.addAttribute('a_miter', new actor.Float32BufferAttribute(attributes.miter, 1));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  var material = new PointLineMaterial({
    u_strokeOpacity: strokeOpacity,
    u_stroke: stroke,
    u_strokeWidth: strokeWidth,
    u_activeColor: activeOption.fill
  });
  var strokeMesh = new actor.Mesh(geometry, material);
  return strokeMesh;
}

var CircleMaterial = /*@__PURE__*/(function (Material) {
  function CircleMaterial(_uniforms, _defines, parameters) {
    if ( _defines === void 0 ) _defines = {};

    Material.call(this, parameters);
    var ref = getModule('circle');
    var vs = ref.vs;
    var fs = ref.fs;
    var uniforms = ref.uniforms;
    this.uniforms = wrapUniforms(actor.merge(uniforms, _uniforms));
    this.defines = _defines;
    this.type = 'CircleMaterial';
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) CircleMaterial.__proto__ = Material;
  CircleMaterial.prototype = Object.create( Material && Material.prototype );
  CircleMaterial.prototype.constructor = CircleMaterial;

  return CircleMaterial;
}(Material));

/**
 * 绘制 SDF，不仅是圆形
 * 手动构建点阵坐标系，便于实现描边、反走样效果
 */
function drawCircle(layerData, layer, buffer) {
  var style = layer.get('styleOptions');
  var activeOption = layer.get('activedOptions');
  if (!buffer) {
    var geometryBuffer = actor.getBuffer(layer.type, layer.shapeType);
    buffer = new geometryBuffer({
      layerData: layerData
    });

  }
  // const { aPosition, aPackedData } = buffer.attributes;
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var geometry = new actor.BufferGeometry();

  if (buffer.indexArray) {
    geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  }
  // geometry.addAttribute('position', new THREE.Float32BufferAttribute(aPosition, 3));
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('miter', new actor.Float32BufferAttribute(attributes.miters, 2));
  geometry.addAttribute('a_size', new actor.Float32BufferAttribute(attributes.sizes, 1));
  geometry.addAttribute('a_shape', new actor.Float32BufferAttribute(attributes.shapes, 1));
  // geometry.addAttribute('a_packed_data', new THREE.Float32BufferAttribute(aPackedData, 4));
  var material = new CircleMaterial({
    u_opacity: style.opacity,
    u_activeColor: activeOption.fill,
    u_zoom: layer.scene.getZoom(),
    u_stroke: style.stroke,
    u_strokeWidth: style.strokeWidth,
    u_strokeOpacity: style.strokeOpacity
  });
  material.depthTest = false;
  material.setBending(style.blending);
  var fillMesh = new actor.Mesh(geometry, material);
  return fillMesh;
}

var hexagonMaterial = /*@__PURE__*/(function (Material) {
  function hexagonMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var defines = ref.defines;
    var ref$1 = getModule('hexagon');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    var uniforms = ref$1.uniforms;
    this.uniforms = wrapUniforms(actor.merge(uniforms, _uniforms));
    this.type = 'hexagonMaterial';
    this.defines = Object.assign(defines, _defines);
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) hexagonMaterial.__proto__ = Material;
  hexagonMaterial.prototype = Object.create( Material && Material.prototype );
  hexagonMaterial.prototype.constructor = hexagonMaterial;

  hexagonMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_opacity: { value: 1.0 },
        u_time: { value: 0 },
        u_radius: { value: 0.01 },
        u_angle: { value: 0.01 },
        u_coverage: { value: 0.8 },
        u_activeId: { value: 0 },
        u_activeColor: { value: [ 1.0, 0, 0, 1.0 ] }
      },
      defines: {

      }
    };
  };

  return hexagonMaterial;
}(Material));

function DrawHexagon(layerData, layer, source) {
  var style = layer.get('styleOptions');
  var ref = layer.get('activedOptions');
  var fill = ref.fill;
  var ref$1 = source.data;
  var radius = ref$1.radius;
  var opacity = style.opacity;
  var angle = style.angle; if ( angle === void 0 ) angle = 0;
  var coverage = style.coverage;
  var lights = style.lights;
  var geometryBuffer = actor.getBuffer(layer.type, 'shape');
  var buffer = new geometryBuffer({
    layerData: layerData,
    shapeType: layer.shapeType
  });
  var attributes = buffer.attributes;
  var instanceGeometry = buffer.instanceGeometry;
  var instancedGeometry = new actor.InstancedBufferGeometry();
  instancedGeometry.setIndex(instanceGeometry.indexArray);
  instancedGeometry.addAttribute('miter', new actor.Float32BufferAttribute(instanceGeometry.positions, 3));
  if (instanceGeometry.normals) {
    instancedGeometry.addAttribute('normal', new actor.Float32BufferAttribute(instanceGeometry.normals, 3));
  }
  instancedGeometry.addAttribute('position', new actor.InstancedBufferAttribute(new Float32Array(attributes.positions), 3));
  instancedGeometry.addAttribute('a_color', new actor.InstancedBufferAttribute(new Float32Array(attributes.colors), 4));
  instancedGeometry.addAttribute('pickingId', new actor.InstancedBufferAttribute(new Float32Array(attributes.pickingIds), 1));
  instancedGeometry.addAttribute('a_size', new actor.InstancedBufferAttribute(new Float32Array(attributes.sizes), 1));

  var material = new hexagonMaterial(Object.assign({}, {u_opacity: opacity,
    u_radius: radius,
    u_angle: angle / 180 * Math.PI,
    u_coverage: coverage,
    u_activeColor: fill},
    generateLightingUniforms(lights)), {
    SHAPE: false,
    LIGHTING: !!instanceGeometry.normals
  });
  var hexgonMesh = new actor.Mesh(instancedGeometry, material);
  return hexgonMesh;
}

var GridMaterial = /*@__PURE__*/(function (Material) {
  function GridMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var defines = ref.defines;
    var ref$1 = getModule('grid');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    var uniforms = ref$1.uniforms;
    this.uniforms = wrapUniforms(actor.merge(uniforms, _uniforms));
    this.type = 'GridMaterial';
    this.defines = Object.assign(defines, _defines);
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) GridMaterial.__proto__ = Material;
  GridMaterial.prototype = Object.create( Material && Material.prototype );
  GridMaterial.prototype.constructor = GridMaterial;

  GridMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_opacity: { value: 1.0 },
        u_time: { value: 0 },
        u_xOffset: { value: 0.01 },
        u_yOffset: { value: 0.01 },
        u_coverage: { value: 0.8 },
        u_activeId: { value: 0 },
        u_activeColor: { value: [ 1.0, 0, 0, 1.0 ] }
      },
      defines: {

      }
    };
  };

  return GridMaterial;
}(Material));

function DrawGrid(layerData, layer, source) {
  var ref = layer.get('styleOptions');
  var opacity = ref.opacity;
  var coverage = ref.coverage;
  var lights = ref.lights;
  var activeOption = layer.get('activedOptions');
  var ref$1 = source.data;
  var xOffset = ref$1.xOffset;
  var yOffset = ref$1.yOffset;

  // const attributes = new gridBuffer(layerdata);
  var geometryBuffer = actor.getBuffer(layer.type, layer.shapeType);
  var buffer = new geometryBuffer({
    layerData: layerData,
    shapeType: layer.shapeType
  });
  var attributes = buffer.attributes;
  var indexArray = buffer.indexArray;
  var geometry = new actor.BufferGeometry();
  geometry.setIndex(new actor.Uint32BufferAttribute(indexArray, 1));
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.positions, 3));
  geometry.addAttribute('miter', new actor.Float32BufferAttribute(attributes.miters, 3));
  geometry.addAttribute('a_color', new actor.Float32BufferAttribute(attributes.colors, 4));
  geometry.addAttribute('pickingId', new actor.Float32BufferAttribute(attributes.pickingIds, 1));
  geometry.addAttribute('normal', new actor.Float32BufferAttribute(attributes.normals, 3));

  var material = new GridMaterial(Object.assign({}, {u_opacity: opacity,
    u_xOffset: xOffset,
    u_yOffset: yOffset,
    u_coverage: coverage,
    u_activeColor: activeOption.fill},
    generateLightingUniforms(lights)), {
    SHAPE: false,
    LIGHTING: layer.shapeType !== 'square'
  });
  var gridMesh = new actor.Mesh(geometry, material);
  return gridMesh;
}

// code from https://github.com/santilland/plotty/blob/master/src/colorscales.js
var colorScales = {
  viridis: new Uint8Array([ 68, 1, 84, 255, 68, 2, 86, 255, 69, 4, 87, 255, 69, 5, 89, 255, 70, 7, 90, 255, 70, 8, 92, 255, 70, 10, 93, 255, 70, 11, 94, 255, 71, 13, 96, 255, 71, 14, 97, 255, 71, 16, 99, 255, 71, 17, 100, 255, 71, 19, 101, 255, 72, 20, 103, 255, 72, 22, 104, 255, 72, 23, 105, 255, 72, 24, 106, 255, 72, 26, 108, 255, 72, 27, 109, 255, 72, 28, 110, 255, 72, 29, 111, 255, 72, 31, 112, 255, 72, 32, 113, 255, 72, 33, 115, 255, 72, 35, 116, 255, 72, 36, 117, 255, 72, 37, 118, 255, 72, 38, 119, 255, 72, 40, 120, 255, 72, 41, 121, 255, 71, 42, 122, 255, 71, 44, 122, 255, 71, 45, 123, 255, 71, 46, 124, 255, 71, 47, 125, 255, 70, 48, 126, 255, 70, 50, 126, 255, 70, 51, 127, 255, 70, 52, 128, 255, 69, 53, 129, 255, 69, 55, 129, 255, 69, 56, 130, 255, 68, 57, 131, 255, 68, 58, 131, 255, 68, 59, 132, 255, 67, 61, 132, 255, 67, 62, 133, 255, 66, 63, 133, 255, 66, 64, 134, 255, 66, 65, 134, 255, 65, 66, 135, 255, 65, 68, 135, 255, 64, 69, 136, 255, 64, 70, 136, 255, 63, 71, 136, 255, 63, 72, 137, 255, 62, 73, 137, 255, 62, 74, 137, 255, 62, 76, 138, 255, 61, 77, 138, 255, 61, 78, 138, 255, 60, 79, 138, 255, 60, 80, 139, 255, 59, 81, 139, 255, 59, 82, 139, 255, 58, 83, 139, 255, 58, 84, 140, 255, 57, 85, 140, 255, 57, 86, 140, 255, 56, 88, 140, 255, 56, 89, 140, 255, 55, 90, 140, 255, 55, 91, 141, 255, 54, 92, 141, 255, 54, 93, 141, 255, 53, 94, 141, 255, 53, 95, 141, 255, 52, 96, 141, 255, 52, 97, 141, 255, 51, 98, 141, 255, 51, 99, 141, 255, 50, 100, 142, 255, 50, 101, 142, 255, 49, 102, 142, 255, 49, 103, 142, 255, 49, 104, 142, 255, 48, 105, 142, 255, 48, 106, 142, 255, 47, 107, 142, 255, 47, 108, 142, 255, 46, 109, 142, 255, 46, 110, 142, 255, 46, 111, 142, 255, 45, 112, 142, 255, 45, 113, 142, 255, 44, 113, 142, 255, 44, 114, 142, 255, 44, 115, 142, 255, 43, 116, 142, 255, 43, 117, 142, 255, 42, 118, 142, 255, 42, 119, 142, 255, 42, 120, 142, 255, 41, 121, 142, 255, 41, 122, 142, 255, 41, 123, 142, 255, 40, 124, 142, 255, 40, 125, 142, 255, 39, 126, 142, 255, 39, 127, 142, 255, 39, 128, 142, 255, 38, 129, 142, 255, 38, 130, 142, 255, 38, 130, 142, 255, 37, 131, 142, 255, 37, 132, 142, 255, 37, 133, 142, 255, 36, 134, 142, 255, 36, 135, 142, 255, 35, 136, 142, 255, 35, 137, 142, 255, 35, 138, 141, 255, 34, 139, 141, 255, 34, 140, 141, 255, 34, 141, 141, 255, 33, 142, 141, 255, 33, 143, 141, 255, 33, 144, 141, 255, 33, 145, 140, 255, 32, 146, 140, 255, 32, 146, 140, 255, 32, 147, 140, 255, 31, 148, 140, 255, 31, 149, 139, 255, 31, 150, 139, 255, 31, 151, 139, 255, 31, 152, 139, 255, 31, 153, 138, 255, 31, 154, 138, 255, 30, 155, 138, 255, 30, 156, 137, 255, 30, 157, 137, 255, 31, 158, 137, 255, 31, 159, 136, 255, 31, 160, 136, 255, 31, 161, 136, 255, 31, 161, 135, 255, 31, 162, 135, 255, 32, 163, 134, 255, 32, 164, 134, 255, 33, 165, 133, 255, 33, 166, 133, 255, 34, 167, 133, 255, 34, 168, 132, 255, 35, 169, 131, 255, 36, 170, 131, 255, 37, 171, 130, 255, 37, 172, 130, 255, 38, 173, 129, 255, 39, 173, 129, 255, 40, 174, 128, 255, 41, 175, 127, 255, 42, 176, 127, 255, 44, 177, 126, 255, 45, 178, 125, 255, 46, 179, 124, 255, 47, 180, 124, 255, 49, 181, 123, 255, 50, 182, 122, 255, 52, 182, 121, 255, 53, 183, 121, 255, 55, 184, 120, 255, 56, 185, 119, 255, 58, 186, 118, 255, 59, 187, 117, 255, 61, 188, 116, 255, 63, 188, 115, 255, 64, 189, 114, 255, 66, 190, 113, 255, 68, 191, 112, 255, 70, 192, 111, 255, 72, 193, 110, 255, 74, 193, 109, 255, 76, 194, 108, 255, 78, 195, 107, 255, 80, 196, 106, 255, 82, 197, 105, 255, 84, 197, 104, 255, 86, 198, 103, 255, 88, 199, 101, 255, 90, 200, 100, 255, 92, 200, 99, 255, 94, 201, 98, 255, 96, 202, 96, 255, 99, 203, 95, 255, 101, 203, 94, 255, 103, 204, 92, 255, 105, 205, 91, 255, 108, 205, 90, 255, 110, 206, 88, 255, 112, 207, 87, 255, 115, 208, 86, 255, 117, 208, 84, 255, 119, 209, 83, 255, 122, 209, 81, 255, 124, 210, 80, 255, 127, 211, 78, 255, 129, 211, 77, 255, 132, 212, 75, 255, 134, 213, 73, 255, 137, 213, 72, 255, 139, 214, 70, 255, 142, 214, 69, 255, 144, 215, 67, 255, 147, 215, 65, 255, 149, 216, 64, 255, 152, 216, 62, 255, 155, 217, 60, 255, 157, 217, 59, 255, 160, 218, 57, 255, 162, 218, 55, 255, 165, 219, 54, 255, 168, 219, 52, 255, 170, 220, 50, 255, 173, 220, 48, 255, 176, 221, 47, 255, 178, 221, 45, 255, 181, 222, 43, 255, 184, 222, 41, 255, 186, 222, 40, 255, 189, 223, 38, 255, 192, 223, 37, 255, 194, 223, 35, 255, 197, 224, 33, 255, 200, 224, 32, 255, 202, 225, 31, 255, 205, 225, 29, 255, 208, 225, 28, 255, 210, 226, 27, 255, 213, 226, 26, 255, 216, 226, 25, 255, 218, 227, 25, 255, 221, 227, 24, 255, 223, 227, 24, 255, 226, 228, 24, 255, 229, 228, 25, 255, 231, 228, 25, 255, 234, 229, 26, 255, 236, 229, 27, 255, 239, 229, 28, 255, 241, 229, 29, 255, 244, 230, 30, 255, 246, 230, 32, 255, 248, 230, 33, 255, 251, 231, 35, 255, 253, 231, 37, 255 ]),
  inferno: new Uint8Array([ 0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 10, 255, 2, 2, 12, 255, 2, 2, 14, 255, 3, 2, 16, 255, 4, 3, 18, 255, 4, 3, 20, 255, 5, 4, 23, 255, 6, 4, 25, 255, 7, 5, 27, 255, 8, 5, 29, 255, 9, 6, 31, 255, 10, 7, 34, 255, 11, 7, 36, 255, 12, 8, 38, 255, 13, 8, 41, 255, 14, 9, 43, 255, 16, 9, 45, 255, 17, 10, 48, 255, 18, 10, 50, 255, 20, 11, 52, 255, 21, 11, 55, 255, 22, 11, 57, 255, 24, 12, 60, 255, 25, 12, 62, 255, 27, 12, 65, 255, 28, 12, 67, 255, 30, 12, 69, 255, 31, 12, 72, 255, 33, 12, 74, 255, 35, 12, 76, 255, 36, 12, 79, 255, 38, 12, 81, 255, 40, 11, 83, 255, 41, 11, 85, 255, 43, 11, 87, 255, 45, 11, 89, 255, 47, 10, 91, 255, 49, 10, 92, 255, 50, 10, 94, 255, 52, 10, 95, 255, 54, 9, 97, 255, 56, 9, 98, 255, 57, 9, 99, 255, 59, 9, 100, 255, 61, 9, 101, 255, 62, 9, 102, 255, 64, 10, 103, 255, 66, 10, 104, 255, 68, 10, 104, 255, 69, 10, 105, 255, 71, 11, 106, 255, 73, 11, 106, 255, 74, 12, 107, 255, 76, 12, 107, 255, 77, 13, 108, 255, 79, 13, 108, 255, 81, 14, 108, 255, 82, 14, 109, 255, 84, 15, 109, 255, 85, 15, 109, 255, 87, 16, 110, 255, 89, 16, 110, 255, 90, 17, 110, 255, 92, 18, 110, 255, 93, 18, 110, 255, 95, 19, 110, 255, 97, 19, 110, 255, 98, 20, 110, 255, 100, 21, 110, 255, 101, 21, 110, 255, 103, 22, 110, 255, 105, 22, 110, 255, 106, 23, 110, 255, 108, 24, 110, 255, 109, 24, 110, 255, 111, 25, 110, 255, 113, 25, 110, 255, 114, 26, 110, 255, 116, 26, 110, 255, 117, 27, 110, 255, 119, 28, 109, 255, 120, 28, 109, 255, 122, 29, 109, 255, 124, 29, 109, 255, 125, 30, 109, 255, 127, 30, 108, 255, 128, 31, 108, 255, 130, 32, 108, 255, 132, 32, 107, 255, 133, 33, 107, 255, 135, 33, 107, 255, 136, 34, 106, 255, 138, 34, 106, 255, 140, 35, 105, 255, 141, 35, 105, 255, 143, 36, 105, 255, 144, 37, 104, 255, 146, 37, 104, 255, 147, 38, 103, 255, 149, 38, 103, 255, 151, 39, 102, 255, 152, 39, 102, 255, 154, 40, 101, 255, 155, 41, 100, 255, 157, 41, 100, 255, 159, 42, 99, 255, 160, 42, 99, 255, 162, 43, 98, 255, 163, 44, 97, 255, 165, 44, 96, 255, 166, 45, 96, 255, 168, 46, 95, 255, 169, 46, 94, 255, 171, 47, 94, 255, 173, 48, 93, 255, 174, 48, 92, 255, 176, 49, 91, 255, 177, 50, 90, 255, 179, 50, 90, 255, 180, 51, 89, 255, 182, 52, 88, 255, 183, 53, 87, 255, 185, 53, 86, 255, 186, 54, 85, 255, 188, 55, 84, 255, 189, 56, 83, 255, 191, 57, 82, 255, 192, 58, 81, 255, 193, 58, 80, 255, 195, 59, 79, 255, 196, 60, 78, 255, 198, 61, 77, 255, 199, 62, 76, 255, 200, 63, 75, 255, 202, 64, 74, 255, 203, 65, 73, 255, 204, 66, 72, 255, 206, 67, 71, 255, 207, 68, 70, 255, 208, 69, 69, 255, 210, 70, 68, 255, 211, 71, 67, 255, 212, 72, 66, 255, 213, 74, 65, 255, 215, 75, 63, 255, 216, 76, 62, 255, 217, 77, 61, 255, 218, 78, 60, 255, 219, 80, 59, 255, 221, 81, 58, 255, 222, 82, 56, 255, 223, 83, 55, 255, 224, 85, 54, 255, 225, 86, 53, 255, 226, 87, 52, 255, 227, 89, 51, 255, 228, 90, 49, 255, 229, 92, 48, 255, 230, 93, 47, 255, 231, 94, 46, 255, 232, 96, 45, 255, 233, 97, 43, 255, 234, 99, 42, 255, 235, 100, 41, 255, 235, 102, 40, 255, 236, 103, 38, 255, 237, 105, 37, 255, 238, 106, 36, 255, 239, 108, 35, 255, 239, 110, 33, 255, 240, 111, 32, 255, 241, 113, 31, 255, 241, 115, 29, 255, 242, 116, 28, 255, 243, 118, 27, 255, 243, 120, 25, 255, 244, 121, 24, 255, 245, 123, 23, 255, 245, 125, 21, 255, 246, 126, 20, 255, 246, 128, 19, 255, 247, 130, 18, 255, 247, 132, 16, 255, 248, 133, 15, 255, 248, 135, 14, 255, 248, 137, 12, 255, 249, 139, 11, 255, 249, 140, 10, 255, 249, 142, 9, 255, 250, 144, 8, 255, 250, 146, 7, 255, 250, 148, 7, 255, 251, 150, 6, 255, 251, 151, 6, 255, 251, 153, 6, 255, 251, 155, 6, 255, 251, 157, 7, 255, 252, 159, 7, 255, 252, 161, 8, 255, 252, 163, 9, 255, 252, 165, 10, 255, 252, 166, 12, 255, 252, 168, 13, 255, 252, 170, 15, 255, 252, 172, 17, 255, 252, 174, 18, 255, 252, 176, 20, 255, 252, 178, 22, 255, 252, 180, 24, 255, 251, 182, 26, 255, 251, 184, 29, 255, 251, 186, 31, 255, 251, 188, 33, 255, 251, 190, 35, 255, 250, 192, 38, 255, 250, 194, 40, 255, 250, 196, 42, 255, 250, 198, 45, 255, 249, 199, 47, 255, 249, 201, 50, 255, 249, 203, 53, 255, 248, 205, 55, 255, 248, 207, 58, 255, 247, 209, 61, 255, 247, 211, 64, 255, 246, 213, 67, 255, 246, 215, 70, 255, 245, 217, 73, 255, 245, 219, 76, 255, 244, 221, 79, 255, 244, 223, 83, 255, 244, 225, 86, 255, 243, 227, 90, 255, 243, 229, 93, 255, 242, 230, 97, 255, 242, 232, 101, 255, 242, 234, 105, 255, 241, 236, 109, 255, 241, 237, 113, 255, 241, 239, 117, 255, 241, 241, 121, 255, 242, 242, 125, 255, 242, 244, 130, 255, 243, 245, 134, 255, 243, 246, 138, 255, 244, 248, 142, 255, 245, 249, 146, 255, 246, 250, 150, 255, 248, 251, 154, 255, 249, 252, 157, 255, 250, 253, 161, 255, 252, 255, 164, 255 ]),
  rainbow: {
    colors: [ '#96005A', '#0000C8', '#0019FF', '#0098FF', '#2CFF96', '#97FF00', '#FFEA00', '#FF6F00', '#FF0000' ],
    positions: [ 0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1 ]
  },
  jet: {
    colors: [ '#000083', '#003CAA', '#05FFFF', '#FFFF00', '#FA0000', '#800000' ],
    positions: [ 0, 0.125, 0.375, 0.625, 0.875, 1 ]
  },
  hsv: {
    colors: [ '#ff0000', '#fdff02', '#f7ff02', '#00fc04', '#00fc0a', '#01f9ff', '#0200fd', '#0800fd', '#ff00fb', '#ff00f5', '#ff0006' ],
    positions: [ 0, 0.169, 0.173, 0.337, 0.341, 0.506, 0.671, 0.675, 0.839, 0.843, 1 ]
  },
  hot: {
    colors: [ '#000000', '#e60000', '#ffd200', '#ffffff' ],
    positions: [ 0, 0.3, 0.6, 1 ]
  },
  cool: {
    colors: [ '#00ffff', '#ff00ff' ],
    positions: [ 0, 1 ]
  },
  spring: {
    colors: [ '#ff00ff', '#ffff00' ],
    positions: [ 0, 1 ]
  },
  summer: {
    colors: [ '#008066', '#ffff66' ],
    positions: [ 0, 1 ]
  },
  autumn: {
    colors: [ '#ff0000', '#ffff00' ],
    positions: [ 0, 1 ]
  },
  winter: {
    colors: [ '#0000ff', '#00ff80' ],
    positions: [ 0, 1 ]
  },
  bone: {
    colors: [ '#000000', '#545474', '#a9c8c8', '#ffffff' ],
    positions: [ 0, 0.376, 0.753, 1 ]
  },
  copper: {
    colors: [ '#000000', '#ffa066', '#ffc77f' ],
    positions: [ 0, 0.804, 1 ]
  },
  greys: {
    colors: [ '#000000', '#ffffff' ],
    positions: [ 0, 1 ]
  },
  yignbu: {
    colors: [ '#081d58', '#253494', '#225ea8', '#1d91c0', '#41b6c4', '#7fcdbb', '#c7e9b4', '#edf8d9', '#ffffd9' ],
    positions: [ 0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1 ]
  },
  greens: {
    colors: [ '#00441b', '#006d2c', '#238b45', '#41ab5d', '#74c476', '#a1d99b', '#c7e9c0', '#e5f5e0', '#f7fcf5' ],
    positions: [ 0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1 ]
  },
  wind: {
    colors: [ '#3288bd', '#66c2a5', '#abdda4', '#e6f598', '#fee08b', '#fdae61', '#f46d43', '#d53e4f' ],
    positions: [ 0, 0.1, 0.2, 0.6, 0.7, 0.8, 0.9, 1 ]
  },
  yiorrd: {
    colors: [ '#800026', '#bd0026', '#e31a1c', '#fc4e2a', '#fd8d3c', '#feb24c', '#fed976', '#ffeda0', '#ffffcc' ],
    positions: [ 0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1 ]
  },
  bluered: {
    colors: [ '#0000ff', '#ff0000' ],
    positions: [ 0, 1 ]
  },
  rdbu: {
    colors: [ '#050aac', '#6a89f7', '#bebebe', '#dcaa84', '#e6915a', '#b20a1c' ],
    positions: [ 0, 0.35, 0.5, 0.6, 0.7, 1 ]
  },
  picnic: {
    colors: [ '#0000ff', '#3399ff', '#66ccff', '#99ccff', '#ccccff', '#ffffff', '#ffccff', '#ff99ff', '#ff66cc', '#ff6666', '#ff0000' ],
    positions: [ 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1 ]
  },
  portland: {
    colors: [ '#0c3383', '#0a88ba', '#f2d338', '#f28f38', '#d91e1e' ],
    positions: [ 0, 0.25, 0.5, 0.75, 1 ]
  },
  blackbody: {
    colors: [ '#000000', '#e60000', '#e6d200', '#ffffff', '#a0c8ff' ],
    positions: [ 0, 0.2, 0.4, 0.7, 1 ]
  },
  earth: {
    colors: [ '#000082', '#00b4b4', '#28d228', '#e6e632', '#784614', '#ffffff' ],
    positions: [ 0, 0.1, 0.2, 0.4, 0.6, 1 ]
  },
  electric: {
    colors: [ '#000000', '#1e0064', '#780064', '#a05a00', '#e6c800', '#fffadc' ],
    positions: [ 0, 0.15, 0.4, 0.6, 0.8, 1 ]
  },
  magma: new Uint8Array([ 0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 9, 255, 2, 2, 11, 255, 2, 2, 13, 255, 3, 3, 15, 255, 3, 3, 18, 255, 4, 4, 20, 255, 5, 4, 22, 255, 6, 5, 24, 255, 6, 5, 26, 255, 7, 6, 28, 255, 8, 7, 30, 255, 9, 7, 32, 255, 10, 8, 34, 255, 11, 9, 36, 255, 12, 9, 38, 255, 13, 10, 41, 255, 14, 11, 43, 255, 16, 11, 45, 255, 17, 12, 47, 255, 18, 13, 49, 255, 19, 13, 52, 255, 20, 14, 54, 255, 21, 14, 56, 255, 22, 15, 59, 255, 24, 15, 61, 255, 25, 16, 63, 255, 26, 16, 66, 255, 28, 16, 68, 255, 29, 17, 71, 255, 30, 17, 73, 255, 32, 17, 75, 255, 33, 17, 78, 255, 34, 17, 80, 255, 36, 18, 83, 255, 37, 18, 85, 255, 39, 18, 88, 255, 41, 17, 90, 255, 42, 17, 92, 255, 44, 17, 95, 255, 45, 17, 97, 255, 47, 17, 99, 255, 49, 17, 101, 255, 51, 16, 103, 255, 52, 16, 105, 255, 54, 16, 107, 255, 56, 16, 108, 255, 57, 15, 110, 255, 59, 15, 112, 255, 61, 15, 113, 255, 63, 15, 114, 255, 64, 15, 116, 255, 66, 15, 117, 255, 68, 15, 118, 255, 69, 16, 119, 255, 71, 16, 120, 255, 73, 16, 120, 255, 74, 16, 121, 255, 76, 17, 122, 255, 78, 17, 123, 255, 79, 18, 123, 255, 81, 18, 124, 255, 82, 19, 124, 255, 84, 19, 125, 255, 86, 20, 125, 255, 87, 21, 126, 255, 89, 21, 126, 255, 90, 22, 126, 255, 92, 22, 127, 255, 93, 23, 127, 255, 95, 24, 127, 255, 96, 24, 128, 255, 98, 25, 128, 255, 100, 26, 128, 255, 101, 26, 128, 255, 103, 27, 128, 255, 104, 28, 129, 255, 106, 28, 129, 255, 107, 29, 129, 255, 109, 29, 129, 255, 110, 30, 129, 255, 112, 31, 129, 255, 114, 31, 129, 255, 115, 32, 129, 255, 117, 33, 129, 255, 118, 33, 129, 255, 120, 34, 129, 255, 121, 34, 130, 255, 123, 35, 130, 255, 124, 35, 130, 255, 126, 36, 130, 255, 128, 37, 130, 255, 129, 37, 129, 255, 131, 38, 129, 255, 132, 38, 129, 255, 134, 39, 129, 255, 136, 39, 129, 255, 137, 40, 129, 255, 139, 41, 129, 255, 140, 41, 129, 255, 142, 42, 129, 255, 144, 42, 129, 255, 145, 43, 129, 255, 147, 43, 128, 255, 148, 44, 128, 255, 150, 44, 128, 255, 152, 45, 128, 255, 153, 45, 128, 255, 155, 46, 127, 255, 156, 46, 127, 255, 158, 47, 127, 255, 160, 47, 127, 255, 161, 48, 126, 255, 163, 48, 126, 255, 165, 49, 126, 255, 166, 49, 125, 255, 168, 50, 125, 255, 170, 51, 125, 255, 171, 51, 124, 255, 173, 52, 124, 255, 174, 52, 123, 255, 176, 53, 123, 255, 178, 53, 123, 255, 179, 54, 122, 255, 181, 54, 122, 255, 183, 55, 121, 255, 184, 55, 121, 255, 186, 56, 120, 255, 188, 57, 120, 255, 189, 57, 119, 255, 191, 58, 119, 255, 192, 58, 118, 255, 194, 59, 117, 255, 196, 60, 117, 255, 197, 60, 116, 255, 199, 61, 115, 255, 200, 62, 115, 255, 202, 62, 114, 255, 204, 63, 113, 255, 205, 64, 113, 255, 207, 64, 112, 255, 208, 65, 111, 255, 210, 66, 111, 255, 211, 67, 110, 255, 213, 68, 109, 255, 214, 69, 108, 255, 216, 69, 108, 255, 217, 70, 107, 255, 219, 71, 106, 255, 220, 72, 105, 255, 222, 73, 104, 255, 223, 74, 104, 255, 224, 76, 103, 255, 226, 77, 102, 255, 227, 78, 101, 255, 228, 79, 100, 255, 229, 80, 100, 255, 231, 82, 99, 255, 232, 83, 98, 255, 233, 84, 98, 255, 234, 86, 97, 255, 235, 87, 96, 255, 236, 88, 96, 255, 237, 90, 95, 255, 238, 91, 94, 255, 239, 93, 94, 255, 240, 95, 94, 255, 241, 96, 93, 255, 242, 98, 93, 255, 242, 100, 92, 255, 243, 101, 92, 255, 244, 103, 92, 255, 244, 105, 92, 255, 245, 107, 92, 255, 246, 108, 92, 255, 246, 110, 92, 255, 247, 112, 92, 255, 247, 114, 92, 255, 248, 116, 92, 255, 248, 118, 92, 255, 249, 120, 93, 255, 249, 121, 93, 255, 249, 123, 93, 255, 250, 125, 94, 255, 250, 127, 94, 255, 250, 129, 95, 255, 251, 131, 95, 255, 251, 133, 96, 255, 251, 135, 97, 255, 252, 137, 97, 255, 252, 138, 98, 255, 252, 140, 99, 255, 252, 142, 100, 255, 252, 144, 101, 255, 253, 146, 102, 255, 253, 148, 103, 255, 253, 150, 104, 255, 253, 152, 105, 255, 253, 154, 106, 255, 253, 155, 107, 255, 254, 157, 108, 255, 254, 159, 109, 255, 254, 161, 110, 255, 254, 163, 111, 255, 254, 165, 113, 255, 254, 167, 114, 255, 254, 169, 115, 255, 254, 170, 116, 255, 254, 172, 118, 255, 254, 174, 119, 255, 254, 176, 120, 255, 254, 178, 122, 255, 254, 180, 123, 255, 254, 182, 124, 255, 254, 183, 126, 255, 254, 185, 127, 255, 254, 187, 129, 255, 254, 189, 130, 255, 254, 191, 132, 255, 254, 193, 133, 255, 254, 194, 135, 255, 254, 196, 136, 255, 254, 198, 138, 255, 254, 200, 140, 255, 254, 202, 141, 255, 254, 204, 143, 255, 254, 205, 144, 255, 254, 207, 146, 255, 254, 209, 148, 255, 254, 211, 149, 255, 254, 213, 151, 255, 254, 215, 153, 255, 254, 216, 154, 255, 253, 218, 156, 255, 253, 220, 158, 255, 253, 222, 160, 255, 253, 224, 161, 255, 253, 226, 163, 255, 253, 227, 165, 255, 253, 229, 167, 255, 253, 231, 169, 255, 253, 233, 170, 255, 253, 235, 172, 255, 252, 236, 174, 255, 252, 238, 176, 255, 252, 240, 178, 255, 252, 242, 180, 255, 252, 244, 182, 255, 252, 246, 184, 255, 252, 247, 185, 255, 252, 249, 187, 255, 252, 251, 189, 255, 252, 253, 191, 255 ]),
  plasma: new Uint8Array([ 13, 8, 135, 255, 16, 7, 136, 255, 19, 7, 137, 255, 22, 7, 138, 255, 25, 6, 140, 255, 27, 6, 141, 255, 29, 6, 142, 255, 32, 6, 143, 255, 34, 6, 144, 255, 36, 6, 145, 255, 38, 5, 145, 255, 40, 5, 146, 255, 42, 5, 147, 255, 44, 5, 148, 255, 46, 5, 149, 255, 47, 5, 150, 255, 49, 5, 151, 255, 51, 5, 151, 255, 53, 4, 152, 255, 55, 4, 153, 255, 56, 4, 154, 255, 58, 4, 154, 255, 60, 4, 155, 255, 62, 4, 156, 255, 63, 4, 156, 255, 65, 4, 157, 255, 67, 3, 158, 255, 68, 3, 158, 255, 70, 3, 159, 255, 72, 3, 159, 255, 73, 3, 160, 255, 75, 3, 161, 255, 76, 2, 161, 255, 78, 2, 162, 255, 80, 2, 162, 255, 81, 2, 163, 255, 83, 2, 163, 255, 85, 2, 164, 255, 86, 1, 164, 255, 88, 1, 164, 255, 89, 1, 165, 255, 91, 1, 165, 255, 92, 1, 166, 255, 94, 1, 166, 255, 96, 1, 166, 255, 97, 0, 167, 255, 99, 0, 167, 255, 100, 0, 167, 255, 102, 0, 167, 255, 103, 0, 168, 255, 105, 0, 168, 255, 106, 0, 168, 255, 108, 0, 168, 255, 110, 0, 168, 255, 111, 0, 168, 255, 113, 0, 168, 255, 114, 1, 168, 255, 116, 1, 168, 255, 117, 1, 168, 255, 119, 1, 168, 255, 120, 1, 168, 255, 122, 2, 168, 255, 123, 2, 168, 255, 125, 3, 168, 255, 126, 3, 168, 255, 128, 4, 168, 255, 129, 4, 167, 255, 131, 5, 167, 255, 132, 5, 167, 255, 134, 6, 166, 255, 135, 7, 166, 255, 136, 8, 166, 255, 138, 9, 165, 255, 139, 10, 165, 255, 141, 11, 165, 255, 142, 12, 164, 255, 143, 13, 164, 255, 145, 14, 163, 255, 146, 15, 163, 255, 148, 16, 162, 255, 149, 17, 161, 255, 150, 19, 161, 255, 152, 20, 160, 255, 153, 21, 159, 255, 154, 22, 159, 255, 156, 23, 158, 255, 157, 24, 157, 255, 158, 25, 157, 255, 160, 26, 156, 255, 161, 27, 155, 255, 162, 29, 154, 255, 163, 30, 154, 255, 165, 31, 153, 255, 166, 32, 152, 255, 167, 33, 151, 255, 168, 34, 150, 255, 170, 35, 149, 255, 171, 36, 148, 255, 172, 38, 148, 255, 173, 39, 147, 255, 174, 40, 146, 255, 176, 41, 145, 255, 177, 42, 144, 255, 178, 43, 143, 255, 179, 44, 142, 255, 180, 46, 141, 255, 181, 47, 140, 255, 182, 48, 139, 255, 183, 49, 138, 255, 184, 50, 137, 255, 186, 51, 136, 255, 187, 52, 136, 255, 188, 53, 135, 255, 189, 55, 134, 255, 190, 56, 133, 255, 191, 57, 132, 255, 192, 58, 131, 255, 193, 59, 130, 255, 194, 60, 129, 255, 195, 61, 128, 255, 196, 62, 127, 255, 197, 64, 126, 255, 198, 65, 125, 255, 199, 66, 124, 255, 200, 67, 123, 255, 201, 68, 122, 255, 202, 69, 122, 255, 203, 70, 121, 255, 204, 71, 120, 255, 204, 73, 119, 255, 205, 74, 118, 255, 206, 75, 117, 255, 207, 76, 116, 255, 208, 77, 115, 255, 209, 78, 114, 255, 210, 79, 113, 255, 211, 81, 113, 255, 212, 82, 112, 255, 213, 83, 111, 255, 213, 84, 110, 255, 214, 85, 109, 255, 215, 86, 108, 255, 216, 87, 107, 255, 217, 88, 106, 255, 218, 90, 106, 255, 218, 91, 105, 255, 219, 92, 104, 255, 220, 93, 103, 255, 221, 94, 102, 255, 222, 95, 101, 255, 222, 97, 100, 255, 223, 98, 99, 255, 224, 99, 99, 255, 225, 100, 98, 255, 226, 101, 97, 255, 226, 102, 96, 255, 227, 104, 95, 255, 228, 105, 94, 255, 229, 106, 93, 255, 229, 107, 93, 255, 230, 108, 92, 255, 231, 110, 91, 255, 231, 111, 90, 255, 232, 112, 89, 255, 233, 113, 88, 255, 233, 114, 87, 255, 234, 116, 87, 255, 235, 117, 86, 255, 235, 118, 85, 255, 236, 119, 84, 255, 237, 121, 83, 255, 237, 122, 82, 255, 238, 123, 81, 255, 239, 124, 81, 255, 239, 126, 80, 255, 240, 127, 79, 255, 240, 128, 78, 255, 241, 129, 77, 255, 241, 131, 76, 255, 242, 132, 75, 255, 243, 133, 75, 255, 243, 135, 74, 255, 244, 136, 73, 255, 244, 137, 72, 255, 245, 139, 71, 255, 245, 140, 70, 255, 246, 141, 69, 255, 246, 143, 68, 255, 247, 144, 68, 255, 247, 145, 67, 255, 247, 147, 66, 255, 248, 148, 65, 255, 248, 149, 64, 255, 249, 151, 63, 255, 249, 152, 62, 255, 249, 154, 62, 255, 250, 155, 61, 255, 250, 156, 60, 255, 250, 158, 59, 255, 251, 159, 58, 255, 251, 161, 57, 255, 251, 162, 56, 255, 252, 163, 56, 255, 252, 165, 55, 255, 252, 166, 54, 255, 252, 168, 53, 255, 252, 169, 52, 255, 253, 171, 51, 255, 253, 172, 51, 255, 253, 174, 50, 255, 253, 175, 49, 255, 253, 177, 48, 255, 253, 178, 47, 255, 253, 180, 47, 255, 253, 181, 46, 255, 254, 183, 45, 255, 254, 184, 44, 255, 254, 186, 44, 255, 254, 187, 43, 255, 254, 189, 42, 255, 254, 190, 42, 255, 254, 192, 41, 255, 253, 194, 41, 255, 253, 195, 40, 255, 253, 197, 39, 255, 253, 198, 39, 255, 253, 200, 39, 255, 253, 202, 38, 255, 253, 203, 38, 255, 252, 205, 37, 255, 252, 206, 37, 255, 252, 208, 37, 255, 252, 210, 37, 255, 251, 211, 36, 255, 251, 213, 36, 255, 251, 215, 36, 255, 250, 216, 36, 255, 250, 218, 36, 255, 249, 220, 36, 255, 249, 221, 37, 255, 248, 223, 37, 255, 248, 225, 37, 255, 247, 226, 37, 255, 247, 228, 37, 255, 246, 230, 38, 255, 246, 232, 38, 255, 245, 233, 38, 255, 245, 235, 39, 255, 244, 237, 39, 255, 243, 238, 39, 255, 243, 240, 39, 255, 242, 242, 39, 255, 241, 244, 38, 255, 241, 245, 37, 255, 240, 247, 36, 255, 240, 249, 33, 255 ])
};
// export default colorScales;

// import BufferBase from '../bufferBase';

var HeatmapBuffer = /*@__PURE__*/(function (Base) {
  function HeatmapBuffer(cfg) {
    Base.call(this, cfg);
    this.init();
  }

  if ( Base ) HeatmapBuffer.__proto__ = Base;
  HeatmapBuffer.prototype = Object.create( Base && Base.prototype );
  HeatmapBuffer.prototype.constructor = HeatmapBuffer;
  HeatmapBuffer.prototype.init = function init () {
    var this$1 = this;

    var data = this.get('data');
    var positions = [];
    var dirs = [];
    var weights = [];
    // const indices = [];

    // 组织顶点数据
    data.forEach(function (d) {
      // const totalIndex = index * 4;
      var coord = d.coordinates;
      var weight = d.size;
      var dir = this$1._addDir(-1, 1);
      var dir1 = this$1._addDir(1, 1);
      var dir2 = this$1._addDir(-1, -1);
      var dir3 = this$1._addDir(1, -1);
      positions.push.apply(positions, coord.concat( coord, coord, coord, coord, coord ));
      dirs.push.apply(dirs, dir.concat( dir2, dir3, dir1, dir, dir3 ));
      weights.push(weight, weight, weight, weight, weight, weight);
      // indices.push(totalIndex, totalIndex + 2, totalIndex + 3, totalIndex, totalIndex + 3, totalIndex + 1);
    });

    this.attributes = {
      vertices: positions,
      // indices,
      dirs: dirs,
      weights: weights
    };
  };

  HeatmapBuffer.prototype._addVertex = function _addVertex (position, dirX, dirY) {
    var x = (position[0] * 2) + ((dirX + 1) / 2);
    var y = (position[1] * 2) + ((dirY + 1) / 2);
    var z = position[2];
    return [ x, y, z ];
  };

  HeatmapBuffer.prototype._addDir = function _addDir (dirX, dirY) {
    var x = (dirX + 1) / 2;
    var y = (dirY + 1) / 2;
    return [ x, y ];
  };

  return HeatmapBuffer;
}(actor.Base));

function createColorRamp(colors) {
  var colorImageData = getColorRamp(colors);
  var colorTexture = getTexture(colorImageData);
  return colorTexture;
}

function getColorRamp(name) {
  var colorscale = name;
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');

  canvas.width = 1;
  canvas.height = 256;
  var gradient = ctx.createLinearGradient(0, 0, 0, 256);
  var data = null;
  if (typeof (colorscale) === 'string') {
    colorscale = colorScales[name];
  }
  if (Object.prototype.toString.call(colorscale) === '[object Object]') {
    var min = colorscale.positions[0];
    var max = colorscale.positions[colorscale.positions.length - 1];

    for (var i = 0; i < colorscale.colors.length; ++i) {
      var value = (colorscale.positions[i] - min) / (max - min);
      gradient.addColorStop(value, colorscale.colors[i]);
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1, 256);
    data = new Uint8ClampedArray(ctx.getImageData(0, 0, 1, 256).data);
  }
  if (Object.prototype.toString.call(colorscale) === '[object Uint8Array]') {
    data = ctx.createImageData(1, 256);
  }

  return new ImageData(data, 1, 256);

}

function getTexture(image) {
  var texture = new actor.Texture(image);
  texture.wrapS = actor.ClampToEdgeWrapping;
  texture.wrapT = actor.ClampToEdgeWrapping;
  texture.magFilter = actor.NearestFilter;
  texture.minFilter = actor.NearestFilter;
  texture.format = actor.RGBAFormat;
  texture.type = actor.UnsignedByteType;
  texture.needsUpdate = true;
  return texture;
}

var HeatmapColorizeMaterial = /*@__PURE__*/(function (Material) {
  function HeatmapColorizeMaterial(_uniforms, _defines, parameters) {
    if ( _defines === void 0 ) _defines = {};

    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var uniforms = ref.uniforms;
    var defines = ref.defines;
    var ref$1 = getModule('heatmap_color');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    this.uniforms = Object.assign(uniforms, this.setUniform(_uniforms));
    this.type = 'HeatmapColorizeMaterial';
    this.defines = Object.assign(defines, _defines);
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) HeatmapColorizeMaterial.__proto__ = Material;
  HeatmapColorizeMaterial.prototype = Object.create( Material && Material.prototype );
  HeatmapColorizeMaterial.prototype.constructor = HeatmapColorizeMaterial;

  HeatmapColorizeMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_intensity: { value: 1.0 },
        u_texture: { value: null },
        u_rampColors: { value: 0 },
        u_opacity: { value: 1 }
      },
      defines: {

      }
    };
  };

  return HeatmapColorizeMaterial;
}(Material));

var HeatmapIntensityMaterial = /*@__PURE__*/(function (Material) {
  function HeatmapIntensityMaterial(_uniforms, _defines, parameters) {
    if ( _defines === void 0 ) _defines = {};

    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var uniforms = ref.uniforms;
    var defines = ref.defines;
    var ref$1 = getModule('heatmap_intensity');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    this.uniforms = Object.assign(uniforms, this.setUniform(_uniforms));
    this.type = 'heatmap_intensity';
    this.defines = Object.assign(defines, _defines);
    this.vertexShader = vs;
    this.blending = actor.AdditiveBlending;
    this.fragmentShader = fs;
    this.depthTest = false;
    this.transparent = true;
  }

  if ( Material ) HeatmapIntensityMaterial.__proto__ = Material;
  HeatmapIntensityMaterial.prototype = Object.create( Material && Material.prototype );
  HeatmapIntensityMaterial.prototype.constructor = HeatmapIntensityMaterial;

  HeatmapIntensityMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
        u_intensity: { value: 10.0 },
        u_zoom: { value: 4 },
        u_radius: { value: 10 }
      },
      defines: {

      }
    };
  };

  return HeatmapIntensityMaterial;
}(Material));

// jscs:disable

/**
 * @author alteredq / http://alteredqualia.com/
 */

var RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new actor.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = false;
	this.needsSwap = false;

};

RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

    this.scene.overrideMaterial = this.overrideMaterial;
		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

    renderer.render( this.scene, this.camera, readBuffer, this.clear );


		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

    this.scene.overrideMaterial = null;

	}

};

// jscs:disable

/**
 * @author alteredq / http://alteredqualia.com/
 */

var ShaderPass = function( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	if ( shader instanceof actor.ShaderMaterial ) {

		this.uniforms = shader.uniforms;

		this.material = shader;

	}
	else if ( shader ) {

		this.uniforms = actor.UniformsUtils.clone( shader.uniforms );

		this.material = new actor.ShaderMaterial( {

			defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

	}

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = true;


	this.camera = new actor.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene = new actor.Scene();

	this.quad = new actor.Mesh( new actor.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

ShaderPass.prototype = {

	render: function( renderer, writeBuffer, readBuffer, delta ) {
		if ( this.uniforms[ this.textureID ] ) {
			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}
    renderer.autoClear = false;
		this.quad.material = this.material;

		if ( this.renderToScreen ) {
			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}
		renderer.autoClear = true;
	}

};

// jscs:disable

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

var CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join( "\n" )

};

// jscs:disable

/**
 * @author alteredq / http://alteredqualia.com/
 */

var MaskPass = function ( scene, camera ) {

	this.scene = scene;
	this.camera = camera;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

MaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


var ClearMaskPass = function () {

	this.enabled = true;

};

ClearMaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};

// jscs:disable

/**
 * @author alteredq / http://alteredqualia.com/
 */

var EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var pixelRatio = renderer.getPixelRatio();

		var width  = Math.floor( renderer.context.canvas.width  / pixelRatio ) || 1;
		var height = Math.floor( renderer.context.canvas.height / pixelRatio ) || 1;
		var parameters = { minFilter: actor.LinearFilter, magFilter: actor.LinearFilter, format: actor.RGBAFormat, stencilBuffer: false };

		renderTarget = new actor.WebGLRenderTarget( width, height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( CopyShader === undefined )
		{ console.error( "EffectComposer relies on THREE.CopyShader" ); }

	this.copyPass = new ShaderPass( CopyShader );

};

EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},
	visible:true,
	type:'composer',
	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;
		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( ! pass.enabled ) { continue; }

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			renderTarget = this.renderTarget1.clone();

			var pixelRatio = this.renderer.getPixelRatio();

			renderTarget.setSize(
				Math.floor( this.renderer.context.canvas.width  / pixelRatio ),
				Math.floor( this.renderer.context.canvas.height / pixelRatio )
			);

		}

		this.renderTarget1.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2.dispose();
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		this.renderTarget1.setSize( width, height );
		this.renderTarget2.setSize( width, height );

	},
	destory: function () {
		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
	}

};

function EffectComposer$1(renderer, container) {
  var composer = new EffectComposer(renderer);

  var updateSize = function() {
    // TODO: Re-enable this when perf issues can be solved
    //
    // Rendering double the resolution of the screen can be really slow
    // var pixelRatio = window.devicePixelRatio;
    var pixelRatio = 1;

    composer.setSize(container.clientWidth * pixelRatio, container.clientHeight * pixelRatio);
  };

  window.addEventListener('resize', updateSize, false);
  updateSize();

  return composer;
}

function DrawHeatmap(layerdata, layer) {

  var colors = layer.get('styleOptions').rampColors;

  layer.rampColors = createColorRamp(colors);
  var heatmap = new heatmapPass(layerdata, layer);
  var copy = new copyPass(layer);
  copy.renderToScreen = true;
  var composer = new EffectComposer$1(layer.scene._engine._renderer, layer.scene._container);
  composer.addPass(heatmap);
  composer.addPass(copy);
  layer.scene._engine.update();
  layer._updateStyle = function (style) {
    if (style.rampColors) {
      style.rampColors = createColorRamp(style.rampColors);
    }
    var newOption = { };
    for (var key in style) {
      newOption['u_' + key] = style[key];
    }
    heatmap.scene.children[0].material.updateUninform(newOption);
    copy.scene.children[0].material.updateUninform(newOption);
  };
  return composer;

}

function heatmapPass(layerdata, layer) {
  var scene = new actor.Scene();
  var style = layer.get('styleOptions');
  var data = layerdata;
  var camera = layer.scene._engine._camera;
  // get attributes data
  var buffer = new HeatmapBuffer({
    data: data
  });
  var attributes = buffer.attributes;
  // create geometery
  var geometry = new actor.BufferGeometry();
  // geometry.setIndex(attributes.indices);
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.vertices, 3));
  geometry.addAttribute('a_dir', new actor.Float32BufferAttribute(attributes.dirs, 2));
  geometry.addAttribute('a_weight', new actor.Float32BufferAttribute(attributes.weights, 1));
  var material = new HeatmapIntensityMaterial({
    u_intensity: style.intensity,
    u_radius: style.radius,
    u_zoom: layer.scene.getZoom()
  }, {});
  var mesh = new actor.Mesh(geometry, material);
  scene.add(mesh);
  scene.onBeforeRender = function () { // 每次渲染前改变状态
    var zoom = layer.scene.getZoom();
    mesh.material.setUniformsValue('u_zoom', zoom);
  };
  var pass = new RenderPass(scene, camera);
  return pass;
}
function copyPass(layer) {
  var style = layer.get('styleOptions');
  var material = new HeatmapColorizeMaterial({
    u_rampColors: layer.rampColors,
    u_opacity: style.opacity || 1.0
  }, {});
  var copyPass = new ShaderPass(material, 'u_texture');
  return copyPass;
}

function ImageMaterial(options) {
  var ref = getModule('image');
  var vs = ref.vs;
  var fs = ref.fs;
  var material = new Material({
    uniforms: {
      u_opacity: { value: options.u_opacity },
      u_texture: { value: options.u_texture }
    },
    vertexShader: vs,
    fragmentShader: fs,
    transparent: true,
    depthTest: false
  });
  return material;
}

function DrawImage$1(attributes, style) {
  var geometry = new actor.BufferGeometry();
  geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.vertices, 3));
  geometry.addAttribute('uv', new actor.Float32BufferAttribute(attributes.uvs, 2));
  var opacity = style.opacity;
  var material = new ImageMaterial({
    u_texture: attributes.texture,
    u_opacity: opacity
  });
  return new actor.Mesh(geometry, material);
}

registerRender('polygon', 'fill', DrawPolygonFill);
registerRender('polygon', 'extrude', DrawPolygonFill);
registerRender('polygon', 'line', DrawPolygonLine);
registerRender('polygon', 'animate', DrawAnimate);

registerRender('line', 'line', DrawLine);
registerRender('line', 'arc', DrawArcLine);
registerRender('line', 'greatCircle', DrawArcLine);

// registerRender('point', 'fill', DrawPointFill);
registerRender('point', 'image', DrawImage);
registerRender('point', 'normal', DrawNormal);
registerRender('point', 'stroke', DrawStroke);
registerRender('point', 'text', DrawText);
registerRender('point', 'fill', drawCircle);
registerRender('point', 'shape', Draw3DShape);
registerRender('point', 'extrude', Draw3DShape);


registerRender('heatmap', 'square', DrawGrid);
registerRender('heatmap', 'squareColumn', DrawGrid);
registerRender('heatmap', 'heatmap', DrawHeatmap);
registerRender('heatmap', 'shape', DrawHexagon);

registerRender('image', 'image', DrawImage$1);

// image

registerRender('text', 'text', DrawText);

var PolygonLayer = /*@__PURE__*/(function (Layer) {
  function PolygonLayer(scene, cfg) {
    Layer.call(this, scene, cfg);
    this.set('type', 'polygon');
  }

  if ( Layer ) PolygonLayer.__proto__ = Layer;
  PolygonLayer.prototype = Object.create( Layer && Layer.prototype );
  PolygonLayer.prototype.constructor = PolygonLayer;
  PolygonLayer.prototype.shape = function shape (type) {
    this.shape = type;
    this.set('shape', type);
    this.set('shapeType', 'polygon');
    return this;
  };
  PolygonLayer.prototype.draw = function draw () {
    // this.init();
    this.type = 'polygon';
    var animateOptions = this.get('animateOptions');
    if (animateOptions.enable) {
      this.shape = 'animate';
    }
    this.add(getRender(this.type, this.shape)(this.layerData, this));
  };
  PolygonLayer.prototype.update = function update () {
    this.updateFilter(this.layerMesh);
  };

  return PolygonLayer;
}(Layer));
PolygonLayer.type = 'polygon';

var pointShape$1 = actor.Global.pointShape;
/**
 * point shape 2d circle, traingle text,image
 * shape 3d   cube，column, sphere
 * shape Model ,自定义
 * image
 */

var PointLayer = /*@__PURE__*/(function (Layer) {
  function PointLayer(scene, cfg) {
    Layer.call(this, scene, cfg);
    this.set('type', 'point');
  }

  if ( Layer ) PointLayer.__proto__ = Layer;
  PointLayer.prototype = Object.create( Layer && Layer.prototype );
  PointLayer.prototype.constructor = PointLayer;
  PointLayer.prototype.draw = function draw () {
    this.type = 'point';
    this.shapeType = this._getShape();
    var mesh = getRender(this.type, this.shapeType)(this.layerData, this);
    this.add(mesh);
  };

  PointLayer.prototype._getShape = function _getShape () {
    var shape = null;
    if (!this.layerData[0].hasOwnProperty('shape')) {
      return 'normal';
    }
    for (var i = 0; i < this.layerData.length; i++) {
      shape = this.layerData[i].shape;
      if (shape !== undefined) {
        break;
      }
    }

    // 2D circle 特殊处理
    if (pointShape$1['2d'].indexOf(shape) !== -1) {
      return 'fill';
    } else if (pointShape$1['3d'].indexOf(shape) !== -1) {
      return 'extrude';
    } else if (this.scene.image.imagesIds.indexOf(shape) !== -1) {
      return 'image';
    }
    return 'text';
  };
  PointLayer.prototype.zoomchange = function zoomchange (ev) {
    var this$1 = this;

    Layer.prototype.zoomchange.call(this, ev);
    requestAnimationFrame(function () {
      this$1._updateData();
    });
  };
  PointLayer.prototype.dragend = function dragend (ev) {
    var this$1 = this;

    Layer.prototype.dragend.call(this, ev);
    requestAnimationFrame(function () {
      this$1._updateData();
    });

  };
  PointLayer.prototype._updateData = function _updateData () {
    if (this.layerSource.get('isCluster')) {
      var bounds = this.scene.getBounds().toBounds();
      var SW = bounds.getSouthWest();
      var NE = bounds.getNorthEast();
      var zoom = this.scene.getZoom();
      var step = Math.max(NE.lng - SW.lng, NE.lat - SW.lat) / 2;
      var bbox = [ SW.lng, SW.lat, NE.lng, NE.lat ];
      // const bbox = [ SW.lng - step, SW.lat - step, NE.lng + step, NE.lat + step ];
      var cfg = this.layerSource.get('cluster');
      var preBox = cfg.bbox;
      var preZoom = cfg.zoom;
      if (!(preBox && preBox[0] < bbox[0] && preBox[1] < bbox[1] && preBox[2] > bbox[2] && preBox[3] < bbox[3] && // 当前范围在范围内
         (Math.abs(zoom - preZoom)) < 0.5)) {
        var newbbox = [ SW.lng - step, SW.lat - step, NE.lng + step, NE.lat + step ];
        this.layerSource.updateCusterData(Math.floor(zoom - 1), newbbox);
        this.repaint();
      }
    }
  };

  return PointLayer;
}(Layer));
PointLayer.type = 'point';

var LineLayer = /*@__PURE__*/(function (Layer) {
  function LineLayer(scene, cfg) {
    Layer.call(this, scene, cfg);
    this.set('type', 'line');
  }

  if ( Layer ) LineLayer.__proto__ = Layer;
  LineLayer.prototype = Object.create( Layer && Layer.prototype );
  LineLayer.prototype.constructor = LineLayer;
  LineLayer.prototype.shape = function shape (field, values) {
    Layer.prototype.shape.call(this, field, values);
    this.shapeType = field;
    this.set('shape', field);
    return this;
  };
  LineLayer.prototype.preRender = function preRender () {
    if (
      this.animateDuration > 0 &&
      this.animateDuration < this.scene._engine.clock.getElapsedTime()
    ) {
      this.layerMesh.material.setDefinesvalue('ANIMATE', false);
      this.emit('animateEnd');
      this.scene.stopAnimate();
      this.animateDuration = Infinity;
    }
  };
  LineLayer.prototype.draw = function draw () {
    this.type = 'line';
    this.add(getRender('line', this.shapeType || 'line')(this.layerData, this));
  };

  return LineLayer;
}(Layer));
LineLayer.type = 'line';

// import BufferBase from './bufferBase';
var ImageBuffer$1 = /*@__PURE__*/(function (Base) {
  function ImageBuffer(cfg) {
    Base.call(this, cfg);
    this.init();
  }

  if ( Base ) ImageBuffer.__proto__ = Base;
  ImageBuffer.prototype = Object.create( Base && Base.prototype );
  ImageBuffer.prototype.constructor = ImageBuffer;
  ImageBuffer.prototype.init = function init () {
    var this$1 = this;

    var layerData = this.get('layerData');
    var coordinates = layerData[0].coordinates;
    var images = layerData[0].images;
    var positions = ( coordinates[0] ).concat( [coordinates[1][0]], [coordinates[0][1]], [0],
      coordinates[1],
      coordinates[0],
      coordinates[1],
      [coordinates[0][0]], [coordinates[1][1]], [0]
    );
    var image = images;
    if (actor.Util.isArray(images)) {
      image = images[0];
      var textures = images.map(function (img) { return this$1._getTexture(img); });
      this.u_rasters = textures;
    }
    var uv = [ 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0 ];
    var texture = new actor.Texture(image);
    texture.magFilter = actor.LinearFilter;
    texture.minFilter = actor.LinearMipMapLinearFilter;
    texture.needsUpdate = true;
    var attributes = {
      vertices: new Float32Array(positions),
      uvs: new Float32Array(uv)
    };
    this.attributes = attributes;
    this.texture = texture;

  };
  ImageBuffer.prototype._getTexture = function _getTexture (image) {
    var texture = new actor.Texture(image);
    texture.magFilter = actor.LinearFilter;
    texture.minFilter = actor.LinearFilter;


  };

  return ImageBuffer;
}(actor.Base));

var imageLayer = /*@__PURE__*/(function (Layer) {
  function imageLayer () {
    Layer.apply(this, arguments);
  }

  if ( Layer ) imageLayer.__proto__ = Layer;
  imageLayer.prototype = Object.create( Layer && Layer.prototype );
  imageLayer.prototype.constructor = imageLayer;

  imageLayer.prototype.draw = function draw () {
    var this$1 = this;

    this.type = 'image';
    var source = this.layerSource;
    var ref = this.get('styleOptions');
    var opacity = ref.opacity;
    // 加载 完成事件
    source.originData.images.then(function (images) {
      this$1.layerData[0].images = images;
      var buffer = new ImageBuffer$1({
        layerData: this$1.layerData
      });
      this$1.initGeometry(buffer.attributes);
      var material = new ImageMaterial({
        u_texture: buffer.texture,
        u_opacity: opacity
      });
      var imageMesh = new actor.Mesh(this$1.geometry, material);
      this$1.add(imageMesh);
      this$1.scene._engine.update();

    });
    return this;
  };
  imageLayer.prototype.initGeometry = function initGeometry (attributes) {
    this.geometry = new actor.BufferGeometry();
    this.geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.vertices, 3));
    this.geometry.addAttribute('uv', new actor.Float32BufferAttribute(attributes.uvs, 2));
  };

  return imageLayer;
}(Layer));

function ImageMaterial$1(options) {
  var ref = getModule('raster');
  var vs = ref.vs;
  var fs = ref.fs;
  var material = new Material({
    uniforms: {
      u_opacity: { value: options.u_opacity },
      u_texture: { value: options.u_texture },
      u_colorTexture: { value: options.u_colorTexture },
      u_min: { value: options.u_min },
      u_max: { value: options.u_max },
      u_extent: { value: options.u_extent },
      u_dimension: { value: options.u_dimension }

    },
    vertexShader: vs,
    fragmentShader: fs,
    transparent: false
  });
  // material.roughness = 1;
  // material.metalness = 0.1;
  // material.envMapIntensity = 3;
  return material;
}

// import BufferBase from './bufferBase';
var RasterBuffer = /*@__PURE__*/(function (Base) {
  function RasterBuffer(cfg) {
    Base.call(this, cfg);
    this.init();
  }

  if ( Base ) RasterBuffer.__proto__ = Base;
  RasterBuffer.prototype = Object.create( Base && Base.prototype );
  RasterBuffer.prototype.constructor = RasterBuffer;
  RasterBuffer.prototype.init = function init () {
    var layerData = this.get('layerData');
    var ref = layerData.dataArray[0];
    var coordinates = ref.coordinates;
    var width = ref.width;
    var data = ref.data;
    var height = ref.height;
    var positions = ( coordinates[0] ).concat( [coordinates[1][0]], [coordinates[0][1]], [0],
      coordinates[1],
      coordinates[0],
      coordinates[1],
      [coordinates[0][0]], [coordinates[1][1]], [0]
    );
    var imgPosUv = [ 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0 ];
    var size = this.get('size');

    var texture = new actor.DataTexture(new Float32Array(data), width, height, actor.LuminanceFormat, actor.FloatType);
    texture.needsUpdate = true;
    var colors = this.get('rampColors');
    var colorImageData = this.getColorRamp(colors);
    var colorTexture = this._getTexture(colorImageData); // 颜色纹理
    this.position = positions;
    this.uv = imgPosUv;
    this.u_raster = texture;//
    this.u_extent = [ coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1] ];
    this.u_colorTexture = colorTexture; // 颜色表‘=
    var triangles = this._buildTriangles(width, height, size, this.u_extent);
    var attributes = {
      vertices: new Float32Array(triangles.vertices),
      uvs: new Float32Array(triangles.uvs),
      indices: triangles.indices,
      dimension: triangles.dimension

    };
    this.attributes = attributes;
  };
  RasterBuffer.prototype.getColorRamp = function getColorRamp (name) {
    var colorscale = name;
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');

    canvas.width = 256;
    canvas.height = 1;
    var gradient = ctx.createLinearGradient(0, 0, 256, 0);
    var data = null;
    if (typeof (colorscale) === 'string') {
      colorscale = colorScales[name];
    }
    if (Object.prototype.toString.call(colorscale) === '[object Object]') {
      var min = colorscale.positions[0];
      var max = colorscale.positions[colorscale.positions.length - 1];

      for (var i = 0; i < colorscale.colors.length; ++i) {
        var value = (colorscale.positions[i] - min) / (max - min);
        gradient.addColorStop(value, colorscale.colors[i]);
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 256, 1);
      data = new Uint8ClampedArray(ctx.getImageData(0, 0, 256, 1).data);
    }
    if (Object.prototype.toString.call(colorscale) === '[object Uint8Array]') {
      data = ctx.createImageData(256, 1);
    }

    return new ImageData(data, 16, 16);

  };

  /**
   * 颜色纹理
   * @param {*} image 颜色图片
   * @return {texture} texture
   */
  RasterBuffer.prototype._getTexture = function _getTexture (image) {
    var texture1 = new actor.Texture(image);
    texture1.magFilter = actor.LinearFilter;
    texture1.minFilter = actor.LinearFilter;
    texture1.format = actor.RGBAFormat;
    texture1.type = actor.UnsignedByteType;
    texture1.generateMipmaps = true;
    texture1.needsUpdate = true;
    return texture1;
  };
  RasterBuffer.prototype._buildTriangles = function _buildTriangles (width, height, size, extent) {
    if ( size === void 0 ) size = 2;

    // const extent = [ 73.482190241, 3.82501784112, 135.106618732, 57.6300459963 ]
    var indices = [];
    var vertices = [];
    var uvs = [];
    var gridX = Math.floor(width / size);
    var gridY = Math.floor(height / size);
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var stepX = (extent[2] - extent[0]) / gridX1;
    var stepY = (extent[3] - extent[1]) / gridY1;
    for (var i = 0; i < gridY1; i++) {
      var y = i * size;
      for (var j = 0; j < gridX1; j++) {
        var x = j * size;
        vertices.push(extent[0] + x * stepX, (height - y) * stepY + extent[1], 0);
        uvs.push(j / gridX);
        uvs.push(i / gridY);
      }
    }
    for (var iy = 0; iy < gridY; iy++) {
      for (var ix = 0; ix < gridX; ix++) {
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = (ix + 1) + gridX1 * (iy + 1);
        var d = (ix + 1) + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }

    }
    return {
      uvs: uvs,
      indices: indices,
      vertices: vertices,
      dimension: [ gridX, gridY ]
    };

  };

  return RasterBuffer;
}(actor.Base));

var RasterLayer = /*@__PURE__*/(function (Layer) {
  function RasterLayer () {
    Layer.apply(this, arguments);
  }

  if ( Layer ) RasterLayer.__proto__ = Layer;
  RasterLayer.prototype = Object.create( Layer && Layer.prototype );
  RasterLayer.prototype.constructor = RasterLayer;

  RasterLayer.prototype.draw = function draw () {
    this.type = 'raster';
    var source = this.layerSource;
    // 加载 完成事件
    var styleOptions = this.get('styleOptions');
    var buffer = new RasterBuffer({
      layerData: source.data,
      rampColors: styleOptions.rampColors
    });
    this.initGeometry(buffer.attributes);
    var rasterConfig = source.data.dataArray[0];
    var material = new ImageMaterial$1({
      u_texture: buffer.u_raster,
      u_colorTexture: buffer.u_colorTexture,
      u_opacity: 1.0,
      u_extent: buffer.u_extent,
      u_min: rasterConfig.min,
      u_max: rasterConfig.max,
      u_dimension: buffer.attributes.dimension

    });

    var rasterMesh = new actor.Mesh(this.geometry, material);
    this.add(rasterMesh);
    return this;
  };

  RasterLayer.prototype.animateFunc = function animateFunc () {
    var this$1 = this;

    var animateOptions = this.get('animateOptions');
    this.material.setValue('u_bands', this.animateData.index % 3);
    this.material.setValue('u_texture', this.animateData.rasters[ Math.floor(this.animateData.index / 3) % 8]);
    this.animateData.index++;
    if (animateOptions) {
      animateOptions(this.animateData.index);
    }
    setTimeout(function () {
      this$1.animateId = requestAnimationFrame(this$1.animateFunc.bind(this$1));
    }, 500);
  };
  RasterLayer.prototype.cancelAnimate = function cancelAnimate () {
    window.cancelAnimationFrame(this.animateId);
  };
  RasterLayer.prototype.initGeometry = function initGeometry (attributes) {
    this.geometry = new actor.BufferGeometry();
    this.geometry.setIndex(attributes.indices);
    this.geometry.addAttribute('position', new actor.Float32BufferAttribute(attributes.vertices, 3));
    this.geometry.addAttribute('uv', new actor.Float32BufferAttribute(attributes.uvs, 2));
  };

  return RasterLayer;
}(Layer));

var HeatMapLayer = /*@__PURE__*/(function (Layer) {
  function HeatMapLayer () {
    Layer.apply(this, arguments);
  }

  if ( Layer ) HeatMapLayer.__proto__ = Layer;
  HeatMapLayer.prototype = Object.create( Layer && Layer.prototype );
  HeatMapLayer.prototype.constructor = HeatMapLayer;

  HeatMapLayer.prototype.shape = function shape (type) {
    this.shapeType = type;
    return this;
  };
  HeatMapLayer.prototype.draw = function draw () {
    this.type = 'heatmap';
    if (!this.shapeType) { this.shapeType = 'heatmap'; }
    var renderType = this.shapeType === 'heatmap' ? 'heatmap' : 'shape';
    this.add(getRender('heatmap', renderType)(this.layerData, this, this.layerSource));
  };

  return HeatMapLayer;
}(Layer));

/**
 * LRU Cache class with limit
 *
 * Update order for each get/set operation
 * Delete oldest when reach given limit
 */

var LRUCache = function LRUCache(limit, destroy) {
  if ( limit === void 0 ) limit = 50;
  if ( destroy === void 0 ) destroy = function () {};

  this.limit = limit;
  this.destroy = destroy;
  this._order = [];
  this.clear();
};

LRUCache.prototype.clear = function clear () {
    var this$1 = this;

  this._order.forEach(function (key) {
    this$1.delete(key);
  });
  this._cache = {};
  // access/update order, first item is oldest, last item is newest
  this._order = [];
};

LRUCache.prototype.get = function get (key) {
  var value = this._cache[key];
  if (value) {
    // update order
    this._deleteOrder(key);
    this._appendOrder(key);
  }
  return value;
};

LRUCache.prototype.set = function set (key, value) {
  if (!this._cache[key]) {
    // if reach limit, delete the oldest
    if (Object.keys(this._cache).length === this.limit) {
      this.delete(this._order[0]);
    }

    this._cache[key] = value;
    this._appendOrder(key);
  } else {
    // if found in cache, delete the old one, insert new one to the first of list
    this.delete(key);

    this._cache[key] = value;
    this._appendOrder(key);
  }
};

LRUCache.prototype.delete = function delete$1 (key) {
  var value = this._cache[key];
  if (value) {
    this._deleteCache(key);
    this._deleteOrder(key);
    this.destroy(value, key);
  }
};

LRUCache.prototype._deleteCache = function _deleteCache (key) {
  delete this._cache[key];
};

LRUCache.prototype._deleteOrder = function _deleteOrder (key) {
  var index = this._order.findIndex(function (o) { return o === key; });
  if (index >= 0) {
    this._order.splice(index, 1);
  }
};

LRUCache.prototype._appendOrder = function _appendOrder (key) {
  this._order.push(key);
};

var TileDataCache = function TileDataCache(limit, tileDestroy) {
  if ( limit === void 0 ) limit = 50;

  this._cache = new LRUCache(limit, tileDestroy);
};

TileDataCache.prototype.getTile = function getTile (key) {
  return this._cache.get(key);
};

TileDataCache.prototype.setTile = function setTile (tile, key) {
  this._cache.set(key, tile);
};
TileDataCache.prototype.removeTile = function removeTile (key) {
  return this._cache.delete(key);
};
TileDataCache.prototype.destory = function destory () {
  this._cache.clear();
};

var tileURLRegex = /\{([zxy])\}/g;
var TileSource = /*@__PURE__*/(function (Source) {
  function TileSource(url, cfg) {
    Source.call(this, cfg);
    this.cfg = cfg;
    this.urlTemplate = url;
    this._tileDataCache = new TileDataCache(50, this.tileDestroy);
    this.type = 'tile';
  }

  if ( Source ) TileSource.__proto__ = Source;
  TileSource.prototype = Object.create( Source && Source.prototype );
  TileSource.prototype.constructor = TileSource;
  TileSource.prototype.getTileData = function getTileData (x, y, z) {
    var this$1 = this;

    var key = [ x, y, z ].join('_');
    var tileData = this._tileDataCache.getTile(key);
    if (!tileData) {
      var tiledataPromise = new Promise(function (resolve) {
        if (tileData) {
          setTimeout(function () {
            resolve(tileData);
          }, 0);
        } else {
          this$1._requestTileData(x, y, z, resolve);
        }
      });
      tileData = {
        loading: true,
        data: tiledataPromise
      };
      this._tileDataCache.setTile(tileData, key);
      return tileData;
    }
    return tileData;

  };
  TileSource.prototype._init = function _init () {
    var parser = this.get('parser');
    this.set('minSourceZoom', parser && parser.minZoom || 0);
    this.set('maxSourceZoom', parser && parser.maxZoom || 18);
  };
  TileSource.prototype._generateSource = function _generateSource (x, y, z, data) {
    this.cfg.parser.tile = [ x, y, z ];
    var tileData = new Source(Object.assign({}, this.cfg,
      {mapType: this.get('mapType'),
      data: data,
      tile: [ x, y, z ]}));
    return tileData;
  };
  TileSource.prototype._requestTileData = function _requestTileData (x, y, z, done) {
    var this$1 = this;

    var urlParams = { x: x, y: y, z: z };
    var url = this._getTileURL(urlParams);
    var key = [ x, y, z ].join('_');
    this.xhrRequest = actor.getArrayBuffer({ url: url }, function (err, data) {
      if (err) {
        this$1._noData = true;
        this$1._tileDataCache.setTile({ loaded: true, data: { data: null } }, key);
        return;
      }
      var tileData = this$1._generateSource(x, y, z, data.data);
      this$1._tileDataCache.setTile({ loaded: true, data: tileData }, key);
      done(tileData);
    });

  };
  TileSource.prototype.getRequestUrl = function getRequestUrl (x, y, z) {
    var urlParams = { x: x, y: y, z: z };
    return this._getTileURL(urlParams);

  };
  TileSource.prototype._getTileURL = function _getTileURL (urlParams) {
    if (!urlParams.s) {
      // Default to a random choice of a, b or c
      urlParams.s = String.fromCharCode(97 + Math.floor(Math.random() * 3));
    }

    tileURLRegex.lastIndex = 0;
    return this.urlTemplate.replace(tileURLRegex, function(value, key) {
      return urlParams[key];
    });
  };
  TileSource.prototype.tileDestroy = function tileDestroy (tile) {
    if (!tile || !tile.data || tile.loading || !tile.data.data || !tile.data.data.dataArray) {
      return;
    }
    var tileData = tile.data;
    tileData.destroy();
  };

  return TileSource;
}(actor.Source));

var TileCache = function TileCache(limit, tileDestroy) {
  if ( limit === void 0 ) limit = 50;

  this._cache = new LRUCache(limit, tileDestroy);
};

TileCache.prototype.getTile = function getTile (key) {
  return this._cache.get(key);
};

TileCache.prototype.setTile = function setTile (tile, key) {
  this._cache.set(key, tile);
};
TileCache.prototype.destory = function destory () {
  this._cache.clear();
};
TileCache.prototype.setNeedUpdate = function setNeedUpdate () {
    var this$1 = this;

  this._cache._order.forEach(function (key) {
    var tile = this$1._cache.get(key);
    tile.needUpdate = true;
  });
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } } };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        var arguments$1 = arguments;

        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments$1[i];
            for (var p in s) { if (Object.prototype.hasOwnProperty.call(s, p)) { t[p] = s[p]; } }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) { if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        { t[p] = s[p]; } }
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        { for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                { t[p[i]] = s[p[i]]; }
        } }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") { r = Reflect.decorate(decorators, target, key, desc); }
    else { for (var i = decorators.length - 1; i >= 0; i--) { if (d = decorators[i]) { r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r; } } }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") { return Reflect.metadata(metadataKey, metadataValue); }
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) { throw t[1]; } return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) { throw new TypeError("Generator is already executing."); }
        while (_) { try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) { return t; }
            if (y = 0, t) { op = [op[0] & 2, t.value]; }
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) { _.ops.pop(); }
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; } }
        if (op[0] & 5) { throw op[1]; } return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) { if (!exports.hasOwnProperty(p)) { exports[p] = m[p]; } }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) { return m.call(o); }
    return {
        next: function () {
            if (o && i >= o.length) { o = void 0; }
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) { return o; }
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) { ar.push(r.value); }
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) { m.call(i); }
        }
        finally { if (e) { throw e.error; } }
    }
    return ar;
}

function __spread() {
    var arguments$1 = arguments;

    for (var ar = [], i = 0; i < arguments.length; i++)
        { ar = ar.concat(__read(arguments$1[i])); }
    return ar;
}

function __spreadArrays() {
    var arguments$1 = arguments;

    for (var s = 0, i = 0, il = arguments.length; i < il; i++) { s += arguments$1[i].length; }
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        { for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            { r[k] = a[j]; } }
    return r;
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) { throw new TypeError("Symbol.asyncIterator is not defined."); }
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; } }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) { resume(q[0][0], q[0][1]); } }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) { throw new TypeError("Symbol.asyncIterator is not defined."); }
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}
function __importStar(mod) {
    if (mod && mod.__esModule) { return mod; }
    var result = {};
    if (mod != null) { for (var k in mod) { if (Object.hasOwnProperty.call(mod, k)) { result[k] = mod[k]; } } }
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

var tslib_es6 = /*#__PURE__*/Object.freeze({
__extends: __extends,
get __assign () { return __assign; },
__rest: __rest,
__decorate: __decorate,
__param: __param,
__metadata: __metadata,
__awaiter: __awaiter,
__generator: __generator,
__exportStar: __exportStar,
__values: __values,
__read: __read,
__spread: __spread,
__spreadArrays: __spreadArrays,
__await: __await,
__asyncGenerator: __asyncGenerator,
__asyncDelegator: __asyncDelegator,
__asyncValues: __asyncValues,
__makeTemplateObject: __makeTemplateObject,
__importStar: __importStar,
__importDefault: __importDefault
});

var common = actor.createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = exports.EPSILON = 0.000001;
var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = exports.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
});

actor.unwrapExports(common);
var common_1 = common.setMatrixArrayType;
var common_2 = common.toRadian;
var common_3 = common.equals;
var common_4 = common.EPSILON;
var common_5 = common.ARRAY_TYPE;
var common_6 = common.RANDOM;

var mat3 = actor.createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sub = exports.mul = undefined;
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;



var glMatrix = _interopRequireWildcard(common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = exports.sub = subtract;
});

actor.unwrapExports(mat3);
var mat3_1 = mat3.sub;
var mat3_2 = mat3.mul;
var mat3_3 = mat3.create;
var mat3_4 = mat3.fromMat4;
var mat3_5 = mat3.clone;
var mat3_6 = mat3.copy;
var mat3_7 = mat3.fromValues;
var mat3_8 = mat3.set;
var mat3_9 = mat3.identity;
var mat3_10 = mat3.transpose;
var mat3_11 = mat3.invert;
var mat3_12 = mat3.adjoint;
var mat3_13 = mat3.determinant;
var mat3_14 = mat3.multiply;
var mat3_15 = mat3.translate;
var mat3_16 = mat3.rotate;
var mat3_17 = mat3.scale;
var mat3_18 = mat3.fromTranslation;
var mat3_19 = mat3.fromRotation;
var mat3_20 = mat3.fromScaling;
var mat3_21 = mat3.fromMat2d;
var mat3_22 = mat3.fromQuat;
var mat3_23 = mat3.normalFromMat4;
var mat3_24 = mat3.projection;
var mat3_25 = mat3.str;
var mat3_26 = mat3.frob;
var mat3_27 = mat3.add;
var mat3_28 = mat3.subtract;
var mat3_29 = mat3.multiplyScalar;
var mat3_30 = mat3.multiplyScalarAndAdd;
var mat3_31 = mat3.exactEquals;
var mat3_32 = mat3.equals;

var mat3_1$1 = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;

mat3.translate = function (out, a, v) {
    var transMat = Array(9);
    mat3.fromTranslation(transMat, v);
    return mat3.multiply(out, transMat, a);
};
mat3.rotate = function (out, a, rad) {
    var rotateMat = Array(9);
    mat3.fromRotation(rotateMat, rad);
    return mat3.multiply(out, rotateMat, a);
};
mat3.scale = function (out, a, v) {
    var scaleMat = Array(9);
    mat3.fromScaling(scaleMat, v);
    return mat3.multiply(out, scaleMat, a);
};
mat3.transform = function (m, actions) {
    var out = [].concat(m);
    for (var i = 0, len = actions.length; i < len; i += 1) {
        var action = actions[i];
        switch (action[0]) {
            case 't':
                mat3.translate(out, out, [action[1], action[2]]);
                break;
            case 's':
                mat3.scale(out, out, [action[1], action[2]]);
                break;
            case 'r':
                mat3.rotate(out, out, action[1]);
                break;
            default:
                break;
        }
    }
    return out;
};
exports["default"] = mat3;

});

actor.unwrapExports(mat3_1$1);

var vec3 = actor.createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;



var glMatrix = _interopRequireWildcard(common);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2];
  // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);
  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x;
  // var uuv = vec3.cross([], qvec, uv);
  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx;
  // vec3.scale(uv, uv, 2 * w);
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  // vec3.scale(uuv, uuv, 2);
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  // return vec3.add(out, a, vec3.add(out, uv, uuv));
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var sub = exports.sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var mul = exports.mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = exports.div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = exports.dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = exports.sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var len = exports.len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = exports.sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = exports.forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();
});

actor.unwrapExports(vec3);
var vec3_1 = vec3.forEach;
var vec3_2 = vec3.sqrLen;
var vec3_3 = vec3.len;
var vec3_4 = vec3.sqrDist;
var vec3_5 = vec3.dist;
var vec3_6 = vec3.div;
var vec3_7 = vec3.mul;
var vec3_8 = vec3.sub;
var vec3_9 = vec3.create;
var vec3_10 = vec3.clone;
var vec3_11 = vec3.length;
var vec3_12 = vec3.fromValues;
var vec3_13 = vec3.copy;
var vec3_14 = vec3.set;
var vec3_15 = vec3.add;
var vec3_16 = vec3.subtract;
var vec3_17 = vec3.multiply;
var vec3_18 = vec3.divide;
var vec3_19 = vec3.ceil;
var vec3_20 = vec3.floor;
var vec3_21 = vec3.min;
var vec3_22 = vec3.max;
var vec3_23 = vec3.round;
var vec3_24 = vec3.scale;
var vec3_25 = vec3.scaleAndAdd;
var vec3_26 = vec3.distance;
var vec3_27 = vec3.squaredDistance;
var vec3_28 = vec3.squaredLength;
var vec3_29 = vec3.negate;
var vec3_30 = vec3.inverse;
var vec3_31 = vec3.normalize;
var vec3_32 = vec3.dot;
var vec3_33 = vec3.cross;
var vec3_34 = vec3.lerp;
var vec3_35 = vec3.hermite;
var vec3_36 = vec3.bezier;
var vec3_37 = vec3.random;
var vec3_38 = vec3.transformMat4;
var vec3_39 = vec3.transformMat3;
var vec3_40 = vec3.transformQuat;
var vec3_41 = vec3.rotateX;
var vec3_42 = vec3.rotateY;
var vec3_43 = vec3.rotateZ;
var vec3_44 = vec3.angle;
var vec3_45 = vec3.str;
var vec3_46 = vec3.exactEquals;
var vec3_47 = vec3.equals;

var base = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;
/**
 * @fileOverview the base class of Coordinate
 * @author sima.zhang
 */


var Coord = /** @class */ (function () {
    function Coord(cfg) {
        if (cfg === void 0) { cfg = {}; }
        this.matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        this.isTransposed = false;
        Object.assign(this, cfg);
        this.init();
    }
    Coord.prototype.init = function () {
        var start = this.start;
        var end = this.end;
        var center = {
            x: (start.x + end.x) / 2,
            y: (start.y + end.y) / 2
        };
        this.center = center;
        this.width = Math.abs(end.x - start.x);
        this.height = Math.abs(end.y - start.y);
    };
    Coord.prototype._swapDim = function (dim) {
        var dimRange = this[dim];
        if (dimRange) {
            var tmp = dimRange.start;
            dimRange.start = dimRange.end;
            dimRange.end = tmp;
        }
    };
    Coord.prototype.getCenter = function () {
        return this.center;
    };
    Coord.prototype.getWidth = function () {
        return this.width;
    };
    Coord.prototype.getHeight = function () {
        return this.height;
    };
    Coord.prototype.convertDim = function (percent, dim) {
        var _a = this[dim], start = _a.start, end = _a.end;
        return start + percent * (end - start);
    };
    Coord.prototype.invertDim = function (value, dim) {
        var _a = this[dim], start = _a.start, end = _a.end;
        return (value - start) / (end - start);
    };
    /**
     * 将归一化的坐标点数据转换为画布坐标
     * @override
     * @param  {Object} point 归一化的坐标点
     * @return {Object}       返回画布坐标
     */
    Coord.prototype.convertPoint = function (point) {
        return point;
    };
    /**
     * 将画布坐标转换为归一化的坐标点数据
     * @override
     * @param  {Object} PointType 画布坐标点数据
     * @return {Object}       归一化后的数据点
     */
    Coord.prototype.invertPoint = function (point) {
        return point;
    };
    /**
     * 将坐标点进行矩阵变换
     * @param  {Number} x   对应 x 轴画布坐标
     * @param  {Number} y   对应 y 轴画布坐标
     * @param  {Number} tag 默认为 0，可取值 0, 1
     * @return {Array}     返回变换后的三阶向量 [x, y, z]
     */
    Coord.prototype.applyMatrix = function (x, y, tag) {
        if (tag === void 0) { tag = 0; }
        var matrix = this.matrix;
        var vector = [x, y, tag];
        vec3.transformMat3(vector, vector, matrix);
        return vector;
    };
    /**
     * 将坐标点进行矩阵逆变换
     * @param  {Number} x   对应 x 轴画布坐标
     * @param  {Number} y   对应 y 轴画布坐标
     * @param  {Number} tag 默认为 0，可取值 0, 1
     * @return {Array}     返回矩阵逆变换后的三阶向量 [x, y, z]
     */
    Coord.prototype.invertMatrix = function (x, y, tag) {
        if (tag === void 0) { tag = 0; }
        var matrix = this.matrix;
        var inversedMatrix = mat3_1$1["default"].invert([], matrix);
        var vector = [x, y, tag];
        vec3.transformMat3(vector, vector, inversedMatrix);
        return vector;
    };
    /**
     * 将归一化的坐标点数据转换为画布坐标，并根据坐标系当前矩阵进行变换
     * @param  {Object} point 归一化的坐标点
     * @return {Object}       返回进行矩阵变换后的画布坐标
     */
    Coord.prototype.convert = function (point) {
        var _a = this.convertPoint(point), x = _a.x, y = _a.y;
        var vector = this.applyMatrix(x, y, 1);
        return {
            x: vector[0],
            y: vector[1]
        };
    };
    /**
     * 将进行过矩阵变换画布坐标转换为归一化坐标
     * @param  {Object} point 画布坐标
     * @return {Object}       返回归一化的坐标点
     */
    Coord.prototype.invert = function (point) {
        var vector = this.invertMatrix(point.x, point.y, 1);
        return this.invertPoint({
            x: vector[0],
            y: vector[1]
        });
    };
    /**
     * 坐标系旋转变换
     * @param  {Number} radian 旋转弧度
     * @return {Object}        返回坐标系对象
     */
    Coord.prototype.rotate = function (radian) {
        var matrix = this.matrix;
        var center = this.center;
        mat3_1$1["default"].translate(matrix, matrix, [-center.x, -center.y]);
        mat3_1$1["default"].rotate(matrix, matrix, radian);
        mat3_1$1["default"].translate(matrix, matrix, [center.x, center.y]);
        return this;
    };
    /**
     * 坐标系反射变换
     * @param  {String} dim 反射维度
     * @return {Object}     返回坐标系对象
     */
    Coord.prototype.reflect = function (dim) {
        switch (dim) {
            case 'x':
                this._swapDim('x');
                break;
            case 'y':
                this._swapDim('y');
                break;
            default:
                this._swapDim('y');
        }
        return this;
    };
    /**
     * 坐标系比例变换
     * @param  {Number} s1 x 方向缩放比例
     * @param  {Number} s2 y 方向缩放比例
     * @return {Object}    返回坐标系对象
     */
    Coord.prototype.scale = function (s1, s2) {
        var matrix = this.matrix;
        var center = this.center;
        mat3_1$1["default"].translate(matrix, matrix, [-center.x, -center.y]);
        mat3_1$1["default"].scale(matrix, matrix, [s1, s2]);
        mat3_1$1["default"].translate(matrix, matrix, [center.x, center.y]);
        return this;
    };
    /**
     * 坐标系平移变换
     * @param  {Number} x x 方向平移像素
     * @param  {Number} y y 方向平移像素
     * @return {Object}   返回坐标系对象
     */
    Coord.prototype.translate = function (x, y) {
        var matrix = this.matrix;
        mat3_1$1["default"].translate(matrix, matrix, [x, y]);
        return this;
    };
    /**
     * 将坐标系 x y 两个轴进行转置
     * @return {Object} 返回坐标系对象
     */
    Coord.prototype.transpose = function () {
        this.isTransposed = !this.isTransposed;
        return this;
    };
    return Coord;
}());
exports["default"] = Coord;

});

actor.unwrapExports(base);

var util = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;
var trunc = function (v) {
    return v > 0 ? Math.floor(v) : Math.ceil(v);
};
exports.trunc = trunc;
function formatNum(num, digits) {
    var pow = Math.pow(10, digits === undefined ? 6 : digits);
    return Math.round(num * pow) / pow;
}
exports.formatNum = formatNum;
function wrapNum(x, range, includeMax) {
    var max = range[1];
    var min = range[0];
    var d = max - min;
    return x === max && includeMax ? x : ((((x - min) % d) + d) % d) + min;
}
exports.wrapNum = wrapNum;

});

actor.unwrapExports(util);
var util_1 = util.trunc;
var util_2 = util.formatNum;
var util_3 = util.wrapNum;

var point = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;

var Point = /** @class */ (function () {
    /**
     * 平面坐标
     * @param x x坐标
     * @param y y坐标
     * @param round 是否取整
     */
    function Point(x, y, round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
    }
    Point.prototype.clone = function () {
        return new Point(this.x, this.y);
    };
    Point.prototype.add = function (point, y, round) {
        return this.clone()._add(toPoint(point, y, round));
    };
    Point.prototype._add = function (point) {
        this.x += point.x;
        this.y += point.y;
        return this;
    };
    Point.prototype.subtract = function (point, y, round) {
        return this.clone()._subtract(toPoint(point, y, round));
    };
    Point.prototype._subtract = function (point) {
        this.x -= point.x;
        this.y -= point.y;
        return this;
    };
    Point.prototype.divideBy = function (num) {
        return this.clone()._divideBy(num);
    };
    Point.prototype._divideBy = function (num) {
        this.x /= num;
        this.y /= num;
        return this;
    };
    Point.prototype.multiplyBy = function (num) {
        return this.clone()._multiplyBy(num);
    };
    Point.prototype._multiplyBy = function (num) {
        this.x *= num;
        this.y *= num;
        return this;
    };
    Point.prototype.scaleBy = function (point) {
        return new Point(this.x * point.x, this.y * point.y);
    };
    Point.prototype.unscaleBy = function (point) {
        return new Point(this.x / point.x, this.y / point.y);
    };
    Point.prototype.round = function () {
        return this.clone()._round();
    };
    Point.prototype._round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    };
    Point.prototype.floor = function () {
        return this.clone()._floor();
    };
    Point.prototype._floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    };
    Point.prototype.ceil = function () {
        return this.clone()._ceil();
    };
    Point.prototype._ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    };
    Point.prototype.trunc = function () {
        return this.clone()._trunc();
    };
    Point.prototype._trunc = function () {
        this.x = util.trunc(this.x);
        this.y = util.trunc(this.y);
        return this;
    };
    Point.prototype.distanceTo = function (point) {
        var newPoint = toPoint(point);
        var x = newPoint.x - this.x;
        var y = newPoint.y - this.y;
        return Math.sqrt(x * x + y * y);
    };
    Point.prototype.equals = function (point, threshold) {
        var newPoint = toPoint(point);
        var margin = Math.max(Math.abs(this.x - newPoint.x), Math.abs(this.y - newPoint.y));
        return margin <= (threshold === undefined ? 1.0e-9 : threshold);
    };
    Point.prototype.contains = function (point) {
        var newPoint = toPoint(point);
        return (Math.abs(newPoint.x) <= Math.abs(this.x) &&
            Math.abs(newPoint.y) <= Math.abs(this.y));
    };
    Point.prototype.toString = function () {
        return "Point(" + util.formatNum(this.x) + ", " + util.formatNum(this.y) + ")";
    };
    return Point;
}());
exports.Point = Point;
function toPoint(x, y, round) {
    if (x instanceof Point) {
        return x;
    }
    if (Array.isArray(x)) {
        return new Point(x[0], x[1]);
    }
    if (x === undefined || x === null) {
        return x;
    }
    if (typeof x === 'object' && 'x' in x && 'y' in x) {
        return new Point(x.x, x.y);
    }
    return new Point(x, y, round);
}
exports.toPoint = toPoint;

});

actor.unwrapExports(point);
var point_1 = point.Point;
var point_2 = point.toPoint;

var bounds = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;

var Bounds = /** @class */ (function () {
    function Bounds(topLeft, bottomRight) {
        if (!topLeft) {
            return;
        }
        var points = bottomRight ? [topLeft, bottomRight] : topLeft;
        if (Array.isArray(points)) {
            for (var i = 0, len = points.length; i < len; i += 1) {
                // @ts-ignore
                this.extend(points[i]);
            }
        }
    }
    Bounds.prototype.extend = function (point$1) {
        var newPoint = point.toPoint(point$1);
        if (!this.min && !this.max) {
            this.min = newPoint.clone();
            this.max = newPoint.clone();
        }
        else {
            this.min.x = Math.min(newPoint.x, this.min.x);
            this.max.x = Math.max(newPoint.x, this.max.x);
            this.min.y = Math.min(newPoint.y, this.min.y);
            this.max.y = Math.max(newPoint.y, this.max.y);
        }
        return this;
    };
    Bounds.prototype.getCenter = function (round) {
        return new point.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    };
    Bounds.prototype.getBottomLeft = function () {
        return new point.Point(this.min.x, this.max.y);
    };
    Bounds.prototype.getTopRight = function () {
        return new point.Point(this.max.x, this.min.y);
    };
    Bounds.prototype.getBottomRight = function () {
        return this.max;
    };
    Bounds.prototype.getTopLeft = function () {
        return this.min;
    };
    Bounds.prototype.getSize = function () {
        return this.max.subtract(this.min);
    };
    /**
     * 判断是否包含 输入 points 或者 bounds
     * @param obj
     */
    Bounds.prototype.contains = function (obj) {
        var min;
        var max;
        var newObj = obj;
        // @ts-ignore
        if (newObj instanceof point.Point || typeof newObj[0] === 'number') {
            newObj = point.toPoint(newObj);
        }
        else {
            newObj = toBounds(newObj);
        }
        if (newObj instanceof Bounds) {
            min = newObj.min;
            max = newObj.max;
        }
        else {
            min = max = obj;
        }
        return (min.x >= this.min.x &&
            max.x <= this.max.x &&
            min.y >= this.min.y &&
            max.y <= this.max.y);
    };
    /**
     * 判断两个bounds是否相交 ,
     * @param bounds
     */
    Bounds.prototype.intersect = function (bounds) {
        var newBounds = toBounds(bounds);
        var min = this.min;
        var max = this.max;
        var min2 = newBounds.min;
        var max2 = newBounds.max;
        var xIntersects = (max2.x >= min.x) && (min2.x <= max.x);
        var yIntersects = (max2.y >= min.y) && (min2.y <= max.y);
        return xIntersects && yIntersects;
    };
    /**
     * 判断bounds是否相互覆盖
     * @param bounds
     */
    Bounds.prototype.overlaps = function (bounds) {
        var newBounds = toBounds(bounds);
        var min = this.min;
        var max = this.max;
        var min2 = newBounds.min;
        var max2 = newBounds.max;
        var xOverlaps = (max2.x > min.x) && (min2.x < max.x);
        var yOverlaps = (max2.y > min.y) && (min2.y < max.y);
        return xOverlaps && yOverlaps;
    };
    Bounds.prototype.isValid = function () {
        return !!(this.min && this.max);
    };
    return Bounds;
}());
exports.Bounds = Bounds;
function toBounds(topLeft, bottomRight) {
    if (!topLeft || topLeft instanceof Bounds) {
        return topLeft;
    }
    return new Bounds(topLeft, bottomRight);
}
exports.toBounds = toBounds;

});

actor.unwrapExports(bounds);
var bounds_1 = bounds.Bounds;
var bounds_2 = bounds.toBounds;

var lngLatBounds = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;

var LngLatBounds = /** @class */ (function () {
    function LngLatBounds(corner1, corner2) {
        if (!corner1) {
            return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        if (Array.isArray(latlngs)) {
            for (var i = 0, len = latlngs.length; i < len; i += 1) {
                // @ts-ignore
                this.extend(latlngs[i]);
            }
        }
    }
    LngLatBounds.prototype.extend = function (obj) {
        var sw = this.southWest;
        var ne = this.northEast;
        var sw2;
        var ne2;
        if (obj instanceof lngLat.LngLat) {
            sw2 = obj;
            ne2 = obj;
        }
        else if (obj instanceof LngLatBounds) {
            sw2 = obj.southWest;
            ne2 = obj.northEast;
            if (!sw2 || !ne2) {
                return this;
            }
        }
        else {
            if (obj && Array.isArray(obj)) {
                if (Array.isArray(obj[0])) {
                    return this.extend(toLngLatBounds(obj));
                }
                return this.extend(lngLat.toLngLat(obj));
            }
            return this;
        }
        if (!sw && !ne) {
            this.southWest = new lngLat.LngLat(sw2.lng, sw2.lat);
            this.northEast = new lngLat.LngLat(ne2.lng, ne2.lat);
        }
        else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
        }
        return this;
    };
    /**
     * 放大或者缩小区域
     * @param bufferRatio 缩放比率
     */
    LngLatBounds.prototype.pad = function (bufferRatio) {
        var sw = this.southWest;
        var ne = this.northEast;
        var heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio;
        var widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
        return new LngLatBounds(new lngLat.LngLat(sw.lng - widthBuffer, sw.lat - heightBuffer), new lngLat.LngLat(ne.lng + widthBuffer, ne.lat + heightBuffer));
    };
    LngLatBounds.prototype.getCenter = function () {
        return new lngLat.LngLat((this.southWest.lng + this.northEast.lng) / 2, (this.southWest.lat + this.northEast.lat) / 2);
    };
    LngLatBounds.prototype.getSouthWest = function () {
        return this.southWest;
    };
    LngLatBounds.prototype.getNorthEast = function () {
        return this.northEast;
    };
    LngLatBounds.prototype.getNorthWest = function () {
        return new lngLat.LngLat(this.getWest(), this.getNorth());
    };
    LngLatBounds.prototype.getSouthEast = function () {
        return new lngLat.LngLat(this.getEast(), this.getSouth());
    };
    LngLatBounds.prototype.getWest = function () {
        return this.southWest.lng;
    };
    LngLatBounds.prototype.getSouth = function () {
        return this.southWest.lat;
    };
    LngLatBounds.prototype.getNorth = function () {
        return this.northEast.lat;
    };
    LngLatBounds.prototype.getEast = function () {
        return this.northEast.lng;
    };
    LngLatBounds.prototype.contains = function (obj) {
        var newObj = obj;
        if ((Array.isArray(newObj) && typeof newObj[0] === 'number') ||
            newObj instanceof lngLat.LngLat ||
            'lat' in newObj) {
            newObj = lngLat.toLngLat(newObj);
        }
        else {
            newObj = toLngLatBounds(newObj);
        }
        var sw = this.southWest;
        var ne = this.northEast;
        var sw2;
        var ne2;
        if (newObj instanceof LngLatBounds) {
            sw2 = newObj.getSouthWest();
            ne2 = newObj.getNorthEast();
        }
        else {
            sw2 = ne2 = newObj;
        }
        return (sw2.lat >= sw.lat &&
            ne2.lat <= ne.lat &&
            sw2.lng >= sw.lng &&
            ne2.lng <= ne.lng);
    };
    // 包含相邻的多边形
    LngLatBounds.prototype.intersects = function (bounds) {
        var newBounds = toLngLatBounds(bounds);
        var sw = this.southWest;
        var ne = this.northEast;
        var sw2 = newBounds.getSouthWest();
        var ne2 = newBounds.getNorthEast();
        var latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat;
        var lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
        return latIntersects && lngIntersects;
    };
    // 不包括相邻的多边形
    LngLatBounds.prototype.overlaps = function (bounds) {
        var newBounds = toLngLatBounds(bounds);
        var sw = this.southWest;
        var ne = this.northEast;
        var sw2 = newBounds.getSouthWest();
        var ne2 = newBounds.getNorthEast();
        var latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat;
        var lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
        return latOverlaps && lngOverlaps;
    };
    LngLatBounds.prototype.toBBoxString = function () {
        return [
            this.getWest(),
            this.getSouth(),
            this.getEast(),
            this.getNorth() ].join(',');
    };
    LngLatBounds.prototype.equals = function (bounds, maxMargin) {
        if (!bounds) {
            return false;
        }
        var newBounds = toLngLatBounds(bounds);
        return (this.southWest.equals(newBounds.getSouthWest(), maxMargin) &&
            this.northEast.equals(newBounds.getNorthEast(), maxMargin));
    };
    LngLatBounds.prototype.isValid = function () {
        return !!(this.southWest && this.northEast);
    };
    return LngLatBounds;
}());
exports.LngLatBounds = LngLatBounds;
function toLngLatBounds(a, b) {
    if (a instanceof LngLatBounds) {
        return a;
    }
    if (b !== undefined) {
        return new LngLatBounds(a, b);
    }
    return new LngLatBounds(a);
}
exports.toLngLatBounds = toLngLatBounds;

});

actor.unwrapExports(lngLatBounds);
var lngLatBounds_1 = lngLatBounds.LngLatBounds;
var lngLatBounds_2 = lngLatBounds.toLngLatBounds;

var lngLat = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;



var LngLat = /** @class */ (function () {
    function LngLat(lng, lat, alt) {
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error("\u65E0\u6548\u7684\u7ECF\u7EAC\u5EA6\u53C2\u6570: (" + lng + ",' " + lat);
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== undefined) {
            this.alt = +alt;
        }
    }
    LngLat.prototype.equals = function (lnglat, threshold) {
        if (!lnglat) {
            return false;
        }
        var newLnglat = toLngLat(lnglat);
        if (newLnglat === undefined) {
            return false;
        }
        var margin = Math.max(Math.abs(this.lat - newLnglat.lat), Math.abs(this.lng - newLnglat.lng));
        return margin <= (threshold === undefined ? 1.0e-9 : threshold);
    };
    LngLat.prototype.toString = function (precision) {
        return ("LngLat(" + util.formatNum(this.lng, precision) + ", " + util.formatNum(this.lat, precision) + ")");
    };
    LngLat.prototype.distanceTo = function (other) {
        return earth.earth.distance(this, toLngLat(other));
    };
    LngLat.prototype.wrap = function () {
        // console.log(earth.infinite);
        return earth.earth.wrapLngLat(this);
    };
    LngLat.prototype.toBounds = function (sizeInMeters) {
        var latAccuracy = 180 * sizeInMeters / 40075017;
        var lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);
        return lngLatBounds.toLngLatBounds([this.lng - lngAccuracy, this.lat - latAccuracy], [this.lng + lngAccuracy, this.lat + latAccuracy]);
    };
    LngLat.prototype.clone = function () {
        return new LngLat(this.lng, this.lat, this.alt);
    };
    return LngLat;
}());
exports.LngLat = LngLat;
function toLngLat(a, b, c) {
    if (a instanceof LngLat) {
        return a;
    }
    if (Array.isArray(a) && typeof a[0] !== 'object') {
        if (a.length === 3) {
            return new LngLat(a[0], a[1], a[2]);
        }
        if (a.length === 2) {
            return new LngLat(a[0], a[1]);
        }
    }
    if (a === undefined || a === null) {
        throw new Error("\u65E0\u6548\u7684\u7ECF\u7EAC\u5EA6\u53C2\u6570: (" + a + ", " + b + ")");
    }
    if (typeof a === 'object' && 'lat' in a) {
        return new LngLat(a.lng, 'lng' in a ? a.lat : 0, a.alt);
    }
    if (b === undefined) {
        throw new Error("\u65E0\u6548\u7684\u7ECF\u7EAC\u5EA6\u53C2\u6570: (" + a + ", " + b + ")");
    }
    return new LngLat(Number(a), b, c);
}
exports.toLngLat = toLngLat;

});

actor.unwrapExports(lngLat);
var lngLat_1 = lngLat.LngLat;
var lngLat_2 = lngLat.toLngLat;

var sphericalMercator = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;



exports.sphericalMercator = {
    R: 6378137,
    MAX_LATITUDE: 85.0511287798,
    /**
     * 经纬度坐标转平面坐标
     * @param lnglat 经纬度
     */
    project: function (lnglat) {
        var d = Math.PI / 180;
        var max = this.MAX_LATITUDE;
        var lat = Math.max(Math.min(max, lnglat.lat), -max);
        var sin = Math.sin(lat * d);
        return new point.Point(this.R * lnglat.lng * d, (this.R * Math.log((1 + sin) / (1 - sin))) / 2);
    },
    // 平面坐标转经纬度
    unproject: function (point) {
        var d = 180 / Math.PI;
        return new lngLat.LngLat((point.x * d) / this.R, (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d);
    },
    bounds: (function () {
        var d = 6378137 * Math.PI;
        return new bounds.Bounds([-d, -d], [d, d]);
    })()
};

});

actor.unwrapExports(sphericalMercator);
var sphericalMercator_1 = sphericalMercator.sphericalMercator;

var transformation = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;

var Transformation = /** @class */ (function () {
    function Transformation(a, b, c, d) {
        if (Array.isArray(a)) {
            // use array properties
            this.a = a[0];
            this.b = a[1];
            this.c = a[2];
            this.d = a[3];
            return;
        }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
    Transformation.prototype.transform = function (point, scale) {
        return this._transform(point.clone(), scale);
    };
    Transformation.prototype._transform = function (point, scale) {
        var newScale = scale || 1;
        point.x = newScale * (this.a * point.x + this.b);
        point.y = newScale * (this.c * point.y + this.d);
        return point;
    };
    Transformation.prototype.untransform = function (point$1, scale) {
        var newScale = scale || 1;
        return new point.Point((point$1.x / newScale - this.b) / this.a, (point$1.y / newScale - this.d) / this.c);
    };
    return Transformation;
}());
exports.Transformation = Transformation;

});

actor.unwrapExports(transformation);
var transformation_1 = transformation.Transformation;

var crs = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;






var scale = 0.5 / (Math.PI * sphericalMercator.sphericalMercator.R);
var transform = new transformation.Transformation(scale, 0.5, -scale, 0.5);
exports.CRS = {
    wrapLng: [-180, 180],
    wrapLat: null,
    projection: sphericalMercator.sphericalMercator,
    transformation: transform,
    lngLatToPoint: function (lnglat, zoom) {
        var projectedPoint = this.projection.project(lnglat);
        var scale = this.scale(zoom);
        return this.transformation.transform(projectedPoint, scale);
    },
    pointToLngLat: function (point, zoom) {
        var scale = this.scale(zoom);
        var untransformedPoint = this.transformation.untransform(point, scale);
        return this.projection.unproject(untransformedPoint);
    },
    project: function (lnglat) {
        return this.projection.project(lnglat);
    },
    unproject: function (point) {
        return this.projection.unproject(point);
    },
    zoom: function (scale) {
        return Math.log(scale / 256) / Math.LN2;
    },
    scale: function (zoom) {
        return 256 * Math.pow(2, zoom);
    },
    getProjectedBounds: function (zoom) {
        if (this.infinite) {
            return new bounds.Bounds([[Infinity, Infinity], [Infinity, Infinity]]);
        }
        var b = this.projection.bounds;
        var s = this.scale(zoom);
        var min = this.transformation.transform(b.min, s);
        var max = this.transformation.transform(b.max, s);
        return new bounds.Bounds(min, max);
    },
    infinite: false,
    wrapLngLat: function (lnglat) {
        var lng = Array.isArray(this.wrapLng) ? util.wrapNum(lnglat.lng, this.wrapLng, true) : lnglat.lng;
        var lat = Array.isArray(this.wrapLat) ? util.wrapNum(lnglat.lat, this.wrapLat, true) : lnglat.lat;
        var alt = lnglat.alt;
        return new lngLat.LngLat(lng, lat, alt);
    },
    wrapLngLatBounds: function (bounds) {
        var center = bounds.getCenter();
        var newCenter = this.wrapLngLat(center);
        var latShift = center.lat - newCenter.lat;
        var lngShift = center.lng - newCenter.lng;
        if (latShift === 0 && lngShift === 0) {
            return bounds;
        }
        var sw = bounds.getSouthWest();
        var ne = bounds.getNorthEast();
        var newSw = new lngLat.LngLat(sw.lng - lngShift, sw.lat - latShift);
        var newNe = new lngLat.LngLat(ne.lng - lngShift, ne.lat - latShift);
        return new lngLatBounds.LngLatBounds(newSw, newNe);
    }
};

});

actor.unwrapExports(crs);
var crs_1 = crs.CRS;

var earth = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;


// @ts-ignore
exports.earth = actor.lib.mix({}, crs.CRS, {
    wrapLng: [-180, 180],
    R: 6371000,
    distance: function (latlng1, latlng2) {
        var rad = Math.PI / 180;
        var lat1 = latlng1.lat * rad;
        var lat2 = latlng2.lat * rad;
        var sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2);
        var sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2);
        var a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon;
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return this.R * c;
    }
});

});

actor.unwrapExports(earth);
var earth_1 = earth.earth;

var crsEpsg3857 = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;




var scale = 0.5 / (Math.PI * sphericalMercator.sphericalMercator.R);
var transform = new transformation.Transformation(scale, 0.5, -scale, 0.5);
// @ts-ignore
exports.epsg3857 = actor.lib.mix({}, earth.earth, {
    code: 'EPSG:3857',
    projection: sphericalMercator.sphericalMercator,
    transformation: transform
});
exports.epsg900913 = actor.lib.mix({}, exports.epsg3857, {
    code: 'EPSG:900913'
});

});

actor.unwrapExports(crsEpsg3857);
var crsEpsg3857_1 = crsEpsg3857.epsg3857;
var crsEpsg3857_2 = crsEpsg3857.epsg900913;

var lnglatProjection = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;



exports.lngLatProjection = {
    project: function (lngLat) {
        return new point.Point(lngLat.lng, lngLat.lat);
    },
    unproject: function (point) {
        return new lngLat.LngLat(point.x, point.y);
    },
    bounds: new bounds.Bounds([-180, -90], [180, 90])
};

});

actor.unwrapExports(lnglatProjection);
var lnglatProjection_1 = lnglatProjection.lngLatProjection;

var crsEpsg4326 = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;




var transform = new transformation.Transformation(1 / 180, 1, -1 / 180, 0.5);
exports.epsg4326 = actor.lib.mix({}, earth.earth, {
    code: 'EPSG:4326',
    projection: lnglatProjection.lngLatProjection,
    transformation: transform
});

});

actor.unwrapExports(crsEpsg4326);
var crsEpsg4326_1 = crsEpsg4326.epsg4326;

var crsSimple = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;




var transform = new transformation.Transformation(1, 0, -1, 0);
// @ts-ignore
exports.simple = actor.lib.mix({}, crs.CRS, {
    projection: lnglatProjection.lngLatProjection,
    transformation: transform,
    scale: function (zoom) {
        return Math.pow(2, zoom);
    },
    zoom: function (scale) {
        return Math.log(scale) / Math.LN2;
    },
    distance: function (latlng1, latlng2) {
        var dx = latlng2.lng - latlng1.lng;
        var dy = latlng2.lat - latlng1.lat;
        return Math.sqrt(dx * dx + dy * dy);
    },
    infinite: true
});

});

actor.unwrapExports(crsSimple);
var crsSimple_1 = crsSimple.simple;

var crs$1 = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;




// 所有的 Coord map
var CRS_MAP = {
    // crs:CRS,
    epsg3857: crsEpsg3857.epsg3857,
    epsg4326: crsEpsg4326.epsg4326,
    simple: crsSimple.simple,
    earth: earth.earth,
    epsg900913: crsEpsg3857.epsg900913
};
/**
 * 通过类型获得 Coord 类
 * @param type
 */
exports.getCRS = function (type) {
    return CRS_MAP[type.toLowerCase()];
};

});

actor.unwrapExports(crs$1);
var crs_1$1 = crs$1.getCRS;

var geo = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;





var Geo = /** @class */ (function (_super) {
    tslib_es6.__extends(Geo, _super);
    function Geo(cfg) {
        var _this = _super.call(this, tslib_es6.__assign({ projection: 'EPSG3857', zoom: 7, mapCenter: [116.400146, 39.926588] }, cfg)) || this;
        _this.type = 'geo';
        _this.isGeo = true;
        cfg.center ? _this.center = cfg.center : _this.center = _this.mapCenter;
        _this._init();
        return _this;
    }
    Geo.prototype._init = function () {
        var start = this.start;
        var end = this.end;
        this.center = lngLat.toLngLat(this.center);
        this.width = Math.abs(end.x - start.x);
        this.height = Math.abs(end.y - start.y);
        this.crs = crs$1.getCRS(this.projection);
    };
    Geo.prototype.getZoom = function () {
        return this.zoom;
    };
    Geo.prototype.setZoom = function (zoom) {
        this.zoom = zoom;
    };
    Geo.prototype.setCenter = function (center) {
        this.center = lngLat.toLngLat(center);
    };
    Geo.prototype.getCenter = function () {
        return this.center;
    };
    /**
     * 经纬度坐标转画布坐标 统一和其他坐标系传入方式 coordControls使用
     * @param point
     */
    Geo.prototype.convertPoint = function (point) {
        var lngLat$1 = [point.x, point.y];
        var ll = this.project(lngLat.toLngLat(lngLat$1), this.zoom).round();
        var origin = this.getPixelOrigin();
        var resPoint = ll.subtract(origin);
        return { x: resPoint.x, y: resPoint.y };
    };
    /**
     * 画布坐标转经纬坐标 统一和其他坐标系传入方式
     * @param point
     */
    Geo.prototype.invertPoint = function (point$1) {
        var newPoint = point.toPoint(point$1);
        var origin = this.getPixelOrigin();
        var px = newPoint.add(origin);
        var lnglat = this.unproject(px, this.zoom);
        return { x: lnglat.lng, y: lnglat.lat };
    };
    /**
    * 画布坐标转经纬坐标 同convertPoint 对用户使用
    * @param point
    */
    Geo.prototype.layerPointToLatLng = function (point) {
        var origin = this.getPixelOrigin();
        var ll = point.add(origin);
        return this.unproject(ll, this.zoom);
    };
    /**
    * 经纬度坐标转画布坐标 同 invertPoint 对用户使用
    * @param lngLat
    */
    Geo.prototype.latLngToLayerPoint = function (lngLat$1) {
        var ll = this.project(lngLat.toLngLat(lngLat$1), this.zoom).round();
        var origin = this.getPixelOrigin();
        return ll.subtract(origin);
    };
    // 计算地图中心点像素坐标
    Geo.prototype.getPixelOrigin = function () {
        var halfWidth = this.width / 2;
        var halfHeight = this.height / 2;
        return this.crs
            .lngLatToPoint(lngLat.toLngLat(this.center), this.zoom)
            .subtract({ y: halfHeight, x: halfWidth });
    };
    /**
     * 经纬度坐标转地图像素坐标
     * @param lnglat
     * @param zoom
     */
    Geo.prototype.project = function (lnglat, zoom) {
        var newZoom = zoom === undefined ? this.zoom : zoom;
        return this.crs.lngLatToPoint(lngLat.toLngLat(lnglat), newZoom);
    };
    /**
     * 地图像素坐标转经纬度
     * @param point
     * @param zoom
     */
    Geo.prototype.unproject = function (point$1, zoom) {
        var newZoom = zoom === undefined ? this.zoom : zoom;
        return this.crs.pointToLngLat(point.toPoint(point$1), newZoom);
    };
    Geo.prototype.distance = function (lnglat1, lnglat2) {
        return this.crs.distance(lngLat.toLngLat(lnglat1), lngLat.toLngLat(lnglat2));
    };
    return Geo;
}(base["default"]));
exports["default"] = Geo;

});

actor.unwrapExports(geo);

var lib = actor.createCommonjsModule(function (module, exports) {
exports.__esModule = true;

exports.GeoCoordinates = geo;

exports.Bounds = bounds.Bounds;
exports.toBounds = bounds.toBounds;

exports.LngLat = lngLat.LngLat;
exports.toLngLat = lngLat.toLngLat;

exports.LngLatBounds = lngLatBounds.LngLatBounds;
exports.toLngLatBounds = lngLatBounds.toLngLatBounds;

exports.Point = point.Point;
exports.toPoint = point.toPoint;

});

actor.unwrapExports(lib);
var lib_1 = lib.GeoCoordinates;
var lib_2 = lib.Bounds;
var lib_3 = lib.toBounds;
var lib_4 = lib.LngLat;
var lib_5 = lib.toLngLat;
var lib_6 = lib.LngLatBounds;
var lib_7 = lib.toLngLatBounds;
var lib_8 = lib.Point;
var lib_9 = lib.toPoint;

var pointShape$2 = actor.Global.pointShape;
var TileLayer = /*@__PURE__*/(function (Layer) {
  function TileLayer(scene, cfg) {
    Layer.call(this, scene, Object.assign({}, cfg,
      {minSourceZoom: 0,
      maxSOurceZoom: 18,
      keepBuffer: 2}));
    this._tileCache = new TileCache(50, this._destroyTile);
    this._crs = crsEpsg3857_1;
    this._tiles = new actor.Object3D();
    this._tiles.frustumCulled = false;
    this._tileKeys = [];
    this.tileList = {};
    this.type = this.get('layerType');
    this.workerPool = this.scene.workerPool;
  }

  if ( Layer ) TileLayer.__proto__ = Layer;
  TileLayer.prototype = Object.create( Layer && Layer.prototype );
  TileLayer.prototype.constructor = TileLayer;
  TileLayer.prototype.shape = function shape (field, values) {
    var layerType = this.get('layerType');
    if (layerType === 'point') {
      return Layer.prototype.shape.call(this, field, values);
    }
    this.shape = field;
    return this;
  };
  TileLayer.prototype.source = function source (data, cfg) {
    if ( cfg === void 0 ) cfg = {};

    if (data instanceof TileSource) {
      data.set('mapType', this.scene.mapType);
      this.tileSource = data;
    } else {
      cfg.mapType = this.scene.mapType;
      this.tileSource = new TileSource(data, cfg);
      this.sourceCfg = Object.assign({}, cfg,
        {url: data});

    }
    return this;
  };
  TileLayer.prototype._initControllers = function _initControllers () {
    var pickCtr = new Controller.Picking({ layer: this });
    var interactionCtr = new Controller.Interaction({ layer: this });
    this.set('pickingController', pickCtr);
    this.set('interacionController', interactionCtr);
  };
  TileLayer.prototype.render = function render () {
    this._visibleWithZoom();
    this._updateDraw();
    this.scene._engine.update();
    return this;
  };
  TileLayer.prototype.draw = function draw () {
    this._object3D.add(this._tiles);
    this._calculateLOD();
  };
  TileLayer.prototype.drawTile = function drawTile () {

  };

  TileLayer.prototype.zoomchange = function zoomchange (ev) {
    var this$1 = this;

    Layer.prototype.zoomchange.call(this, ev);
    this._visibleWithZoom();
    requestAnimationFrame(function () {
      this$1._calculateLOD();
    });
    this._calculateLOD();
  };

  TileLayer.prototype.dragend = function dragend (ev) {
    var this$1 = this;

    Layer.prototype.dragend.call(this, ev);
    requestAnimationFrame(function () {
      this$1._calculateLOD();
    });

  };

  TileLayer.prototype._calculateLOD = function _calculateLOD () {
    var this$1 = this;

    /**
     * 加载完成 active
     * 需要显示 current
     * 是否保留 retain
     */
    var zoom = Math.floor(this.scene.getZoom()) - 1;
    var minZoom = this.get('minZoom');
    var maxZoom = this.get('maxZoom');
    var minSourceZoom = this.tileSource.get('minSourceZoom');
    var maxSourceZoom = this.tileSource.get('maxSourceZoom');
    var currentZoom = this.scene.getZoom();
    this.tileZoom = zoom > maxSourceZoom ? maxSourceZoom : zoom;
    if (currentZoom < minZoom || currentZoom >= maxZoom || currentZoom < minSourceZoom) {
      this._removeTiles();
      this._object3D.visible = false;
      return;
    } else if (this.get('visible')) {
      this._object3D.visible = true;
    }
    this.show();
    this.updateTileList = [];
    var center = this.scene.getCenter();
    var centerPoint = this._crs.lngLatToPoint(lib_5(center.lng, center.lat), this.tileZoom);
    var centerXY = centerPoint.divideBy(256).floor();
    var pixelBounds = this._getPixelBounds();
    var tileRange = this._pxBoundsToTileRange(pixelBounds);
    var margin = this.get('keepBuffer');
    this.noPruneRange = new lib_2(tileRange.getBottomLeft().subtract([ margin, -margin ]),
      tileRange.getTopRight().add([ margin, -margin ]));
    if (!(isFinite(tileRange.min.x) &&
    isFinite(tileRange.min.y) &&
    isFinite(tileRange.max.x) &&
    isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }
    for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
      for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
        var coords = [ i, j, this.tileZoom ];
        var tile = this.tileList[coords.join('_')];
        if (tile) {
          tile.current = true;
        } else {
          this.tileList[coords.join('_')] = {
            current: true,
            coords: coords
          };
          this.updateTileList.push(coords);
        }
      }
    }
    this.updateTileList.sort(function (a, b) {
      var tile1 = a;
      var tile2 = b;
      var d1 = Math.pow((tile1[0] * 1 - centerXY.x), 2) + Math.pow((tile1[1] * 1 - centerXY.y), 2);
      var d2 = Math.pow((tile2[0] * 1 - centerXY.x), 2) + Math.pow((tile2[1] * 1 - centerXY.y), 2);
      return d1 - d2;
    });
    this._pruneTiles();
    // 更新瓦片数据
    this.updateTileList.forEach(function (coords) {
      var key = coords.join('_');
      if (this$1.tileList[key].current) {
        this$1._requestTile(key, this$1);
      }
    });
  };
  TileLayer.prototype._getShape = function _getShape (layerData) {
    var shape = null;
    if (!layerData[0].hasOwnProperty('shape')) {
      return 'normal';
    }
    for (var i = 0; i < layerData.length; i++) {
      shape = layerData[i].shape;
      if (shape !== undefined) {
        break;
      }
    }
    if (pointShape$2['2d'].indexOf(shape) !== -1) {
      return 'circle';
    } else if (pointShape$2['3d'].indexOf(shape) !== -1) {
      return 'fill';
    } else if (this.scene.image.imagesIds.indexOf(shape) !== -1) {
      return 'image';
    }
    return 'text';
  };
  TileLayer.prototype._updateTileList = function _updateTileList (x, y, z) {
    var key = [ x, y, z ].join('_');
    var tile = this.tileList[key];
    if (tile) {
      tile.current = true;
    } else {
      this.tileList[key] = {
        current: true,
        active: false,
        coords: key.split('_')
      };
      this.updateTileList.push(key);
    }
  };
  TileLayer.prototype._requestTile = function _requestTile (key, layer) {
    var this$1 = this;

    var t = this.tileList[key];
    if (!t) {
      return;
    }
    var tile = this._tileCache.getTile(key);
    if (!tile) {
      tile = this._createTile(key, layer);
      tile.on('tileLoaded', function () {
        t.active = true;
        var mesh = tile.getMesh();
        mesh.name = key;
        this$1._tileCache.setTile(tile, key);
        this$1._tileKeys.push(key);
        if (mesh.type === 'composer') {
          this$1.scene._engine.composerLayers.push(mesh);
          this$1.scene._engine.update();
          this$1._pruneTiles();
          return;
        }
        if (mesh.children.length !== 0) {
          this$1._tiles.add(tile.getMesh());
          this$1._addPickTile(tile.getMesh());
        }
        this$1.scene._engine.update();
        this$1._pruneTiles();
      });
    } else {
      if (tile.getMesh().type === 'composer') {
        this.scene._engine.composerLayers.push(tile.getMesh());
        this.scene._engine.update();
        this._pruneTiles();
        return;
      }
      if (tile.needUpdate) {
        tile.updateColor();
        tile.needUpdate = false;
      }
      this._tiles.add(tile.getMesh());
      t.active = true;
      this._addPickTile(tile.getMesh());
      this._tileKeys.push(key);
      this.scene._engine.update();
      this._pruneTiles();
    }
  };
  TileLayer.prototype._addPickTile = function _addPickTile (meshobj) {
    if (this.type === 'image') {
      return;
    }
    var pickCtr = this.get('pickingController');
    var mesh = meshobj.children[0];
    mesh.name = meshobj.name;
    pickCtr.addPickMesh(mesh);
  };
  // 根据距离优先级查找
  TileLayer.prototype.getSelectFeature = function getSelectFeature (id, lnglat) {
    var zoom = this.tileZoom;

    var tilePoint = this._crs.lngLatToPoint(lib_5(lnglat.lng, lnglat.lat), zoom);
    var tileXY = tilePoint.divideBy(256).floor();
    var key = [ tileXY.x, tileXY.y, zoom ].join('_');
    var tile = this._tileCache.getTile(key);
    var feature = tile ? tile.getSelectFeature(id) : null;
    return { feature: feature };
  };
  TileLayer.prototype._pruneTiles = function _pruneTiles () {
    var tile;
    var zoom = this.tileZoom;
    for (var key in this.tileList) {
      var c = this.tileList[key].coords;
      if (c[2] !== zoom || !this.noPruneRange.contains(new lib_8(c[0], c[1]))) {
        this.tileList[key].current = false;
      }
    }

    for (var key$1 in this.tileList) {
      tile = this.tileList[key$1];
      tile.retain = tile.current;
    }
    for (var key$2 in this.tileList) {
      tile = this.tileList[key$2];
      if (tile.current && !tile.active) {
        var ref = key$2.split('_').map(function (v) { return v * 1; });
        var x = ref[0];
        var y = ref[1];
        var z = ref[2];
        if (!this._retainParent(x, y, z, z - 5)) {
          this._retainChildren(x, y, z, z + 2);
        }
      }

    }
    this._removeOutTiles();
  };
  TileLayer.prototype._retainParent = function _retainParent (x, y, z, minZoom) {
    var x2 = Math.floor(x / 2);
    var y2 = Math.floor(y / 2);
    var z2 = z - 1;
    var tile = this.tileList[[ x2, y2, z2 ].join('_')];
    if (tile && tile.active) {
      tile.retain = true;
      return true;
    } else if (tile && tile.loaded) {
      tile.retain = true;
    }
    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }

    return false;

  };
  TileLayer.prototype._retainChildren = function _retainChildren (x, y, z, maxZoom) {
    for (var i = 2 * x; i < 2 * x + 2; i++) {
      for (var j = 2 * y; j < 2 * y + 2; j++) {
        var key = [ i, j, z + 1 ].join('_');
        var tile = this.tileList[key];
        if (tile && tile.active) {
          tile.retain = true;
          continue;
        } else if (tile && tile.loaded) {
          tile.retain = true;
        }

        if (z + 1 < maxZoom) {
          this._retainChildren(i, j, z + 1, maxZoom);
        }
      }
    }
  };
  // 移除视野外的tile
  TileLayer.prototype._removeOutTiles = function _removeOutTiles () {
    var this$1 = this;

    for (var key in this.tileList) {
      if (!this.tileList[key].retain) {
        var tileObj = this._tileCache.getTile(key);
        if (tileObj) {
          tileObj._abortRequest();
          var pickCtr = this.get('pickingController');
          pickCtr && pickCtr.removePickMeshByName(tileObj.getMesh().name);
          this._tiles.remove(tileObj.getMesh());
        }
        if (tileObj && tileObj.getMesh().type === 'composer') {
          this.scene._engine.composerLayers = this.scene._engine.composerLayers.filter(function (obj) {
            return obj.name !== tileObj.getMesh().name;
          });
        }
        delete this.tileList[key];
      }
    }
    if (this._tiles.children.length > Object.keys(this.tileList).length) {
      this._tiles.children.forEach(function (tile) {
        var key = tile.name;
        if (!this$1.tileList[key]) {
          this$1._tiles.remove(tile);
        }
      });
    } // 移除 空的geom

    this.scene._engine.update();
  };


  TileLayer.prototype._removeTiles = function _removeTiles () {
    this.hide();
    if (!this._tiles || !this._tiles.children) {
      return;
    }

    for (var i = this._tiles.children.length - 1; i >= 0; i--) {
      this._tiles.remove(this._tiles.children[i]);
    }
    this.tileList = [];
    this._tileKeys = [];
    this._tileCache.destory();
    var pickCtr = this.get('pickingController');
    pickCtr.removeAllMesh();
  };
  TileLayer.prototype._getPixelBounds = function _getPixelBounds () {
    var viewPort = this.scene.getBounds().toBounds();
    var NE = viewPort.getNorthEast();
    var SW = viewPort.getSouthWest();
    var zoom = this.tileZoom;
    var center = this.scene.getCenter();
    var NEPoint = this._crs.lngLatToPoint(lib_5(NE.lng, NE.lat), zoom);
    var SWPoint = this._crs.lngLatToPoint(lib_5(SW.lng, SW.lat), zoom);
    var centerPoint = this._crs.lngLatToPoint(lib_5(center.lng, center.lat), zoom);
    var topHeight = centerPoint.y - NEPoint.y;
    var bottomHeight = SWPoint.y - centerPoint.y;
    // 跨日界线的情况
    var leftWidth;
    var rightWidth;
    if (center.lng - NE.lng > 0 || center.lng - SW.lng < 0) {
      var width = Math.pow(2, zoom) * 256 / 360 * (180 - NE.lng) + Math.pow(2, zoom) * 256 / 360 * (SW.lng + 180);
      if (center.lng - NE.lng > 0) { // 日界线在右侧
        leftWidth = Math.pow(2, zoom) * 256 / 360 * (center.lng - NE.lng);
        rightWidth = width - leftWidth;
      } else {
        rightWidth = Math.pow(2, zoom) * 256 / 360 * (SW.lng - center.lng);
        leftWidth = width - rightWidth;
      }
    } else { // 不跨日界线
      leftWidth = Math.pow(2, zoom) * 256 / 360 * (center.lng - SW.lng);
      rightWidth = Math.pow(2, zoom) * 256 / 360 * (NE.lng - center.lng);
    }
    var pixelBounds = new lib_2(centerPoint.subtract(leftWidth, topHeight), centerPoint.add(rightWidth, bottomHeight));
    return pixelBounds;
  };
  TileLayer.prototype._pxBoundsToTileRange = function _pxBoundsToTileRange (pixelBounds) {
    return new lib_2(
      pixelBounds.min.divideBy(256).floor(),
      pixelBounds.max.divideBy(256).ceil().subtract([ 1, 1 ])
    );
  };
  TileLayer.prototype._wrapCoords = function _wrapCoords (coords) {
    var wrapX = [ 0, Math.pow(2, coords[2]) ];
    var newX = util_3(coords[0], wrapX);
    return [ newX, coords[1], coords[2] ];
  };
  TileLayer.prototype._destroyTile = function _destroyTile (tile) {
    tile.destroy();
    tile = null;
  };
  TileLayer.prototype._updateDraw = function _updateDraw () {
    var this$1 = this;

    var preAttrs = this.get('preAttrOptions');
    var nextAttrs = this.get('attrOptions');
    var preStyle = this.get('preStyleOption');
    var nextStyle = this.get('styleOptions');
    if (preAttrs === undefined && preStyle === undefined) { // 首次渲染
      // this._setPreOption();
      this._scaleByZoom();
      this._initControllers();
      this._initInteraction();
      this._initMapEvent();
      this.draw();
      this._setPreOption();
      return;
    }
    if (!this._tiles.children.length > 0 || !this._object3D.visible) {
      return;
    }
    // 更新数据颜色 过滤 filter
    if (!actor.Util.isEqual(preAttrs.color, nextAttrs.color) || !actor.Util.isEqual(preAttrs.filter, nextAttrs.filter)) {
      this._tileCache.setNeedUpdate();
      this._tiles.children.forEach(function (tile) {
        var tileObj = this$1._tileCache.getTile(tile.name);
        tileObj.updateColor();
        tileObj.needUpdate = false;
        this$1.scene._engine.update();
      });
    }
    // 更新Size
    if (!actor.Util.isEqual(preAttrs.size, nextAttrs.size)) ;
    // 更新形状
    if (!actor.Util.isEqual(preAttrs.shape, nextAttrs.shape)) ;
    if (!actor.Util.isEqual(preStyle, nextStyle)) {
      actor.Util.each(diff(preStyle, nextStyle), function (ref) {
        var type = ref.type;
        var key = ref.key;
        var value = ref.value;
        // newStyle[key] = type === 'remove' ? null : value;
      });
      this._tiles.children(function (tile) {
        this$1._tileCache.get(tile.name).updateStyle();
      });
    }
    this._setPreOption();
  };
  TileLayer.prototype.destroy = function destroy () {
  };

  return TileLayer;
}(Layer));

var r2d = 180 / Math.PI;
var tileURLRegex$1 = /\{([zxy])\}/g;
var Tile = /*@__PURE__*/(function (Base) {
  function Tile(key, url, layer) {
    var this$1 = this;

    Base.call(this, {
      scales: {},
      attrs: {}
    });
    this.layer = layer;
    this._tile = key.split('_').map(function (v) { return v * 1; });
    this._path = url;
    this._tileLnglatBounds = this._tileLnglatBounds(this._tile);

    this._tileBounds = this._tileBounds(this._tileLnglatBounds);

    this._center = this._tileBounds.getCenter();

    this._centerLnglat = this._tileLnglatBounds.getCenter();
    this._object3D = new actor.Object3D({ name: key });
    this._object3D.frustumCulled = false;
    // this._object3D.name = key;
    this._object3D.onBeforeRender = function () {
    };
    this._isLoaded = false;
    this.requestTileAsync(function (data) { return this$1._init(data); });
  }

  if ( Base ) Tile.__proto__ = Base;
  Tile.prototype = Object.create( Base && Base.prototype );
  Tile.prototype.constructor = Tile;
  Tile.prototype._init = function _init (data) {
    // this._creatSource(data); // 获取Source
    this.layerSource = data;

    if (this.layerSource.data === null) {
      this.isValid = false;
      return;
    }
    this.isValid = true;
    this._initControllers();
    this._createMesh();
  };
  Tile.prototype.repaint = function repaint () {
    this._initControllers();
    this._createMesh();
  };
  Tile.prototype.requestTileAsync = function requestTileAsync (done) {
    var data = this.layer.tileSource.getTileData(this._tile[0], this._tile[1], this._tile[2]);
    if (data.loaded) {
      done(data.data);
    } else {
      data.data.then(function (data) {
        done(data);
      });
    }
  };
  Tile.prototype._initControllers = function _initControllers () {
    var mappingCtr = new Controller.Mapping({
      layer: this.layer,
      mesh: this
    });
    var bufferCtr = new Controller.Buffer({
      layer: this.layer,
      mesh: this
    });
    this.set('mappingController', mappingCtr);
    this.set('bufferController', bufferCtr);

  };
  Tile.prototype._createMesh = function _createMesh () {};
  Tile.prototype._getTileURL = function _getTileURL (urlParams) {
    if (!urlParams.s) {
      // Default to a random choice of a, b or c
      urlParams.s = String.fromCharCode(97 + Math.floor(Math.random() * 3));
    }

    tileURLRegex$1.lastIndex = 0;
    return this._path.replace(tileURLRegex$1, function(value, key) {
      return urlParams[key];
    });
  };
  // 经纬度范围转瓦片范围
  Tile.prototype._tileBounds = function _tileBounds (lnglatBound) {
    var ne = this.layer.scene.project([ lnglatBound.getNorthEast().lng, lnglatBound.getNorthEast().lat ]);
    var sw = this.layer.scene.project([ lnglatBound.getSouthWest().lng, lnglatBound.getSouthWest().lat ]);
    return lib_3(sw, ne);
  };
  Tile.prototype.getMesh = function getMesh () {
    return this._object3D;
  };


  // Get tile bounds in WGS84 coordinates
  Tile.prototype._tileLnglatBounds = function _tileLnglatBounds (tile) {
    var e = this._tile2lng(tile[0] + 1, tile[2]);
    var w = this._tile2lng(tile[0], tile[2]);
    var s = this._tile2lat(tile[1] + 1, tile[2]);
    var n = this._tile2lat(tile[1], tile[2]);
    return lib_7([ w, n ], [ e, s ]);
  };

  Tile.prototype._tile2lng = function _tile2lng (x, z) {
    return x / Math.pow(2, z) * 360 - 180;
  };

  Tile.prototype._tile2lat = function _tile2lat (y, z) {
    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
    return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  };
  Tile.prototype._retainParent = function _retainParent (x, y, z, minZoom) {
    if ( minZoom === void 0 ) minZoom = 5;

    var x2 = Math.floor(x / 2),
      y2 = Math.floor(y / 2),
      z2 = z - 1,
      coords2 = [ +x2, +y2, +z2 ];
    var tile = this._tiles[coords2]; // 计算保留
    if (tile && tile.active) {
      tile.retain = true;
      return true;

    } else if (tile && tile.loaded) {
      tile.retain = true;
    }

    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }

    return false;
  };
  Tile.prototype.updateColor = function updateColor () {
    var bufferCtr = this.get('bufferController');
    this.get('mappingController').update();
    bufferCtr._updateColorAttributes(this.getMesh().children[0]);
  };
  Tile.prototype.updateStyle = function updateStyle () {
    var bufferCtr = this.get('bufferController');
    bufferCtr._updateStyle(this.getMesh().children[0]);
  };
  Tile.prototype._preRender = function _preRender () {
  };
  Tile.prototype.destroy = function destroy () {
    Base.prototype.destroy.call(this);
    destoryObject(this._object3D);
  };

  return Tile;
}(actor.Base));

var ImageTile = /*@__PURE__*/(function (Tile) {
  function ImageTile () {
    Tile.apply(this, arguments);
  }

  if ( Tile ) ImageTile.__proto__ = Tile;
  ImageTile.prototype = Object.create( Tile && Tile.prototype );
  ImageTile.prototype.constructor = ImageTile;

  ImageTile.prototype.requestTileAsync = function requestTileAsync () {
    var this$1 = this;

    // Making this asynchronous really speeds up the LOD framerate
    setTimeout(function () {
      if (!this$1._mesh) {
        // this._mesh = this._createMesh();
        this$1._requestTile();
      }
    }, 0);
  };
  ImageTile.prototype._requestTile = function _requestTile () {
    var image = this._createDebugMesh();
    this._createMesh(image);
    this.emit('tileLoaded');
    // const urlParams = {
    //   x: this._tile[0],
    //   y: this._tile[1],
    //   z: this._tile[2]
    // };

    // const url = this._getTileURL(urlParams);
    // const image = document.createElement('img');

    // image.addEventListener('load', () => {
    //   this._isLoaded = true;
    //   this._createMesh(image);
    //   this.emit('tileLoaded');
    //   this._ready = true;
    // }, false);

    // image.crossOrigin = '';

    // // Load image
    // image.src = url;

    // this._image = image;
  };
  ImageTile.prototype._getBufferData = function _getBufferData (images) {
    var NW = this._tileBounds.getTopLeft();
    var SE = this._tileBounds.getBottomRight();
    var coordinates = [[ NW.x, NW.y, 0 ], [ SE.x, SE.y, 0 ]];
    return [{
      coordinates: coordinates,
      images: images
    }];
  };
  ImageTile.prototype._createMesh = function _createMesh (image) {
    if (!this._center) {
      return;
    }
    this._layerData = this._getBufferData(image);
    var buffer = new ImageBuffer$1({
      layerData: this._layerData
    });
    buffer.attributes.texture = buffer.texture;
    var style = this.layer.get('styleOptions');
    var mesh = DrawImage$1(buffer.attributes, style);
    this._object3D.add(mesh);
    return this._object3D;
  };
  ImageTile.prototype._createDebugMesh = function _createDebugMesh () {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    context.font = 'Bold 20px Helvetica Neue, Verdana, Arial';
    context.fillStyle = '#ff0000';
    context.fillText(this._tile.join('/'), 20, 20);
    context.strokeStyle = 'red';
    context.rect(0, 0, 256, 256);
    context.stroke();
    return canvas;
  };
  ImageTile.prototype._abortRequest = function _abortRequest () {
    if (!this._image) {
      return;
    }

    this._image.src = '';
  };
  ImageTile.prototype.updateColor = function updateColor () {

  };
  ImageTile.prototype.getSelectFeature = function getSelectFeature () {
    return {};
  };
  ImageTile.prototype.destroy = function destroy () {
    // Cancel any pending requests
    this._abortRequest();

    // Clear image reference
    this._image = null;

    Tile.prototype.destroy.call(this);
  };

  return ImageTile;
}(Tile));

var ImageTileLayer = /*@__PURE__*/(function (TileLayer) {
  function ImageTileLayer(scene, cfg) {
    TileLayer.call(this, scene, cfg);
    this.type = 'image';
  }

  if ( TileLayer ) ImageTileLayer.__proto__ = TileLayer;
  ImageTileLayer.prototype = Object.create( TileLayer && TileLayer.prototype );
  ImageTileLayer.prototype.constructor = ImageTileLayer;
  ImageTileLayer.prototype._createTile = function _createTile (key, layer) {
    return new ImageTile(key, this.url, layer);
  };

  return ImageTileLayer;
}(TileLayer));

var MaskMaterial = /*@__PURE__*/(function (Material) {
  function MaskMaterial(_uniforms, _defines, parameters) {
    Material.call(this, parameters);
    var ref = this.getDefaultParameters();
    var uniforms = ref.uniforms;
    var defines = ref.defines;
    var ref$1 = getModule('mask_quard');
    var vs = ref$1.vs;
    var fs = ref$1.fs;
    this.uniforms = Object.assign(uniforms, this.setUniform(_uniforms));
    this.type = 'MaskMaterial';
    this.defines = Object.assign(defines, _defines);
    this.vertexShader = vs;
    this.fragmentShader = fs;
    this.transparent = true;
  }

  if ( Material ) MaskMaterial.__proto__ = Material;
  MaskMaterial.prototype = Object.create( Material && Material.prototype );
  MaskMaterial.prototype.constructor = MaskMaterial;

  MaskMaterial.prototype.getDefaultParameters = function getDefaultParameters () {
    return {
      uniforms: {
      },
      defines: {

      }
    };
  };

  return MaskMaterial;
}(Material));

var VectorTile = /*@__PURE__*/(function (Tile) {
  function VectorTile () {
    Tile.apply(this, arguments);
  }

  if ( Tile ) VectorTile.__proto__ = Tile;
  VectorTile.prototype = Object.create( Tile && Tile.prototype );
  VectorTile.prototype.constructor = VectorTile;

  VectorTile.prototype._createMesh = function _createMesh () {
    var this$1 = this;

    var layerData = this.layerData;
    if (this.layer.get('layerType') === 'point') {
      this.layer.shape = this.layer._getShape(layerData);
    }
    this.mesh = getRender(this.layer.get('layerType'), this.layer.shape)(layerData, this.layer);
    if (this.mesh.type !== 'composer') { // 热力图的情况
      this.mesh.onBeforeRender = function (renderer) {
        this$1._renderMask(renderer);
      };
      this.mesh.onAfterRender = function (renderer) {
        var context = renderer.context;
        context.clear(context.STENCIL_BUFFER_BIT);
        context.disable(context.STENCIL_TEST);
      };
      this._object3D.add(this.mesh);
    } else { // 如果是热力图
      this._object3D = this.mesh;
    }
    setTimeout(function () {
      this$1.emit('tileLoaded');
    }, 0);
    return this._object3D;
  };
  VectorTile.prototype._renderMask = function _renderMask (renderer) {
    var zoom = this.layer.scene.getZoom();
    updateObjecteUniform(this.mesh, {
      u_time: this.layer.scene._engine.clock.getElapsedTime(),
      u_zoom: zoom
    });
    if (this.layer.get('layerType') === 'point') { // 点图层目前不需要mask
      return;
    }
    var maskScene = new actor.Scene();
    this.maskScene = maskScene;
    var tileMesh = this._tileMaskMesh();
    maskScene.add(tileMesh);
    var context = renderer.context;
    renderer.autoClear = false;
    renderer.clearDepth();
    context.enable(context.STENCIL_TEST);
    context.stencilOp(context.REPLACE, context.REPLACE, context.REPLACE);
    context.stencilFunc(context.ALWAYS, 1, 0xffffffff);
    context.clearStencil(0);
    context.clear(context.STENCIL_BUFFER_BIT);
    context.colorMask(false, false, false, false);

    // config the stencil buffer to collect data for testing
    this.layer.scene._engine.renderScene(maskScene);
    context.colorMask(true, true, true, true);
    context.depthMask(false);
    renderer.clearDepth();

    // only render where stencil is set to 1

    context.stencilFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
    context.stencilOp(context.KEEP, context.KEEP, context.KEEP);
  };
  VectorTile.prototype._tileMaskMesh = function _tileMaskMesh () {
    var tilebound = this._tileBounds;
    var bl = [ tilebound.getBottomLeft().x, tilebound.getBottomLeft().y, 0 ];
    var br = [ tilebound.getBottomRight().x, tilebound.getBottomRight().y, 0 ];
    var tl = [ tilebound.getTopLeft().x, tilebound.getTopLeft().y, 0 ];
    var tr = [ tilebound.getTopRight().x, tilebound.getTopRight().y, 0 ];
    var positions = bl.concat( tr, br, bl, tl, tr );
    var geometry = new actor.BufferGeometry();
    geometry.addAttribute('position', new actor.Float32BufferAttribute(positions, 3));
    var maskMaterial = new MaskMaterial();
    var maskMesh = new actor.Mesh(geometry, maskMaterial);
    return maskMesh;
  };
  VectorTile.prototype._abortRequest = function _abortRequest () {
    if (!this.xhrRequest) {
      return;
    }

    this.xhrRequest.abort();
  };
  VectorTile.prototype.getSelectFeature = function getSelectFeature (id) {
    var featurekey = this.layerSource.originData.featureKeys[id];
    if (featurekey && featurekey.index !== undefined) {
      var featureIndex = featurekey.index;
      return this.layerSource.originData.dataArray[featureIndex];
    }
    return null;
  };
  VectorTile.prototype.destroy = function destroy () {
    Tile.prototype.destroy.call(this);
    destoryObject(this.maskScene);
    this._object3D = null;
    this.maskScene = null;
    this.layerData = null;
  };

  return VectorTile;
}(Tile));

var VectorTileLayer = /*@__PURE__*/(function (TileLayer) {
  function VectorTileLayer () {
    TileLayer.apply(this, arguments);
  }

  if ( TileLayer ) VectorTileLayer.__proto__ = TileLayer;
  VectorTileLayer.prototype = Object.create( TileLayer && TileLayer.prototype );
  VectorTileLayer.prototype.constructor = VectorTileLayer;

  VectorTileLayer.prototype._createTile = function _createTile (key, layer) {
    return new VectorTile(key, this.url, layer);
  };

  return VectorTileLayer;
}(TileLayer));

var TextLayer = /*@__PURE__*/(function (Layer) {
  function TextLayer () {
    Layer.apply(this, arguments);
  }

  if ( Layer ) TextLayer.__proto__ = Layer;
  TextLayer.prototype = Object.create( Layer && Layer.prototype );
  TextLayer.prototype.constructor = TextLayer;

  TextLayer.prototype.shape = function shape (field, values) {
    Layer.prototype.shape.call(this, field, values);
    this.shape = 'text';
    return this;
  };
  TextLayer.prototype.draw = function draw () {
    this.type = 'text';
    this.add(getRender(this.type, this.shape)(this.layerData, this));
  };

  return TextLayer;
}(Layer));

registerLayer('PolygonLayer', PolygonLayer);
registerLayer('PointLayer', PointLayer);
registerLayer('LineLayer', LineLayer);
registerLayer('ImageLayer', imageLayer);
registerLayer('RasterLayer', RasterLayer);
registerLayer('HeatmapLayer', HeatMapLayer);
registerLayer('TileLayer', TileLayer);
registerLayer('ImageTileLayer', ImageTileLayer);
registerLayer('VectorTileLayer', VectorTileLayer);
registerLayer('TextLayer', TextLayer);

// 将图片标注绘制在512*512的画布上，每个大小 64*64 支持 64种图片
var LoadImage = /*@__PURE__*/(function (EventEmitter) {
  function LoadImage() {
    EventEmitter.call(this);
    var pixelRatio = window.devicePixelRatio || 1;
    this.imageWidth = 64 * pixelRatio;
    this.canvas = document.createElement('canvas');
    this.canvas.style.cssText += 'height: 512px;width: 512px;';
    this.canvas.width = this.imageWidth * 8;
    this.canvas.height = this.imageWidth * 8;
    this.ctx = this.canvas.getContext('2d');
    this.images = [];
    this.imagesCount = 0;
    this.imagePos = {};
    this.imagesIds = [];
  }

  if ( EventEmitter ) LoadImage.__proto__ = EventEmitter;
  LoadImage.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  LoadImage.prototype.constructor = LoadImage;
  LoadImage.prototype.addImage = function addImage (id, opt) {
    var this$1 = this;

    this.imagesCount++;
    this.imagesIds.push(id);
    var imageCount = this.imagesCount;
    var x = imageCount % 8 * this.imageWidth;
    var y = parseInt(imageCount / 8) * this.imageWidth;
    this.imagePos[id] = { x: x / this.canvas.width, y: y / this.canvas.height };
    this.texture = new actor.Texture(this.canvas);
    if (typeof opt === 'string') {
      actor.getImage({ url: opt }, function (err, img) {
        img.id = id;
        this$1.images.push(img);
        this$1.ctx.drawImage(img, x, y, this$1.imageWidth, this$1.imageWidth);
        this$1.texture.magFilter = actor.LinearFilter;
        this$1.texture.minFilter = actor.LinearFilter;
        this$1.texture.needsUpdate = true;
        this$1.emit('imageLoaded');

      });
    } else {
      var width = opt.width;
      var height = opt.height;
      var channels = opt.channels;
      var data = new Uint8Array(width * height * channels);
      var image = new Image();
      image.width = width;
      image.height = height;
      image.data = data;
      image.id = id;
      this.images.push(image);
      this.ctx.drawImage(image, x, y, this.imageWidth, this.imageWidth);
      this.texture = new actor.CanvasTexture(this.canvas);
      this.imagePos[id] = { x: x >> 9, y: y >> 9 };
      this.texture.needsUpdate = true;
      this.emit('imageLoaded');
    }

  };
  LoadImage.prototype.removeImage = function removeImage () {
  // todo

  };

  return LoadImage;
}(actor.EventEmitter));

var tinySdf = TinySDF;
var default_1 = TinySDF;

var INF = 1e20;

function TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
    this.fontSize = fontSize || 24;
    this.buffer = buffer === undefined ? 3 : buffer;
    this.cutoff = cutoff || 0.25;
    this.fontFamily = fontFamily || 'sans-serif';
    this.fontWeight = fontWeight || 'normal';
    this.radius = radius || 8;
    var size = this.size = this.fontSize + this.buffer * 2;

    this.canvas = document.createElement('canvas');
    this.canvas.width = this.canvas.height = size;

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;
    this.ctx.textBaseline = 'middle';
    this.ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.d = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Int16Array(size);

    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
}

TinySDF.prototype.draw = function (char) {
    this.ctx.clearRect(0, 0, this.size, this.size);
    this.ctx.fillText(char, this.buffer, this.middle);

    var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
    var alphaChannel = new Uint8ClampedArray(this.size * this.size);

    for (var i = 0; i < this.size * this.size; i++) {
        var a = imgData.data[i * 4 + 3] / 255; // alpha value
        this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
    }

    edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);
    edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);

    for (i = 0; i < this.size * this.size; i++) {
        var d = this.gridOuter[i] - this.gridInner[i];
        alphaChannel[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));
    }

    return alphaChannel;
};

// 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
function edt(data, width, height, f, d, v, z) {
    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
            data[y * width + x] = d[y];
        }
    }
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
            data[y * width + x] = Math.sqrt(d[x]);
        }
    }
}

// 1D squared distance transform
function edt1d(f, d, v, z, n) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = +INF;

    for (var q = 1, k = 0; q < n; q++) {
        var s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
            k--;
            s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
    }

    for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q) { k++; }
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
    }
}
tinySdf.default = default_1;

/**
 * tiny-sdf 中每个 glyph 的宽度（加上 buffer 24 + 3 + 3 = 30）
 */
var glyphSizeInSDF = 30;

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

function buildMapping(ref) {
  var characterSet = ref.characterSet;
  var getFontWidth = ref.getFontWidth;
  var fontHeight = ref.fontHeight;
  var buffer = ref.buffer;
  var maxCanvasWidth = ref.maxCanvasWidth;
  var mapping = ref.mapping; if ( mapping === void 0 ) mapping = {};
  var xOffset = ref.xOffset; if ( xOffset === void 0 ) xOffset = 0;
  var yOffset = ref.yOffset; if ( yOffset === void 0 ) yOffset = 0;

  var row = 0;
  var x = xOffset;
  Array.from(characterSet).forEach(function (char, i) {
    if (!mapping[char]) {
      var width = getFontWidth(char, i);
      if (x + glyphSizeInSDF > maxCanvasWidth) {
      // if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }
      mapping[char] = {
        // x: x + buffer,
        x: x,
        y: yOffset + row * glyphSizeInSDF,
        // y: yOffset + row * (fontHeight + buffer * 2) + buffer,
        width: glyphSizeInSDF,
        // height: fontHeight,
        height: glyphSizeInSDF,
        advance: width
      };
      // x += width + buffer * 2;
      x += glyphSizeInSDF;
    }
  });

  var rowHeight = fontHeight + buffer * 2;

  return {
    mapping: mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}

var DEFAULT_CHAR_SET = getDefaultCharacterSet();
var DEFAULT_FONT_FAMILY = 'sans-serif';
var DEFAULT_FONT_WEIGHT = 'normal';
var DEFAULT_FONT_SIZE = 24;
var DEFAULT_BUFFER = 3;
var DEFAULT_CUTOFF = 0.25;
var DEFAULT_RADIUS = 8;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 1.0;
var HEIGHT_SCALE = 1.0;
var CACHE_LIMIT = 3;
var cache = new LRUCache(CACHE_LIMIT);

var VALID_PROPS = [
  'fontFamily',
  'fontWeight',
  'characterSet',
  'fontSize',
  'sdf',
  'buffer',
  'cutoff',
  'radius'
];

function getDefaultCharacterSet() {
  var charSet = [];
  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = fontWeight + " " + fontSize + "px " + fontFamily;
  ctx.fillStyle = 'black';
  ctx.textBaseline = 'middle';
  // ctx.textAlign = 'left';
}
function getNewChars(key, characterSet) {
  var cachedFontAtlas = cache.get(key);
  if (!cachedFontAtlas) {
    return characterSet;
  }

  var newChars = [];
  var cachedMapping = cachedFontAtlas.mapping;
  var cachedCharSet = Object.keys(cachedMapping);
  cachedCharSet = new Set(cachedCharSet);

  var charSet = characterSet;
  if (charSet instanceof Array) {
    charSet = new Set(charSet);
  }

  charSet.forEach(function (char) {
    if (!cachedCharSet.has(char)) {
      newChars.push(char);
    }
  });

  return newChars;
}

function populateAlphaChannel(alphaChannel, imageData) {
  // populate distance value from tinySDF to image alpha channel
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

var FontAtlasManager = function FontAtlasManager() {

  // font settings
  this.props = {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: DEFAULT_FONT_WEIGHT,
    characterSet: DEFAULT_CHAR_SET,
    fontSize: DEFAULT_FONT_SIZE,
    buffer: DEFAULT_BUFFER,
    // sdf only props
    // https://github.com/mapbox/tiny-sdf
    sdf: true,
    cutoff: DEFAULT_CUTOFF,
    radius: DEFAULT_RADIUS
  };

  // key is used for caching generated fontAtlas
  this._key = null;
  this._texture = new actor.Texture();
};

var prototypeAccessors = { texture: { configurable: true },mapping: { configurable: true },scale: { configurable: true },fontAtlas: { configurable: true } };

prototypeAccessors.texture.get = function () {
  return this._texture;
};

prototypeAccessors.mapping.get = function () {
  var data = cache.get(this._key);
  return data && data.mapping;
};

prototypeAccessors.scale.get = function () {
  return HEIGHT_SCALE;
};

prototypeAccessors.fontAtlas.get = function () {
  return this._fontAtlas;
};

FontAtlasManager.prototype.setProps = function setProps (props) {
    var this$1 = this;
    if ( props === void 0 ) props = {};

  VALID_PROPS.forEach(function (prop) {
    if (prop in props) {
      this$1.props[prop] = props[prop];
    }
  });

  // update cache key
  var oldKey = this._key;
  this._key = this._getKey();

  var charSet = getNewChars(this._key, this.props.characterSet);
  var cachedFontAtlas = cache.get(this._key);

  // if a fontAtlas associated with the new settings is cached and
  // there are no new chars
  if (cachedFontAtlas && charSet.length === 0) {
    // update texture with cached fontAtlas
    if (this._key !== oldKey) {
      this._updateTexture(cachedFontAtlas);
    }
    return;
  }

  // update fontAtlas with new settings
  var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);
  this._fontAtlas = fontAtlas;
  this._updateTexture(fontAtlas);

  // update cache
  cache.set(this._key, fontAtlas);
};

FontAtlasManager.prototype._updateTexture = function _updateTexture (ref) {
    var canvas = ref.data;

  this._texture = new actor.CanvasTexture(canvas);
  this._texture.minFilter = actor.LinearFilter;
  this._texture.magFilter = actor.LinearFilter;
  this._texture.flipY = false;
  this._texture.format = actor.AlphaFormat;
  this._texture.needUpdate = true;
};

FontAtlasManager.prototype._generateFontAtlas = function _generateFontAtlas (key, characterSet, cachedFontAtlas) {
  var ref = this.props;
    var fontFamily = ref.fontFamily;
    var fontWeight = ref.fontWeight;
    var fontSize = ref.fontSize;
    var buffer = ref.buffer;
    var sdf = ref.sdf;
    var radius = ref.radius;
    var cutoff = ref.cutoff;
  var canvas = cachedFontAtlas && cachedFontAtlas.data;
  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.width = MAX_CANVAS_WIDTH;
  }
  var ctx = canvas.getContext('2d');

  setTextStyle(ctx, fontFamily, fontSize, fontWeight);

  // 1. build mapping
  var ref$1 = buildMapping(
    Object.assign(
      {
        getFontWidth: function (char) { return ctx.measureText(char).width; },
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer: buffer,
        characterSet: characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH
      },
      cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    )
  );
    var mapping = ref$1.mapping;
    var canvasHeight = ref$1.canvasHeight;
    var xOffset = ref$1.xOffset;
    var yOffset = ref$1.yOffset;

  // 2. update canvas
  // copy old canvas data to new canvas only when height changed
  if (canvas.height !== canvasHeight) {
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    canvas.height = canvasHeight;
    ctx.putImageData(imageData, 0, 0);
  }
  setTextStyle(ctx, fontFamily, fontSize, fontWeight);

  // 3. layout characters
  if (sdf) {
    var tinySDF = new tinySdf(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
    // used to store distance values from tinySDF
    // tinySDF.size equals `fontSize + buffer * 2`
    var imageData$1 = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);

    for (var i = 0, list = characterSet; i < list.length; i += 1) {
      var char = list[i];

        populateAlphaChannel(tinySDF.draw(char), imageData$1);
      // 考虑到描边，需要保留 sdf 的 buffer，不能像 deck.gl 一样直接减去
      ctx.putImageData(imageData$1, mapping[char].x, mapping[char].y);
    }
  } else {
    for (var i$1 = 0, list$1 = characterSet; i$1 < list$1.length; i$1 += 1) {
      var char$1 = list$1[i$1];

        ctx.fillText(char$1, mapping[char$1].x, mapping[char$1].y + fontSize * BASELINE_SCALE);
    }
  }
  return {
    xOffset: xOffset,
    yOffset: yOffset,
    mapping: mapping,
    data: canvas,
    width: canvas.width,
    height: canvas.height
  };
};

FontAtlasManager.prototype._getKey = function _getKey () {
  var ref = this.props;
    var fontFamily = ref.fontFamily;
    var fontWeight = ref.fontWeight;
    var fontSize = ref.fontSize;
    var buffer = ref.buffer;
    var sdf = ref.sdf;
    var radius = ref.radius;
    var cutoff = ref.cutoff;
  if (sdf) {
    return (fontFamily + " " + fontWeight + " " + fontSize + " " + buffer + " " + radius + " " + cutoff);
  }
  return (fontFamily + " " + fontWeight + " " + fontSize + " " + buffer);
};

Object.defineProperties( FontAtlasManager.prototype, prototypeAccessors );

var point_frag = "precision highp float;\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nuniform float u_strokeWidth;uniform vec4 u_stroke;uniform sampler2D u_texture;varying vec2 v_rs;varying vec2 v_uv;varying vec4 v_color;varying float v_shape;const float u_buffer=.75;const float u_gamma=.08;const vec3 halo=vec3(1.);void main(){\n#ifdef TEXCOORD_0\nvec2 pos=v_uv+gl_PointCoord/512.*64.;pos.y=1.-pos.y;vec4 textureColor=texture2D(u_texture,pos);gl_FragColor=textureColor;\n#pragma include \"pick\"\nreturn;\n#endif\nif(v_color.a==0.)discard;vec4 pcolor=v_color;float ro=v_rs.x;float ri=v_rs.y;float d=0.;if(ro<3.){gl_FragColor=pcolor;return;}vec2 st=gl_PointCoord*2.-1.;float a=atan(st.x,st.y)+PI;float r=TWO_PI/v_shape;float ratio=1.+(1.1-smoothstep(2.8,6.,v_shape));float dis2center=cos(floor(.5+a/r)*r-a)*length(st)*ro*ratio;float alpha=smoothstep(ro,ro+.1,dis2center);if(alpha==1.){discard;}if(u_strokeWidth>0.){if(dis2center>ro-u_strokeWidth){gl_FragColor=vec4(u_stroke.xyz,u_stroke.a*(ro-dis2center));return;}else if(dis2center>ri){gl_FragColor=u_stroke;return;}}if(dis2center>ri-u_strokeWidth){float factor=ri-dis2center;if(u_strokeWidth==0.){float a=pcolor.a*factor;gl_FragColor=vec4(pcolor.rgb,a);}else{float a=u_stroke.a*(1.-factor)+pcolor.a*factor;gl_FragColor=vec4(u_stroke.rgb*(1.-factor)+pcolor.rgb*factor,a);}}else{gl_FragColor=pcolor;}\n#pragma include \"pick\"\n}";

var point_vert = "precision highp float;attribute vec4 a_color;attribute float a_size;attribute float a_shape;uniform vec4 u_stroke;uniform float u_strokeWidth;uniform float u_opacity;uniform float u_zoom;varying vec4 v_color;varying vec2 v_rs;varying vec2 v_uv;varying float v_shape;uniform float u_activeId;uniform vec4 u_activeColor;void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;v_color=a_color;v_color.a*=u_opacity;if(pickingId==u_activeId) {v_color=u_activeColor;}gl_Position= matModelViewProjection *vec4(position,1.0);gl_PointSize=a_size;v_rs=vec2(a_size/2.0,a_size/2.0-u_strokeWidth);\n#ifdef TEXCOORD_0\nv_uv=uv;\n#endif\n#ifdef SHAPE\nv_shape=a_shape;\n#endif\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var polygon_frag = "precision highp float;uniform vec4 u_baseColor : [ 1.0,0,0,1.0 ];uniform vec4 u_brightColor : [ 1.0,0,0,1.0 ];uniform vec4 u_windowColor : [ 1.0,0,0,1.0 ];uniform float u_zoom : 0;uniform float u_time : 0;uniform float u_near : 0;uniform float u_far : 1;\n#ifdef ANIMATE\nvarying vec2 v_texCoord;\n#endif\nvarying vec4 v_color;vec3 getWindowColor(float n,float hot,vec3 brightColor,vec3 darkColor) {float s=step(hot,n);vec3 color=mix(brightColor,vec3(0.9,0.9,1.0),n);return mix(darkColor,color,s);}float random (vec2 st) {return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}float LinearizeDepth() \n{float z=gl_FragCoord.z*2.0-1.0;  \nreturn (2.0*u_near*u_far)/(u_far+u_near-z*(u_far-u_near));\t\n}vec3 fog(vec3 color,vec3 fogColor,float depth){float fogFactor=clamp(depth,0.0,1.0);vec3 output_color=mix(fogColor,color,fogFactor);return output_color;}float sdRect(vec2 p,vec2 sz) {  \nvec2 d=abs(p)-sz;float outside=length(max(d,0.));float inside=min(max(d.x,d.y),0.);return outside+inside;}void main() {if(v_color.w==0.0) {discard;return;}vec3 baseColor=u_baseColor.xyz;vec3 brightColor=u_brightColor.xyz;vec3 windowColor=u_windowColor.xyz;float targetColId=5.;float depth=1.0-LinearizeDepth()/u_far*u_zoom;  \nvec3 fogColor=vec3(23.0/255.0,31.0/255.0,51.0/255.0); \n#ifdef ANIMATE \nif(v_texCoord.x < 0.) {vec3 foggedColor=fog(baseColor.xyz+vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);gl_FragColor=vec4( foggedColor,v_color.w);}else {vec2 st=v_texCoord; \nvec2  UvScale=v_texCoord;float tStep=min(0.08,max(0.05*(18.0-u_zoom),0.02));float tStart=0.25*tStep;float tEnd=0.75*tStep;float u=mod(UvScale.x,tStep);float v=mod(UvScale.y,tStep);float ux=floor(UvScale.x/tStep);float uy=floor(UvScale.y/tStep);float n=random(vec2(ux,uy));float lightP=u_time;float head=1.0-step(0.005,st.y);/*step3*/float sU=step(tStart,u)-step(tEnd,u);float sV=step(tStart,v)-step(tEnd,v);vec2 windowSize=vec2(abs(tEnd-tStart),abs(tEnd-tStart));float dist=sdRect(vec2(u,v),windowSize);float s=sU*sV;float curColId=floor(UvScale.x/tStep);float sCol=step(targetColId-0.2,curColId)-step(targetColId+0.2,curColId);float mLightP=mod(lightP,2.);float sRow=step(mLightP-0.2,st.y)-step(mLightP,st.y);if(ux==targetColId){n=0.;}float timeP=min(0.75,abs ( sin(u_time/6.0) ) );float hot=smoothstep(1.0,0.0,timeP);vec3 color=mix(baseColor,getWindowColor(n,hot,brightColor,windowColor),s);float sFinal=s*sCol*sRow;color+=mix(baseColor,brightColor,sFinal*n);color=color*v_color.rgb;vec3 foggedColor=fog(color,fogColor,depth);gl_FragColor=vec4(foggedColor,1.0); \n}\n#else\ngl_FragColor=vec4(v_color.xyz,v_color.w);\n#endif\n#pragma include \"pick\"\n}";

var polygon_vert = "precision highp float;attribute vec4 a_color; \n#ifdef SHAPE\nattribute vec3 a_size;attribute vec3 a_shape;\n#endif\n#ifdef ANIMATE\nattribute vec2 faceUv;varying vec2 v_texCoord;\n#endif\nvarying vec4 v_color;uniform float u_zoom : 0;uniform float u_opacity : 1.0;uniform float u_activeId :-1;uniform vec4 u_activeColor : [1.0,0.0,0.0,1.0];\n#pragma include \"lighting\"\nvoid main() {\n#ifdef ANIMATE\nv_texCoord=faceUv;\n#endif\nv_color=a_color;v_color.a*=u_opacity;float scale=pow(2.0,(20.0-u_zoom));vec3 offset=vec3(0.);\n#ifdef SHAPE\noffset=vec3(a_size*scale*a_shape);\n#endif\ngl_Position=projectionMatrix*modelViewMatrix*vec4(position+offset,1.);\n#ifdef LIGHTING\nif (normal !=vec3(0.,0.,1.0)) {vec3 viewDir=normalize(cameraPosition-position);v_color.rgb*=calc_lighting(position,normal,viewDir);}\n#endif\nif(pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var grid_frag = "precision highp float;varying vec4 v_color;void main() {gl_FragColor=v_color;\n#pragma include \"pick\"\n}";

var grid_vert = "precision highp float;attribute vec3 miter;attribute vec4 a_color;uniform float u_xOffset;uniform float u_yOffset;uniform float u_coverage;uniform float u_opacity;uniform float u_activeId;uniform vec4 u_activeColor;varying vec4 v_color;\n#pragma include \"lighting\"\nvoid main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;v_color=a_color;v_color.a*=u_opacity;if(pickingId==u_activeId) {v_color=u_activeColor;}float x=position.x+miter.x*u_xOffset*u_coverage;float y=position.y+miter.y*u_yOffset*u_coverage;float z=position.z+miter.z;\n#ifdef LIGHTING\nvec3 viewDir=normalize(cameraPosition-vec3(x,y,z));v_color.rgb*=calc_lighting(vec3(x,y,z),normal,viewDir);\n#endif\ngl_Position=matModelViewProjection*vec4(x,y,z,1.0);\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var hexagon_frag = "precision highp float;varying vec4 v_color;void main() {gl_FragColor=v_color;\n#pragma include \"pick\"\n}";

var hexagon_vert = "precision highp float;attribute vec3 miter;attribute vec3 a_shape;attribute float a_size;attribute vec4 a_color;uniform float u_radius;uniform float u_coverage;uniform float u_opacity;uniform float u_angle;uniform float u_activeId;uniform vec4 u_activeColor;varying vec4 v_color;\n#pragma include \"lighting\"\nvoid main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;mat2 rotationMatrix=mat2(cos(u_angle),sin(u_angle),-sin(u_angle),cos(u_angle));v_color=a_color;v_color.a*=u_opacity;if(pickingId==u_activeId) {v_color=u_activeColor;}vec2 offset=vec2(rotationMatrix*miter.xy*u_radius*u_coverage );float x=position.x+offset.x;float y=position.y+offset.y;float z=miter.z*a_size;\n#ifdef LIGHTING\nvec3 viewDir=normalize(cameraPosition-vec3(x,y,z));v_color.rgb*=calc_lighting(vec3(x,y,z),normal,viewDir);\n#endif\ngl_Position=matModelViewProjection*vec4(x,y,z,1.0);\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var circle_frag = "uniform float u_blur : 0;uniform float u_opacity : 1;uniform float u_strokeWidth : 1;uniform vec4 u_stroke : [1,1,1,1];uniform float u_strokeOpacity : 1;varying vec4 v_data;varying vec4 v_color;varying float v_radius;\n#pragma include \"sdf_2d\"\nvoid main() {int shape=int(v_data.w);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(u_blur,antialiasblur);float r=v_radius/(v_radius+u_strokeWidth);float outer_df;float inner_df;if (shape==0) {outer_df=sdCircle(v_data.xy,1.0);inner_df=sdCircle(v_data.xy,r);} else if (shape==1) {outer_df=sdEquilateralTriangle(1.1*v_data.xy);inner_df=sdEquilateralTriangle(1.1/r*v_data.xy);} else if (shape==2) {outer_df=sdBox(v_data.xy,vec2(1.));inner_df=sdBox(v_data.xy,vec2(r));} else if (shape==3) {outer_df=sdPentagon(v_data.xy,0.8);inner_df=sdPentagon(v_data.xy,r*0.8);} else if (shape==4) {outer_df=sdHexagon(v_data.xy,0.8);inner_df=sdHexagon(v_data.xy,r*0.8);} else if (shape==5) {outer_df=sdOctogon(v_data.xy,1.0);inner_df=sdOctogon(v_data.xy,r);} else if (shape==6) {outer_df=sdHexagram(v_data.xy,0.52);inner_df=sdHexagram(v_data.xy,r*0.52);} else if (shape==7) {outer_df=sdRhombus(v_data.xy,vec2(1.0));inner_df=sdRhombus(v_data.xy,vec2(r));} else if (shape==8) {outer_df=sdVesica(v_data.xy,1.1,0.8);inner_df=sdVesica(v_data.xy,r*1.1,r*0.8);}float opacity_t=smoothstep(0.0,antialiased_blur,outer_df);float color_t=u_strokeWidth < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,inner_df\n);gl_FragColor=opacity_t*mix(v_color*u_opacity,u_stroke*u_strokeOpacity*v_color.a,color_t);\n#pragma include \"pick\"\n}";

var circle_vert = "\nattribute vec4 a_color;attribute float a_size;attribute float a_shape;attribute vec2 miter;uniform float u_zoom : 1;uniform float u_stroke_width : 2;uniform float u_activeId : 0;uniform vec4 u_activeColor : [ 1.0,0,0,1.0 ];varying vec4 v_data;varying vec4 v_color;varying float v_radius;\n#pragma include \"decode\"\nvoid main() {v_color=a_color;vec2 extrude=miter;float radius=a_size;v_radius=radius;float zoom_scale=pow(2.,20.-u_zoom);vec2 offset=miter*(radius+u_stroke_width)*zoom_scale;gl_Position=projectionMatrix*modelViewMatrix*vec4(position.xy+offset,0.0,1.0);float antialiasblur=1.0/(radius+u_stroke_width);v_data=vec4(extrude,antialiasblur,a_shape);if(pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var point_line_frag = "precision highp float;varying float v_pickingId;varying vec4 v_color;void main() {if(v_pickingId <-0.1) {discard;}\n#ifdef ANIMATE \nif (vTime > 1.0 || vTime < 0.0) {discard;} \n#endif\ngl_FragColor=v_color;\n#pragma include \"pick\"\n}";

var point_line_vert = "precision highp float;attribute float a_miter;attribute vec3 a_size;attribute vec3 a_shape;uniform float u_strokeWidth;uniform float u_strokeOpacity;uniform vec4 u_activeColor;uniform float u_activeId;uniform vec4 u_stroke;uniform float u_zoom;uniform float u_time;varying float vTime;varying float v_pickingId;varying vec4 v_color;void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;float scale=pow(2.0,(20.0-u_zoom));vec3 newposition=position+(a_size+vec3(u_strokeWidth/2.,u_strokeWidth/2.,0))*scale*a_shape+vec3(0.,a_size.y*scale/4.,0.);;\n#ifdef ANIMATE \nvTime=1.0-(mod(u_time*50.,3600.)-position.z)/100.;\n#endif\nv_color=u_stroke;v_color.a*=u_strokeOpacity;v_pickingId=pickingId;if(v_pickingId==u_activeId) {v_color=u_activeColor;}vec3 pointPos=newposition.xyz+vec3(normal*u_strokeWidth*scale/2.0*a_miter);gl_Position=matModelViewProjection*vec4(pointPos,1.0);\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var normal_point_frag = "precision highp float;varying vec4 v_color;void main(){gl_FragColor=v_color;}";

var normal_point_vert = "precision highp float;attribute vec4 a_color;attribute float a_size;varying vec4 v_color;uniform float u_activeId;uniform vec4 u_activeColor;uniform float u_opacity;void main(){mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;v_color=a_color;v_color.a*=u_opacity;if(pickingId==u_activeId){v_color=u_activeColor;}gl_Position=matModelViewProjection*vec4(position,1.);gl_PointSize=a_size;\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var mesh_line_frag = "precision highp float;uniform float u_opacity : 1.0;uniform float u_dash_offset : 0.0;uniform float u_dash_ratio : 0.0;uniform float u_blur : 0.9;varying vec4 v_color;uniform float u_time : 0;\n#if defined DASHLINE  || defined ANIMATE\nvarying float v_distance_ratio;\n#endif\nvarying float v_dash_array;varying float v_time;varying vec2 v_normal;\n#ifdef TEXTURE\nuniform sampler2D u_texture;varying vec2 v_uv;varying float v_texture_y;varying float v_texture_percent;\n#endif\n#ifdef ANIMATE \nuniform float u_duration : 2.0;uniform float u_interval : 1.0;uniform float u_trailLength : 0.2;\n#endif\nvoid main() {\n#ifdef TEXTURE\nfloat texture_y_fract=fract(v_texture_y);if (texture_y_fract <=v_texture_percent) {vec4 tex_color=texture2D(u_texture,vec2(v_uv.x,1.0-0.125-v_uv.y+(texture_y_fract/v_texture_percent)*0.125));gl_FragColor=vec4(mix(v_color.rgb,tex_color.rgb,tex_color.a),v_color.a);} else {gl_FragColor=v_color;}\n#else\ngl_FragColor=v_color;\n#endif\n#ifdef DASHLINE\nfloat time=0.;\n#ifdef ANIMATE \ntime=u_time/1000.;\n#endif\ngl_FragColor.a*=u_opacity*ceil(mod(v_distance_ratio+u_dash_offset+time,v_dash_array)-(v_dash_array*u_dash_ratio));\n#else\ngl_FragColor.a*=u_opacity;\n#endif\n#ifdef ANIMATE \nfloat alpha=1.0-fract( mod(1.0-v_distance_ratio,u_interval)*(1.0/u_interval)+u_time/u_duration);alpha=(alpha+u_trailLength-1.0)/u_trailLength;alpha=smoothstep(0.,1.,alpha);gl_FragColor.a*=alpha;\n#endif\nfloat blur=1.-smoothstep(u_blur,1.,length(v_normal));gl_FragColor.a*=blur;\n#pragma include \"pick\"\n}";

var mesh_line_vert = "attribute float a_miter;attribute vec4 a_color;attribute float a_size;attribute float a_distance;attribute float a_dash_array;attribute float a_total_distance;uniform float u_zoom;uniform float u_time : 0;uniform float u_activeId : 0;uniform vec4 u_activeColor : [ 1.0,0,0,1.0 ];varying float v_time;varying vec4 v_color;varying float v_dash_array;varying vec2 v_normal;\n#if defined DASHLINE  || defined ANIMATE\nvarying float v_distance_ratio;\n#endif\n#ifdef ANIMATE \nuniform float u_duration : 2.0;uniform float u_interval : 1.0;uniform float u_trailLength : 0.2;\n#endif\n#ifdef TEXTURE\nattribute vec2 a_texture_coord;uniform float u_pattern_spacing : 0.0;varying vec2 v_uv;varying float v_texture_y;varying float v_texture_percent;\n#endif\nvoid main() {float extrude_scale=pow(2.0,20.0-u_zoom);v_color=a_color;v_dash_array=a_dash_array*pow(2.0,20.0-u_zoom);float distance_ratio=a_distance/a_total_distance;\n#if defined DASHLINE  || defined ANIMATE\nv_distance_ratio=distance_ratio;\n#endif\n#ifdef TEXTURE\nv_uv=vec2(a_texture_coord.x+0.125,a_texture_coord.y);if (a_miter > 0.0) {v_uv.x=a_texture_coord.x;}v_texture_y=a_distance/extrude_scale/(a_size+u_pattern_spacing);v_texture_percent=a_size/(a_size+u_pattern_spacing);\n#endif\nv_normal=vec2(normal*sign(a_miter));vec3 offset=vec3(normal*a_size*extrude_scale/2.0*a_miter);gl_Position=projectionMatrix*modelViewMatrix*vec4(position.xy+offset.xy,0.,1.0);if(pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var arc_line_frag = "precision mediump float;uniform float u_opacity;varying vec4 v_color;uniform float u_time : 0;\n#if defined DASHLINE  || defined ANIMATE\nvarying float v_distance_ratio;\n#endif\n#ifdef ANIMATE \nuniform float u_duration : 2.0;uniform float u_interval : 1.0;uniform float u_trailLength : 0.2;\n#endif\nvoid main() {if(v_color.a==0.){discard;}gl_FragColor=v_color;gl_FragColor.a=v_color.a*u_opacity;\n#ifdef ANIMATE\nfloat alpha=1.0-fract( mod(1.0-v_distance_ratio,u_interval)*(1.0/u_interval)+u_time/u_duration);gl_FragColor.a*=alpha;\n#endif\n#pragma include \"pick\"\n}";

var arc_line_vert = "precision mediump float;attribute vec4 a_color;attribute vec4 a_instance;attribute float a_size;uniform float u_zoom;uniform float u_time;uniform float u_activeId : 0;uniform vec4 u_activeColor : [ 1.0,0,0,1.0 ];uniform mat4 matModelViewProjection;uniform float segmentNumber;  \nvarying vec4 v_color;\n#ifdef ANIMATE\nvarying float v_distance_ratio;\n#endif\nfloat maps (float value,float start1,float stop1,float start2,float stop2) {return start2+(stop2-start2)*((value-start1)/(stop1-start1));}float getSegmentRatio(float index) {return smoothstep(0.0,1.0,index/(segmentNumber-1.0));}float paraboloid(vec2 source,vec2 target,float ratio) {vec2 x=mix(source,target,ratio);vec2 center=mix(source,target,0.5);float dSourceCenter=distance(source,center);float dXCenter=distance(x,center);return (dSourceCenter+dXCenter)*(dSourceCenter-dXCenter);}vec3 getPos(vec2 source,vec2 target,float segmentRatio) {float vertex_height=paraboloid(source,target,segmentRatio);return vec3(mix(source,target,segmentRatio),sqrt(max(0.0,vertex_height)));}vec2 getExtrusionOffset(vec2 line_clipspace,float offset_direction) {vec2 dir_screenspace=normalize(line_clipspace);dir_screenspace=vec2(-dir_screenspace.y,dir_screenspace.x);vec2 offset=dir_screenspace*offset_direction*a_size*pow(2.0,20.0-u_zoom)/2.0;return offset;}void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;vec2 source=a_instance.rg;vec2 target=a_instance.ba;float segmentIndex=position.x;float segmentRatio=getSegmentRatio(segmentIndex);float indexDir=mix(-1.0,1.0,step(segmentIndex,0.0));float nextSegmentRatio=getSegmentRatio(segmentIndex+indexDir);vec3 curr=getPos(source,target,segmentRatio);vec3 next=getPos(source,target,nextSegmentRatio);vec2 offset=getExtrusionOffset((next.xy-curr.xy)*indexDir,position.y);\n#ifdef ANIMATE\nv_distance_ratio=segmentIndex/segmentNumber;\n#endif\ngl_Position=matModelViewProjection*vec4(vec3(curr+vec3(offset,0.0)),1.0);v_color=a_color;if(pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var great_circle_line_vert = "#define PI 3.1415926535\nprecision mediump float;attribute vec4 a_color;attribute vec4 a_instance;attribute float a_size;uniform float u_zoom;uniform float u_time;uniform float u_activeId : 0;uniform vec4 u_activeColor : [ 1.0,0,0,1.0 ];uniform mat4 matModelViewProjection;uniform float segmentNumber;  \nvarying vec4 v_color;\n#ifdef ANIMATE\nvarying float v_distance_ratio;\n#endif\n#pragma include \"project\"\nfloat maps (float value,float start1,float stop1,float start2,float stop2) {return start2+(stop2-start2)*((value-start1)/(stop1-start1));}float getSegmentRatio(float index) {return smoothstep(0.0,1.0,index/(segmentNumber-1.));}float paraboloid(vec2 source,vec2 target,float ratio) {vec2 x=mix(source,target,ratio);vec2 center=mix(source,target,0.5);float dSourceCenter=distance(source,center);float dXCenter=distance(x,center);return (dSourceCenter+dXCenter)*(dSourceCenter-dXCenter);}vec3 getPos(vec2 source,vec2 target,float segmentRatio) {float vertex_height=paraboloid(source,target,segmentRatio);return vec3(mix(source,target,segmentRatio),sqrt(max(0.0,vertex_height)));}vec2 getExtrusionOffset(vec2 line_clipspace,float offset_direction) {vec2 dir_screenspace=normalize(line_clipspace);dir_screenspace=vec2(-dir_screenspace.y,dir_screenspace.x);vec2 offset=dir_screenspace*offset_direction*a_size*pow(2.0,20.0-u_zoom)/2.0;return offset;}float getAngularDist (vec2 source,vec2 target) {vec2 delta=source-target;vec2 sin_half_delta=sin(delta/2.0);float a=sin_half_delta.y*sin_half_delta.y+cos(source.y)*cos(target.y)*sin_half_delta.x*sin_half_delta.x;return 2.0*atan(sqrt(a),sqrt(1.0-a));}vec2 interpolate (vec2 source,vec2 target,float angularDist,float t) {if(abs(angularDist-PI) < 0.001) {return (1.0-t)*source+t*target;}float a=sin((1.0-t)*angularDist)/sin(angularDist);float b=sin(t*angularDist)/sin(angularDist);vec2 sin_source=sin(source);vec2 cos_source=cos(source);vec2 sin_target=sin(target);vec2 cos_target=cos(target);float x=a*cos_source.y*cos_source.x+b*cos_target.y*cos_target.x;float y=a*cos_source.y*sin_source.x+b*cos_target.y*sin_target.x;float z=a*sin_source.y+b*sin_target.y;return vec2(atan(y,x),atan(z,sqrt(x*x+y*y)));}void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;vec2 source=radians(unProjectFlat(a_instance.rg));vec2 target=radians(unProjectFlat(a_instance.ba));float angularDist=getAngularDist(source,target);float segmentIndex=position.x;float segmentRatio=getSegmentRatio(segmentIndex);float indexDir=mix(-1.0,1.0,step(segmentIndex,0.0));float nextSegmentRatio=getSegmentRatio(segmentIndex+indexDir);\n#ifdef ANIMATE\nv_distance_ratio=segmentIndex/segmentNumber;\n#endif\nvec3 curr=vec3(degrees(interpolate(source,target,angularDist,segmentRatio)),0.0);vec3 next=vec3(degrees(interpolate(source,target,angularDist,nextSegmentRatio)),0.0);vec2 offset=getExtrusionOffset((ProjectFlat(next.xy)-ProjectFlat(curr.xy))*indexDir,position.y);gl_Position=matModelViewProjection*vec4(vec3(vec3(ProjectFlat(curr.xy),2.)+vec3(offset,0.0)),1.0);v_color=a_color;if(pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var line_frag = "precision highp float;varying vec4 v_color;varying float vTime;void main() {vec4 color=v_color;\n#ifdef ANIMATE \nif (vTime > 1.0 || vTime < 0.0) {discard;} \ncolor.a=color.a*vTime*1.5;\n#endif\ngl_FragColor=color;\n#pragma include \"pick\"\n}";

var line_vert = "precision highp float;attribute vec4 a_color;uniform float currentTime;uniform float u_time;uniform float u_opacity;varying float vTime;varying vec4 v_color;uniform float u_activeId;uniform vec4 u_activeColor;void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;v_color=a_color;v_color.a*=u_opacity;if(pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef ANIMATE \nvTime=1.0-(mod(u_time*50.,3600.)-position.z)/100.;\n#endif\ngl_Position=matModelViewProjection*vec4(position.xy,10.,1.0);\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var heatmap_color_vert = "varying vec2 v_uv;void main(){v_uv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4( position,1.0 );}";

var heatmap_color_frag = "uniform sampler2D u_texture;uniform sampler2D u_rampColors;uniform float u_opacity;varying vec2 v_uv;void main(){float intensity=texture2D(u_texture,v_uv).r;vec4 color=texture2D(u_rampColors,vec2(0.5,1.0-intensity));gl_FragColor=color;gl_FragColor.a=color.a*smoothstep(0.,0.05,intensity)*u_opacity;}";

var heatmap_intensity_frag = "precision highp float;uniform float u_intensity;varying float v_weight;varying vec2 v_extrude;void main(){float GAUSS_COEF=0.3989422804014327;float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=v_weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,val,val,val);}";

var heatmap_intensity_vert = "precision highp float;attribute float a_weight;attribute vec2 a_dir;uniform float u_intensity;uniform float u_radius;uniform float u_zoom;varying vec2 v_extrude;varying float v_weight;void main(){v_weight=a_weight;float GAUSS_COEF=0.3989422804014327;float ZERO=1.0/255.0/16.0;float extrude_x=a_dir.x*2.0-1.0;float extrude_y=a_dir.y*2.0-1.0;vec2 extrude_dir=normalize(vec2(extrude_x,extrude_y));float S=sqrt(-2.0*log(ZERO/a_weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=extrude_dir*S;vec2 extrude= v_extrude*u_radius*pow(2.0,20.0-u_zoom); \nvec4 pos=vec4( position.xy+extrude,0.0,1.0);gl_Position=projectionMatrix*modelViewMatrix*pos;}";

var text_frag = "uniform sampler2D u_sdf_map;uniform float u_gamma_scale : 0.5;uniform float u_font_size : 24;uniform float u_opacity : 1.0;uniform vec4 u_stroke : [0,0,0,1];uniform float u_strokeWidth : 2.0;uniform float u_halo_blur : 0.5;varying vec4 v_color;varying vec2 v_uv;varying float v_gamma_scale;void main() {float dist=texture2D(u_sdf_map,v_uv).a;float fontScale=u_font_size/24.0;lowp float buff=(6.0-u_strokeWidth/fontScale)/SDF_PX;highp float gamma=(u_halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);highp float gamma_scaled=gamma*v_gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=mix(v_color*u_opacity,u_stroke,smoothstep(0.,0.5,1.-dist))*alpha;\n#pragma include \"pick\"\n}";

var text_vert = "attribute vec2 a_pos;attribute vec2 a_tex;attribute vec2 a_offset;attribute vec4 a_color;attribute float a_size;uniform vec2 u_sdf_map_size;uniform vec2 u_viewport_size;uniform float u_activeId : 0;uniform vec4 u_activeColor : [1.0,0.0,0.0,1.0];varying vec2 v_uv;varying float v_gamma_scale;varying vec4 v_color;void main() {v_color=a_color;v_uv=a_tex/u_sdf_map_size;float fontScale=a_size/24.;vec4 projected_position=projectionMatrix*modelViewMatrix*vec4(a_pos,0.,1.);gl_Position=vec4(projected_position.xy/projected_position.w+a_offset*fontScale/u_viewport_size*2.,0.0,1.0);v_gamma_scale=gl_Position.w;if (pickingId==u_activeId) {v_color=u_activeColor;}\n#ifdef PICK\nworldId=id_toPickColor(pickingId);\n#endif\n}";

var image_vert = "precision highp float;varying vec2 v_texCoord;void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;v_texCoord=uv;gl_Position= matModelViewProjection*vec4(position,1.0);}";

var image_frag = "precision mediump float;uniform sampler2D u_texture;uniform float u_opacity;varying vec2 v_texCoord;void main() {vec4 color=texture2D(u_texture,vec2(v_texCoord.x,1.0-v_texCoord.y));gl_FragColor=color*u_opacity;}";

var raster_vert = "precision highp float;uniform vec4 u_extent;uniform sampler2D u_texture;uniform float u_opacity;uniform float u_size;uniform sampler2D u_colorTexture;uniform float u_min;uniform float u_max;varying vec2 v_texCoord;varying vec4 v_color;void main() {mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;float value=texture2D(u_texture,uv)[0];v_texCoord=uv;value=clamp(value,u_min,u_max);float value1= (value-u_min)/(u_max-u_min);vec2 ramp_pos=vec2(fract(16.0*(1.0-value1)),floor(16.0*(1.0-value1))/16.0);v_color=texture2D(u_colorTexture,ramp_pos);v_color.a*=u_opacity;vec2 range=u_extent.zw-u_extent.xy;gl_Position= matModelViewProjection*vec4(position.xy,value*100.,1.0);}";

var raster_frag = "precision highp float;uniform sampler2D u_texture;uniform sampler2D u_colorTexture;uniform vec2 u_dimension;varying vec2 v_texCoord;varying vec4 v_color;uniform float u_min;uniform float u_max;uniform vec4 u_extent;\n#define PI 3.141592653589793\nvoid main() {vec2 u_latrange=vec2(3.83718,53.5636);float u_zoom=7.0;float u_maxzoom=10.0;vec2 epsilon=1.0/u_dimension;vec2 u_light=vec2(0.5000,5.8469);vec4 u_accent=vec4(0.,0.,0.,1.);vec4 u_highlight=vec4(1.0);vec4 u_shadow=vec4(0.,0.,0.,1.);float a=texture2D(u_texture,v_texCoord-epsilon)[0];float b=texture2D(u_texture,v_texCoord+vec2(0,-epsilon.y))[0];float c=texture2D(u_texture,v_texCoord+vec2(epsilon.x-epsilon.y))[0];float d=texture2D(u_texture,v_texCoord+vec2(-epsilon.x,0))[0];float e=texture2D(u_texture,v_texCoord)[0];float f=texture2D(u_texture,v_texCoord+vec2(epsilon.x,0))[0];float g=texture2D(u_texture,v_texCoord+vec2(-epsilon.x,epsilon.y))[0];float h=texture2D(u_texture,v_texCoord+vec2(0,epsilon.y))[0];float i=texture2D(u_texture,v_texCoord+epsilon)[0];float exaggeration=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/ pow(2.0,(u_zoom-u_maxzoom)*exaggeration+19.2562-u_zoom);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_texCoord.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*v_color*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=v_color;}";

var tile_polygon_vert = "attribute vec4 a_color;uniform float u_zoom;uniform float u_opacity;varying vec4 v_color;uniform float u_activeId;uniform vec4 u_activeColor;void main(){mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;v_color=a_color;v_color.a*=u_opacity;if(pickingId==u_activeId){v_color=u_activeColor;}gl_Position=projectionMatrix*vec4(position.xy/4096.,0.,1.);}";

var tile_polygon_frag = "varying vec4 v_color;void main(){gl_FragColor=v_color;}";

var mask_quard_vert = "precision highp float;void main(){mat4 matModelViewProjection=projectionMatrix*modelViewMatrix;gl_Position= matModelViewProjection*vec4(position,1.0);}";

var mask_quard_frag = "precision highp float;void main() {gl_FragColor=vec4(0.0,0.,0.,1.0);}";

var common$1 = "#define PI 3.14159265359\n#define TWO_PI 6.28318530718";

var pick_color = "vec4 id_toPickColor(float pickingId) {float id=step(0.,pickingId)*pickingId;vec3 a=fract(vec3(1.0/255.0,1.0/(255.0*255.0),1.0/(255.0*255.0*255.0))*id);a-=a.xxy*vec3(0.0,1.0/255.0,1.0/255.0);vec4 worldColor=vec4(a,1);return worldColor;}";

var decode = "#define SHIFT_RIGHT17 1.0/131072.0\n#define SHIFT_RIGHT18 1.0/262144.0\n#define SHIFT_RIGHT19 1.0/524288.0\n#define SHIFT_RIGHT20 1.0/1048576.0\n#define SHIFT_RIGHT21 1.0/2097152.0\n#define SHIFT_RIGHT22 1.0/4194304.0\n#define SHIFT_RIGHT23 1.0/8388608.0\n#define SHIFT_RIGHT24 1.0/16777216.0\n#define SHIFT_LEFT17 131072.0\n#define SHIFT_LEFT18 262144.0\n#define SHIFT_LEFT19 524288.0\n#define SHIFT_LEFT20 1048576.0\n#define SHIFT_LEFT21 2097152.0\n#define SHIFT_LEFT22 4194304.0\n#define SHIFT_LEFT23 8388608.0\n#define SHIFT_LEFT24 16777216.0\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}";

var lighting = "\nuniform float u_ambient : 1.0;uniform float u_diffuse : 1.0;uniform float u_specular : 1.0;uniform int u_num_of_directional_lights : 1;uniform int u_num_of_spot_lights : 0;\n#define SHININESS 32.0\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\n#define MAX_NUM_OF_SPOT_LIGHTS 3\n#pragma include \"common\"\nstruct DirectionalLight {vec3 direction;vec3 ambient;vec3 diffuse;vec3 specular;};struct SpotLight {vec3 position;vec3 direction;vec3 ambient;vec3 diffuse;vec3 specular;float constant;float linear;float quadratic;float angle;float blur;float exponent;};uniform DirectionalLight u_directional_lights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];uniform SpotLight u_spot_lights[MAX_NUM_OF_SPOT_LIGHTS];vec3 calc_directional_light(DirectionalLight light,vec3 normal,vec3 viewDir) {vec3 lightDir=normalize(light.direction);float diff=max(dot(normal,lightDir),0.0);vec3 halfwayDir=normalize(lightDir+viewDir);float spec=pow(max(dot(normal,halfwayDir),0.0),SHININESS);vec3 ambient=light.ambient*u_ambient;vec3 diffuse=light.diffuse*diff*u_diffuse;vec3 specular=light.specular*spec*u_specular;return ambient+diffuse+specular;}vec3 calc_lighting(vec3 position,vec3 normal,vec3 viewDir) {vec3 weight=vec3(0.0);for (int i=0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {if (i >=u_num_of_directional_lights) {break;}weight+=calc_directional_light(u_directional_lights[i],normal,viewDir);}return weight;}";

var pick = "#ifdef PICK\nif(worldId.x==0.&&worldId.y==0.&& worldId.z==0.){discard;return;}gl_FragColor=worldId;return;\n#endif";

var sdf_2d = "/***2D signed distance field functions*@see http:*/float ndot(vec2 a,vec2 b ) { return a.x*b.x-a.y*b.y; }float sdCircle(vec2 p,float r) {return length(p)-r;}float sdEquilateralTriangle(vec2 p) {const float k=sqrt(3.0);p.x=abs(p.x)-1.0;p.y=p.y+1.0/k;if( p.x+k*p.y > 0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;p.x-=clamp( p.x,-2.0,0.0 );return-length(p)*sign(p.y);}float sdBox(vec2 p,vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0)))+min(max(d.x,d.y),0.0);}float sdPentagon(vec2 p,float r) {const vec3 k=vec3(0.809016994,0.587785252,0.726542528);p.x=abs(p.x);p-=2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);p-=2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);p-=vec2(clamp(p.x,-r*k.z,r*k.z),r);    \nreturn length(p)*sign(p.y);}float sdHexagon(vec2 p,float r) {const vec3 k=vec3(-0.866025404,0.5,0.577350269);p=abs(p);p-=2.0*min(dot(k.xy,p),0.0)*k.xy;p-=vec2(clamp(p.x,-k.z*r,k.z*r),r);return length(p)*sign(p.y);}float sdOctogon(vec2 p,float r) {const vec3 k=vec3(-0.9238795325,0.3826834323,0.4142135623 );p=abs(p);p-=2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);p-=2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);p-=vec2(clamp(p.x,-k.z*r,k.z*r),r);return length(p)*sign(p.y);}float sdHexagram(vec2 p,float r) {const vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);p=abs(p);p-=2.0*min(dot(k.xy,p),0.0)*k.xy;p-=2.0*min(dot(k.yx,p),0.0)*k.yx;p-=vec2(clamp(p.x,r*k.z,r*k.w),r);return length(p)*sign(p.y);}float sdRhombus(vec2 p,vec2 b) {vec2 q=abs(p);float h=clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);float d=length( q-0.5*b*vec2(1.0-h,1.0+h) );return d*sign( q.x*b.y+q.y*b.x-b.x*b.y );}float sdVesica(vec2 p,float r,float d) {p=abs(p);float b=sqrt(r*r-d*d);return ((p.y-b)*d>p.x*b) \n? length(p-vec2(0.0,b)): length(p-vec2(-d,0.0))-r;}";

var project = "#define PI 3.1415926535\n#define E 2.718281828459045\nvec2 ProjectFlat(vec2 lnglat){float maxs=85.0511287798;float lat=max(min(maxs,lnglat.y),-maxs);float scale=268435456.;float d=PI/180.;float x=lnglat.x*d;float y=lat*d;y=log(tan((PI/4.)+(y/2.)));float a=.5/PI,b=.5,c=-.5/PI;d=.5;x=scale*(a*x+b)-215440491.;y=scale*(c*y+d)-106744817.;return vec2(x,y);}vec2 unProjectFlat(vec2 px){float a=.5/PI;float b=.5;float c=-.5/PI;float d=.5;float scale=268435456.;float x=((px.x+215440491.)/scale-b)/a;float y=((px.y+106744817.)/scale-d)/c;y=(atan(pow(E,y))-(PI/4.))*2.;d=PI/180.;float lat=y/d;float lng=x/d;return vec2(lng,lat);}";

function compileBuiltinModules() {
  registerModule('point', { vs: point_vert, fs: point_frag });
  registerModule('common', { vs: common$1, fs: common$1 });
  registerModule('decode', { vs: decode, fs: '' });
  registerModule('lighting', { vs: lighting, fs: '' });
  registerModule('pick', { vs: '', fs: pick });
  registerModule('sdf_2d', { vs: '', fs: sdf_2d });
  registerModule('project', { vs: project, fs: '' });
  registerModule('pick_color', { vs: pick_color, fs: pick_color });
  registerModule('circle', { vs: circle_vert, fs: circle_frag });
  registerModule('polygon', { vs: polygon_vert, fs: polygon_frag });
  registerModule('grid', { vs: grid_vert, fs: grid_frag });
  registerModule('hexagon', { vs: hexagon_vert, fs: hexagon_frag });
  registerModule('pointline', { vs: point_line_vert, fs: point_line_frag });
  registerModule('pointnormal', { vs: normal_point_vert, fs: normal_point_frag });
  registerModule('meshline', { vs: mesh_line_vert, fs: mesh_line_frag });
  registerModule('arcline', { vs: arc_line_vert, fs: arc_line_frag });
  registerModule('greatcircle', { vs: great_circle_line_vert, fs: arc_line_frag });
  registerModule('line', { vs: line_vert, fs: line_frag });
  registerModule('heatmap_color', { vs: heatmap_color_vert, fs: heatmap_color_frag });
  registerModule('heatmap_intensity', { vs: heatmap_intensity_vert, fs: heatmap_intensity_frag });
  registerModule('text', { vs: text_vert, fs: text_frag });
  registerModule('image', { vs: image_vert, fs: image_frag });
  registerModule('raster', { vs: raster_vert, fs: raster_frag });
  registerModule('tilepolygon', { vs: tile_polygon_vert, fs: tile_polygon_frag });
  registerModule('mask_quard', { vs: mask_quard_vert, fs: mask_quard_frag });

}

function WebWorker() {
  return (new Worker(exported.workerUrl));
}

/**
 * Constructs a worker pool.
 * @private
 */
var WorkerPool = function WorkerPool() {
  this.active = {};
};

WorkerPool.prototype.acquire = function acquire (mapId) {
  if (!this.workers) {
    // Lazily look up the value of mapboxgl.workerCount so that
    // client code has had a chance to set it.
    this.workers = [];
    while (this.workers.length < WorkerPool.workerCount) {
      this.workers.push(new WebWorker());
    }
  }

  this.active[mapId] = true;
  return this.workers.slice();
};

WorkerPool.prototype.release = function release (mapId) {
  delete this.active[mapId];
  if (Object.keys(this.active).length === 0) {
    this.workers.forEach(function (w) {
      w.terminate();
    });
    this.workers = null;
  }
};

WorkerPool.workerCount = Math.max(Math.floor(window.navigator.hardwareConcurrency / 2), 1);

var tileURLRegex$2 = /\{([zxy])\}/g;
var VectorTileSource = /*@__PURE__*/(function (Base) {
  function VectorTileSource(cfg, workerController) {
    Base.call(this, Object.assign({}, {type: 'vector'},
      cfg));
    this.cfg = cfg;
    this.workerController = workerController;
    this.urlTemplate = this.get('url');
  }

  if ( Base ) VectorTileSource.__proto__ = Base;
  VectorTileSource.prototype = Object.create( Base && Base.prototype );
  VectorTileSource.prototype.constructor = VectorTileSource;
  VectorTileSource.prototype.loadTile = function loadTile (tileinfo, callback) {
    var tileId = tileinfo.id.split('_');
    var url = this._getTileURL({
      x: tileId[0],
      y: tileId[1],
      z: tileId[2]
    });
    var params = Object.assign({}, {id: tileinfo.id,
      type: 'vector'},
      this.cfg,
      {url: url});
    tileinfo.workerID = this.workerController.send('loadTile', params, done.bind(this));
    function done(err, data) { // 收到数据，处理数据
      callback(err, data);
    }
  };
  VectorTileSource.prototype.abortTile = function abortTile (tileinfo) {
    this.workerController.send('abortTile', { id: tileinfo.id, type: this.get('type'), sourceID: this.get('sourceID') }, undefined, tileinfo.workerID);
  };
  VectorTileSource.prototype.unloadTile = function unloadTile (tileinfo) {
    this.workerController.send('removeTile', { id: tileinfo.id, type: this.get('type'), sourceID: this.get('sourceID') }, undefined, tileinfo.workerID);
  };
  VectorTileSource.prototype._getTileURL = function _getTileURL (urlParams) {
    if (!urlParams.s) {
      // Default to a random choice of a, b or c
      urlParams.s = String.fromCharCode(97 + Math.floor(Math.random() * 3));
    }

    tileURLRegex$2.lastIndex = 0;
    return this.urlTemplate.replace(tileURLRegex$2, function(value, key) {
      return urlParams[key];
    });
  };

  return VectorTileSource;
}(actor.Base));

var r2d$1 = 180 / Math.PI;
var VectorTileMesh = function VectorTileMesh(layer, data) {
  this.layer = layer;
  this._object3D = new actor.Object3D();
  this._object3D.name = data.tileId;
  this._tile = data.tileId.split('_').map(function (v) { return v * 1; });
  this._tileLnglatBounds = this._tileLnglatBounds(this._tile);

  this._tileBounds = this._tileBounds(this._tileLnglatBounds);

  this._center = this._tileBounds.getCenter();

  this._centerLnglat = this._tileLnglatBounds.getCenter();
  this._init(data);

  this.maskScene = new actor.Scene();
  var tileMesh = this._tileMaskMesh();
  // this._object3D.add(tileMesh);
  this.maskScene.add(tileMesh);
  this._bufferData = data;
};
VectorTileMesh.prototype._init = function _init (data) {
  this._createMesh(data);

};
VectorTileMesh.prototype.getFeatureIndex = function getFeatureIndex (id) {
  return this._bufferData.featureKey.indexOf(id);
};

VectorTileMesh.prototype._createMesh = function _createMesh (data) {
    var this$1 = this;

  this.mesh = getRender(this.layer.get('type'), data.shape)(null, this.layer, data.buffer);
  if (this.mesh.type !== 'composer') { // 热力图的情况
    this.mesh.onBeforeRender = function (renderer) {
      this$1._renderMask(renderer);
      var zoom = this$1.layer.scene.getZoom();
      updateObjecteUniform(this$1._object3D, {
        u_time: this$1.layer.scene._engine.clock.getElapsedTime(),
        u_zoom: zoom
      });
    };
    this.mesh.onAfterRender = function (renderer) {
      var context = renderer.context;
      context.clear(context.STENCIL_BUFFER_BIT);
      context.disable(context.STENCIL_TEST);
    };
    this._object3D.add(this.mesh);
  } else { // 如果是热力图
    this._object3D = this.mesh;
  }
  return this._object3D;
};
VectorTileMesh.prototype.getMesh = function getMesh () {
  return this._object3D;
};

VectorTileMesh.prototype._renderMask = function _renderMask (renderer) {
  if (this.layer.get('layerType') === 'point') { // 点图层目前不需要mask
    return;
  }
  var context = renderer.context;
  renderer.autoClear = false;
  renderer.clearDepth();
  context.enable(context.STENCIL_TEST);
  context.stencilOp(context.REPLACE, context.REPLACE, context.REPLACE);
  context.stencilFunc(context.ALWAYS, 1, 0xffffffff);
  context.clearStencil(0);
  context.clear(context.STENCIL_BUFFER_BIT);
  context.colorMask(false, false, false, false);

  // config the stencil buffer to collect data for testing
  this.layer.scene._engine.renderScene(this.maskScene);
  context.colorMask(true, true, true, true);
  context.depthMask(false);
  renderer.clearDepth();

  // only render where stencil is set to 1

  context.stencilFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
  context.stencilOp(context.KEEP, context.KEEP, context.KEEP);
};
VectorTileMesh.prototype._tileMaskMesh = function _tileMaskMesh () {
  var tilebound = this._tileBounds;
  var bl = [ tilebound.getBottomLeft().x, tilebound.getBottomLeft().y, 0 ];
  var br = [ tilebound.getBottomRight().x, tilebound.getBottomRight().y, 0 ];
  var tl = [ tilebound.getTopLeft().x, tilebound.getTopLeft().y, 0 ];
  var tr = [ tilebound.getTopRight().x, tilebound.getTopRight().y, 0 ];
  var positions = new Float32Array(bl.concat( tr, br, bl, tl, tr ));
  var geometry = new actor.BufferGeometry();
  geometry.addAttribute('position', new actor.Float32BufferAttribute(positions, 3));
  var maskMaterial = new MaskMaterial();
  var maskMesh = new actor.Mesh(geometry, maskMaterial);
  return maskMesh;
};
VectorTileMesh.prototype.getSelectFeature = function getSelectFeature (id) {
  var featurekey = this.layerSource.originData.featureKeys[id];
  if (featurekey && featurekey.index !== undefined) {
    var featureIndex = featurekey.index;
    return this.layerSource.originData.dataArray[featureIndex];
  }
  return null;
};
VectorTileMesh.prototype._tileBounds = function _tileBounds (lnglatBound) {
  var ne = this.layer.scene.project([ lnglatBound.getNorthEast().lng, lnglatBound.getNorthEast().lat ]);
  var sw = this.layer.scene.project([ lnglatBound.getSouthWest().lng, lnglatBound.getSouthWest().lat ]);
  return lib_3(sw, ne);
};
// Get tile bounds in WGS84 coordinates
VectorTileMesh.prototype._tileLnglatBounds = function _tileLnglatBounds (tile) {
  var e = this._tile2lng(tile[0] + 1, tile[2]);
  var w = this._tile2lng(tile[0], tile[2]);
  var s = this._tile2lat(tile[1] + 1, tile[2]);
  var n = this._tile2lat(tile[1], tile[2]);
  return lib_7([ w, n ], [ e, s ]);
};

VectorTileMesh.prototype._tile2lng = function _tile2lng (x, z) {
  return x / Math.pow(2, z) * 360 - 180;
};

VectorTileMesh.prototype._tile2lat = function _tile2lat (y, z) {
  var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
  return r2d$1 * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
};

VectorTileMesh.prototype.destroy = function destroy () {
  destoryObject(this._object3D);
  destoryObject(this.maskScene);
  this._object3D = null;
  this.maskScene = null;
  this.layerData = null;
};

// 统一管理 source 添加，管理，更新
var SouceCache = /*@__PURE__*/(function (Base) {
  function SouceCache(scene, cfg) {
    Base.call(this, Object.assign({}, {cacheLimit: 50,
      minZoom: 0,
      maxZoom: 18,
      keepBuffer: 0},
      cfg));
    this._tileMap = {};// 视野内瓦片坐标序列
    this.tileList = {}; // 正在使用的瓦片坐标，记录瓦片的使用状态
    this.scene = scene;
    // TODO 销毁函数
    this._tileCache = new TileCache(this.get('cacheLimit'), this._destroyTile.bind(this));
    this._crs = crsEpsg3857_1;
    this.layers = this.scene.getLayers();
    this._source = new VectorTileSource(cfg, this.scene.style.WorkerController);
    this.layersTiles = {}; // 存储当前source所有layer的瓦片
  }

  if ( Base ) SouceCache.__proto__ = Base;
  SouceCache.prototype = Object.create( Base && Base.prototype );
  SouceCache.prototype.constructor = SouceCache;
  SouceCache.prototype.getLayerById = function getLayerById (id) {
    var layers = this.scene.getLayers();
    for (var i = 0; i < layers.length; i += 1) {
      if (layers[i].layerId === id * 1) {
        return layers[i];
      }
    }
  };

  /**
   * 移除视野外的瓦片，计算新增的瓦片数据
   * @param {*}tileMap 瓦片列表
   */

  SouceCache.prototype.update = function update () {
    var this$1 = this;

    this._calculateTileIDs();
    var loop = function ( i ) {
      // 瓦片相关参数
      var tileId = this$1.updateTileList[i].join('_');
      var tileinfo = this$1.tileList[tileId];
      tileinfo.loading = true;
      var tiles = this$1._tileCache.getTile(tileId);
      if (tiles !== undefined) {
        tileinfo.active = true;
        tileinfo.loaded = true;
        for (var layerId in tiles.mesh) {
          var layer = this$1.getLayerById(layerId);
          var tileMesh = tiles.mesh[layerId];
          layer.tiles.add(tileMesh.getMesh());
          this$1._addPickMesh(layer, tileMesh.getMesh());
          this$1.scene._engine.update();
        }
        this$1._pruneTiles();
        return;
      }
      this$1._source.loadTile(tileinfo, function (err, data) {
        if (!err && data !== undefined) {
          this$1._renderTile(tileinfo, data);
          tileinfo.active = true;
        }
        tileinfo.loaded = true;
        this$1._pruneTiles();
      });
    };

    for (var i = 0; i < this$1.updateTileList.length; i++) loop( i );
  };

  SouceCache.prototype._renderTile = function _renderTile (tileinfo, data) {
    var tileId = tileinfo.id;
    var tiles = {
      rawData: data.rawTileData,
      mesh: {}
    };
    for (var layerId in data.buffer) {
      var layer = this.getLayerById(layerId);
      var tileMesh = new VectorTileMesh(layer, data.buffer[layerId]);
      tiles.mesh[layerId] = tileMesh;
      layer.tiles.add(tileMesh.getMesh());
      this._addPickMesh(layer, tileMesh.getMesh());
      this.scene._engine.update();
    }

    this._tileCache.setTile(tiles, tileId);
  };
  SouceCache.prototype.getSelectFeature = function getSelectFeature (featureId, layerId, lnglat) {
    var zoom = this.tileZoom;
    var tilePoint = this._crs.lngLatToPoint(lib_5(lnglat.lng, lnglat.lat), zoom);
    var tileXY = tilePoint.divideBy(256).floor();
    var tile = this._getParentTile(tileXY.x, tileXY.y, zoom, zoom - 3);
    var layer = this.getLayerById(layerId);
    var sourceLayer = layer.get('sourceOption').parser.sourceLayer;
    var featureIndex = tile.mesh[layerId].getFeatureIndex(featureId);
    var feature = this._getVectorFeature(tile.rawData, sourceLayer, featureIndex);
    return feature ? feature.toGeoJSON(tileXY.x, tileXY.y, zoom) : { };
  };
  SouceCache.prototype._getParentTile = function _getParentTile (x, y, z, minZoom) {
    if (z < minZoom) { return null; }
    var key = [ x, y, z ].join('_');
    var tile = this._tileCache.getTile(key);
    if (!tile) {
      return this._getParentTile(Math.floor(x / 2), Math.floor(y / 2), z - 1);
    }
    return tile;
  };

  SouceCache.prototype._getVectorFeature = function _getVectorFeature (rawTile, sourceLayer, featureIndex) {
    var vectorTile = new actor.VectorTile(new actor.PBF(rawTile));
    if (featureIndex < 0) {
      return;
    }
    return vectorTile.layers[sourceLayer].feature(featureIndex);

  };
  // 计算视野内的瓦片坐标
  SouceCache.prototype._calculateTileIDs = function _calculateTileIDs () {
    this._tileMap = {};
    this.updateTileList = [];
    var zoom = Math.floor(this.scene.getZoom()); // - window.window.devicePixelRatio + 1; // zoom - 1
    var minSourceZoom = this.get('minZoom');
    var maxSourceZoom = this.get('maxZoom');
    this.tileZoom = zoom > maxSourceZoom ? maxSourceZoom : zoom;
    var currentZoom = this.scene.getZoom();
    if (currentZoom < minSourceZoom) {
      this._removeTiles();
      // 小于source最小范围不在处理
      return;
    }
    var pixelBounds = this._getPixelBounds();
    var tileRange = this._pxBoundsToTileRange(pixelBounds);
    var margin = this.get('keepBuffer');
    var center = this.scene.getCenter();
    var centerPoint = this.scene.crs.lngLatToPoint(lib_5(center.lng, center.lat), this.tileZoom);
    var centerXY = centerPoint.divideBy(256).floor();
    this._noPruneRange = new lib_2(tileRange.getBottomLeft().subtract([ margin, -margin ]),
      tileRange.getTopRight().add([ margin, -margin ]));
    if (!(isFinite(tileRange.min.x) &&
      isFinite(tileRange.min.y) &&
      isFinite(tileRange.max.x) &&
      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }
    for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
      for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
        var coords = [ i, j, this.tileZoom ];
        var tile = this.tileList[coords.join('_')];
        if (tile && tile.loading) {
          tile.current = true;
          tile.retain = true;
        } else {
          this.tileList[coords.join('_')] = {
            current: true,
            active: false,
            retain: true,
            loading: false,
            coords: coords,
            id: coords.join('_')
          };
          this.updateTileList.push(coords);
        }
      }
    }
    // 根据中心点排序
    this.updateTileList.sort(function (a, b) {
      var tile1 = a;
      var tile2 = b;
      var d1 = Math.pow((tile1[0] * 1 - centerXY.x), 2) + Math.pow((tile1[1] * 1 - centerXY.y), 2);
      var d2 = Math.pow((tile2[0] * 1 - centerXY.x), 2) + Math.pow((tile2[1] * 1 - centerXY.y), 2);
      return d1 - d2;
    });
    this._pruneTiles();
  };
  SouceCache.prototype._getPixelBounds = function _getPixelBounds () {
    var viewPort = this.scene.getBounds().toBounds();
    var NE = viewPort.getNorthEast();
    var SW = viewPort.getSouthWest();
    var zoom = this.tileZoom;
    var center = this.scene.getCenter();
    var NEPoint = this.scene.crs.lngLatToPoint(lib_5(NE.lng, NE.lat), zoom);
    var SWPoint = this.scene.crs.lngLatToPoint(lib_5(SW.lng, SW.lat), zoom);
    var centerPoint = this.scene.crs.lngLatToPoint(lib_5(center.lng, center.lat), zoom);
    var topHeight = centerPoint.y - NEPoint.y;
    var bottomHeight = SWPoint.y - centerPoint.y;
    // 跨日界线的情况
    var leftWidth;
    var rightWidth;
    if (center.lng - NE.lng > 0 || center.lng - SW.lng < 0) {
      var width = Math.pow(2, zoom) * 256 / 360 * (180 - NE.lng) + Math.pow(2, zoom) * 256 / 360 * (SW.lng + 180);
      if (center.lng - NE.lng > 0) { // 日界线在右侧
        leftWidth = Math.pow(2, zoom) * 256 / 360 * (center.lng - NE.lng);
        rightWidth = width - leftWidth;
      } else {
        rightWidth = Math.pow(2, zoom) * 256 / 360 * (SW.lng - center.lng);
        leftWidth = width - rightWidth;
      }
    } else { // 不跨日界线
      leftWidth = Math.pow(2, zoom) * 256 / 360 * (center.lng - SW.lng);
      rightWidth = Math.pow(2, zoom) * 256 / 360 * (NE.lng - center.lng);
    }
    var pixelBounds = new lib_2(centerPoint.subtract(leftWidth, topHeight), centerPoint.add(rightWidth, bottomHeight));
    return pixelBounds;
  };
  SouceCache.prototype._pxBoundsToTileRange = function _pxBoundsToTileRange (pixelBounds) {
    return new lib_2(
      pixelBounds.min.divideBy(256).floor(),
      pixelBounds.max.divideBy(256).ceil().subtract([ 1, 1 ])
    );
  };

  SouceCache.prototype._loadTile = function _loadTile (tile, callback) {
    return this._source.loadTile(tile, callback);

  };
  SouceCache.prototype._unloadTile = function _unloadTile (tile) {
    if (this._source.unloadTile) {
      return this._source.unloadTile(tile, function () { });
    }
  };

  SouceCache.prototype._abortTile = function _abortTile (tile) {
    if (this._source.abortTile) {
      return this._source.abortTile(tile, function () { });
    }
  };
  SouceCache.prototype.reload = function reload () {

  };

  SouceCache.prototype._reloadTile = function _reloadTile () {

  };
  SouceCache.prototype._removeTile = function _removeTile () {

  };
  SouceCache.prototype.clearTiles = function clearTiles () {

  };
  SouceCache.prototype._pruneTiles = function _pruneTiles () {
    var tile;
    var zoom = this.tileZoom;
    for (var key in this.tileList) {
      var c = this.tileList[key].coords;
      if (c[2] !== zoom || !this._noPruneRange.contains(new lib_8(c[0], c[1]))) {
        this.tileList[key].current = false;
        this.tileList[key].retain = false;
      }
    }
    for (var key$1 in this.tileList) {
      tile = this.tileList[key$1];
      if (tile.current && !tile.active) {
        var ref = key$1.split('_').map(function (v) { return v * 1; });
        var x = ref[0];
        var y = ref[1];
        var z = ref[2];
        if (!this._retainParent(x, y, z, z - 5)) {
          this._retainChildren(x, y, z, z + 2);
        }
      }

    }
    this._removeOutTiles();
  };
  SouceCache.prototype._retainParent = function _retainParent (x, y, z, minZoom) {
    var x2 = Math.floor(x / 2);
    var y2 = Math.floor(y / 2);
    var z2 = z - 1;
    var tile = this.tileList[[ x2, y2, z2 ].join('_')];
    if (tile && tile.active) {
      tile.retain = true;
      tile.current = true;
      return true;
    } else if (tile && tile.loaded) {
      tile.retain = true;
    }
    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }

    return false;

  };
  SouceCache.prototype._retainChildren = function _retainChildren (x, y, z, maxZoom) {
    for (var i = 2 * x; i < 2 * x + 2; i++) {
      for (var j = 2 * y; j < 2 * y + 2; j++) {
        var key = [ i, j, z + 1 ].join('_');
        var tile = this.tileList[key];
        if (tile && tile.active) {
          tile.retain = true;
          tile.current = true;
          continue;
        } else if (tile && tile.loaded) {
          tile.retain = true;
          tile.current = true;
        }

        if (z + 1 < maxZoom) {
          this._retainChildren(i, j, z + 1, maxZoom);
        }
      }
    }
  };
  // 地图拾取
  SouceCache.prototype._addPickMesh = function _addPickMesh (layer, meshObj) {
    if (this.type === 'image') {
      return;
    }
    var pickCtr = layer.get('pickingController');
    var mesh = meshObj.children[0];
    mesh.name = meshObj.name;
    pickCtr.addPickMesh(mesh);
  };
  SouceCache.prototype._removeOutTiles = function _removeOutTiles () {
    var this$1 = this;

    // 移除视野外的tile
    for (var key in this.tileList) {
      if (!this.tileList[key].retain) {
        this._abortTile(this.tileList[key]);
        this._unloadTile(this.tileList[key]);
        delete this.tileList[key];
      }
    }
    var layers = this.scene.getLayers();
    var loop = function ( i ) {
      var id = this$1.get('sourceID');
      var layerSource = layers[i].get('sourceOption').id;
      if (layerSource !== id) {
        return {};
      }
      layers[i].tiles.children.forEach(function (tile) {
        var key = tile.name;
        if (!this$1.tileList[key]) {
          layers[i].tiles.remove(tile);
          var pickCtr = layers[i].get('pickingController');
          pickCtr && pickCtr.removePickMeshByName(key);
        }
      });
    };

    for (var i = 0; i < layers.length; i++) {
      var returned = loop( i );

      if ( returned ) return returned.v;
    }
    // 移除对应的数据
  };
  SouceCache.prototype._destroyTile = function _destroyTile (tile, key) {
    this._unloadTile(key);
  };

  return SouceCache;
}(actor.Base));

var id$1 = 1;
function asyncAll(
  array,
  fn,
  callback
) {
  if (!array.length) { return callback(null, []); }
  var remaining = array.length;
  var results = new Array(array.length);
  var error = null;
  array.forEach(function (item, i) {
    fn(item, function (err, result) {
      if (err) { error = err; }
      results[i] = ((result));
      if (--remaining === 0) { callback(error, results); }
    });
  });
}

var WorkerController = function WorkerController(workerPool, parent) {
  this.workerPool = workerPool;
  this.actors = [];
  this.currentActor = 0;
  this.id = id$1++;
  var workers = this.workerPool.acquire(this.id);

  for (var i = 0; i < workers.length; i++) {
    var worker = workers[i];
    var actor = new WorkerController.Actor(worker, parent, this.id);
    actor.name = "Worker " + i;
    this.actors.push(actor);
  }
};

/**
 * Broadcast a message to all Workers.
 */

WorkerController.prototype.broadcast = function broadcast (type, data, cb) {
  cb = cb || function() { };
  asyncAll(this.actors, function (actor, done) {
    actor.send(type, data, done);
  }, cb);
};


WorkerController.prototype.send = function send (type, data, callback, targetID) {
  if (typeof targetID !== 'number' || isNaN(targetID)) {
    // Use round robin to send requests to web workers.
    targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
  }
  this.actors[targetID].send(type, data, callback, targetID);
  return targetID;
};

WorkerController.prototype.remove = function remove () {
  this.actors.forEach(function (actor) { actor.remove(); });
  this.actors = [];
  this.workerPool.release(this.id);
};
WorkerController.Actor = actor.Actor;

var omitOption = [ 'mappingController', 'interacionController', 'pickingController', 'interactions', 'eventController' ];
// 统一管理所有的Source
// 统一管理地图样式
var Style = /*@__PURE__*/(function (Base) {
  function Style(scene, cfg) {
    Base.call(this, cfg);
    this.scene = scene;
    this._sourceCaches = {};
    this.WorkerPool = new WorkerPool();
    this._tileMap = {};
    this.WorkerController = new WorkerController(this.WorkerPool, this);
    this.layerStyles = {};
    this.layers = [];
    this.addMapEvent();
  }

  if ( Base ) Style.__proto__ = Base;
  Style.prototype = Object.create( Base && Base.prototype );
  Style.prototype.constructor = Style;
  Style.prototype.addSource = function addSource (id, sourceCfg) {
    if (this._sourceCaches[id] !== undefined) {
      throw new Error('SourceID 已存在');
    }
    sourceCfg.sourceID = id;
    this._sourceCaches[id] = new SouceCache(this.scene, sourceCfg);
  };
  Style.prototype.getSource = function getSource (id) {
    return this._sourceCaches[id];
  };
  Style.prototype.addLayer = function addLayer (layer) {
    var id = layer.layerId;
    this.layers[id] = layer;
  };
  // 设置
  Style.prototype._addTileStyle = function _addTileStyle (layerCfg) {
    var layerid = layerCfg.layerId;
    var newLayerCfg = {};
    for (var key in layerCfg) { // 过滤不可传递对象
      if (omitOption.indexOf(key) === -1) {
        newLayerCfg[key] = layerCfg[key];
      }
    }
    this.layerStyles[layerid] = newLayerCfg;
    this._layerStyleGroupBySourceID();

    this.WorkerController.broadcast('setLayers', this.layerStyles);
    // TODO 更新 style

  };
  Style.prototype.removeTileStyle = function removeTileStyle (id) {
    delete this.layerStyles[id];
    this._layerStyleGroupBySourceID();

  };
  Style.prototype._layerStyleGroupBySourceID = function _layerStyleGroupBySourceID () {
    var sourceStyles = [];
    // 支持VectorLayer
    for (var layerId in this.layerStyles) {
      var sourceID = this.layerStyles[layerId].sourceOption.id;
      var sourcelayer = this.layerStyles[layerId].sourceOption.parser.sourceLayer;
      if (!sourceStyles[sourceID]) { sourceStyles[sourceID] = {}; }
      if (!sourceStyles[sourceID][sourcelayer]) { sourceStyles[sourceID][sourcelayer] = []; }
      sourceStyles[sourceID][sourcelayer].push(this.layerStyles[layerId]);
    }
    this.sourceStyles = sourceStyles;
  };
  Style.prototype.update = function update (parameters) {
    this._addTileStyle(parameters);
    for (var key in this._sourceCaches) {
      this._sourceCaches[key].update(this.layers, this.sourceStyles[key]);
    }

  };
  Style.prototype.addMapEvent = function addMapEvent () {
    var this$1 = this;

    this.mapEventHander = throttle(function () {
      requestAnimationFrame(function () {
        for (var key in this$1._sourceCaches) {
          this$1._sourceCaches[key].update(this$1.layers, this$1.sourceStyles[key]);
        }
      });
    }, 200);
    this.scene.map.on('zoomchange', this.mapEventHander);
    this.scene.map.on('dragend', this.mapEventHander);
  };
  Style.prototype.clearMapEvent = function clearMapEvent () {
    this.scene.map.off('zoomchange', this.mapEventHander);
    this.scene.map.off('dragend', this.mapEventHander);
  };
  Style.prototype.destroy = function destroy () {
    this.WorkerController.remove();

  };

  return Style;
}(actor.Base));

function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
  return trim(str).split(/\s+/);
}

var docStyle = window.document.documentElement.style;
function testProp(props) {
  if (!docStyle) { return props[0]; }
  for (var i = 0; i < props.length; i++) {
    if (props[i] in docStyle) {
      return props[i];
    }
  }
  return props[0];
}
function create(tagName, className, container) {
  var el = document.createElement(tagName);
  el.className = className || '';

  if (container) {
    container.appendChild(el);
  }
  return el;
}
// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
  var parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
  if (el.classList !== undefined) {
    var classes = splitWords(name);
    for (var i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    var className = getClass(el);
    setClass(el, (className ? className + ' ' : '') + name);
  }
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
  if (el.classList !== undefined) {
    el.classList.remove(name);
  } else {
    setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
  }
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
  if (el.classList !== undefined) {
    return el.classList.contains(name);
  }
  var className = getClass(el);
  return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
  if (el.className.baseVal === undefined) {
    el.className = name;
  } else {
    // in case of SVG element
    el.className.baseVal = name;
  }
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
  // Check if the element is an SVGElementInstance and use the correspondingElement instead
  // (Required for linked SVG elements in IE11.)
  if (el.correspondingElement) {
    el = el.correspondingElement;
  }
  return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

function empty(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}

var transformProp = testProp([ 'transform', 'WebkitTransform' ]);

function setTransform(el, value) {
  el.style[transformProp] = value;
}

var Control = function Control(cfg) {
  actor.Util.assign(this, cfg);
  this._initControlPos();
};
Control.prototype.addControl = function addControl (control) {
  control.addTo(this.scene);
};
Control.prototype.removeControl = function removeControl (control) {
  control.remove();
  return this;
};
Control.prototype._initControlPos = function _initControlPos () {
  var corners = this._controlCorners = {};
  var l = 'l7-';
  var container = this._controlContainer =
    create('div', l + 'control-container', this.scene.getContainer());

  function createCorner(vSide, hSide) {
    var className = l + vSide + ' ' + l + hSide;

    corners[vSide + hSide] = create('div', className, container);
  }

  createCorner('top', 'left');
  createCorner('top', 'right');
  createCorner('bottom', 'left');
  createCorner('bottom', 'right');
};
Control.prototype._clearControlPos = function _clearControlPos () {
  for (var i in this._controlCorners) {
    remove(this._controlCorners[i]);
  }
  remove(this._controlContainer);
  delete this._controlCorners;
  delete this._controlContainer;
};

var Control$1 = /*@__PURE__*/(function (Base) {
  function Control(cfg) {
    Base.call(this, Object.assign({}, {position: 'topright'},
      cfg));
  }

  if ( Base ) Control.__proto__ = Base;
  Control.prototype = Object.create( Base && Base.prototype );
  Control.prototype.constructor = Control;
  Control.prototype.setPosition = function setPosition (position) {
    var scene = this._scene;
    if (scene) {
      scene.removeControl(this);
    }
    this.set('position', position);
    if (scene) {
      scene.addControl(this);
    }
    return this;
  };
  Control.prototype.getContainer = function getContainer () {
    return this._container;
  };
  Control.prototype.addTo = function addTo (scene) {
    this.remove();
    this.isShow = true;
    this._scene = scene;
    var container = this._container = this.onAdd(scene);
    var pos = this.get('position');
    var corner = scene.get('controlController')._controlCorners[pos];
    addClass(container, 'l7-control');

    if (pos.indexOf('bottom') !== -1) {
      corner.insertBefore(container, corner.firstChild);
    } else {
      corner.appendChild(container);
    }
    return this;
  };
  Control.prototype.hide = function hide () {
    var container = this._container;
    addClass(container, 'l7-control-hide');
    this.isShow = false;
  };
  Control.prototype.show = function show () {
    var container = this._container;
    removeClass(container, 'l7-control-hide');
    this.isShow = true;
  };
  Control.prototype.remove = function remove$1 () {
    if (!this._scene) {
      return this;
    }
    remove(this._container);
  };
  Control.prototype._refocusOnMap = function _refocusOnMap (e) {
    // if map exists and event is not a keyboard event
    if (this._scene && e && e.screenX > 0 && e.screenY > 0) {
      this._scene.getContainer().focus();
    }
  };

  return Control;
}(actor.Base));

var Zoom = /*@__PURE__*/(function (Control) {
  function Zoom(cfg) {
    Control.call(this, Object.assign({}, {position: 'topleft',
      zoomInText: '+',
      zoomInTitle: 'Zoom in',
      zoomOutText: '&#x2212;',
      zoomOutTitle: 'Zoom out'},
      cfg));
    actor.bindAll([ '_updateDisabled', '_zoomIn', '_zoomOut' ], this);
    this._disabled = false;
  }

  if ( Control ) Zoom.__proto__ = Control;
  Zoom.prototype = Object.create( Control && Control.prototype );
  Zoom.prototype.constructor = Zoom;
  Zoom.prototype.onAdd = function onAdd (scene) {
    var zoomName = 'l7-control-zoom';
    var container = create('div', zoomName + ' l7-bar');

    this._zoomInButton = this._createButton(this.get('zoomInText'), this.get('zoomInTitle'),
      zoomName + '-in', container, this._zoomIn);
    this._zoomOutButton = this._createButton(this.get('zoomOutText'), this.get('zoomOutTitle'),
      zoomName + '-out', container, this._zoomOut);
    scene.on('zoomend', this._updateDisabled);
    scene.on('zoomchange', this._updateDisabled);
    this._updateDisabled();
    return container;
  };
  Zoom.prototype.onRemove = function onRemove (scene) {
    scene.off('zoomend', this._updateDisabled);
    scene.off('zoomchange', this._updateDisabled);
  };
  Zoom.prototype.disable = function disable () {
    this._disabled = true;
    this._updateDisabled();
    return this;
  };
  Zoom.prototype.enable = function enable () {
    this._disabled = false;
    this._updateDisabled();
    return this;
  };
  Zoom.prototype._zoomIn = function _zoomIn () {
    if (!this._disabled && this._scene.getZoom() < this._scene.get('maxZoom')) {
      this._scene.zoomIn();
    }
  };
  Zoom.prototype._zoomOut = function _zoomOut () {
    if (!this._disabled && this._scene.getZoom() > this._scene.get('minZoom')) {
      this._scene.zoomOut();
    }
  };
  Zoom.prototype._createButton = function _createButton (html, tile, className, container, fn) {
    var link = create('a', className, container);
    link.innerHTML = html;
    link.href = '#';
    link.tile = tile;
    link.addEventListener('click', fn);
    return link;
  };
  Zoom.prototype._updateDisabled = function _updateDisabled () {
    var scene = this._scene;
    var className = 'l7-disabled';
    removeClass(this._zoomInButton, className);
    removeClass(this._zoomOutButton, className);
    if (this._disabled || scene.getZoom() <= scene.get('minZoom')) {
      addClass(this._zoomOutButton, className);
    }
    if (this._disabled || scene.getZoom() >= scene.get('maxZoom')) {
      addClass(this._zoomInButton, className);
    }
  };

  return Zoom;
}(Control$1));

var Scale = /*@__PURE__*/(function (Control) {
  function Scale(cfg) {
    Control.call(this, Object.assign({}, {position: 'bottomleft',
      maxWidth: 100,
      metric: true,
      updateWhenIdle: false,
      imperial: false},
      cfg));
    actor.bindAll([ '_update' ], this);
  }

  if ( Control ) Scale.__proto__ = Control;
  Scale.prototype = Object.create( Control && Control.prototype );
  Scale.prototype.constructor = Scale;
  Scale.prototype.onAdd = function onAdd (scene) {
    var className = 'l7-control-scale';
    var container = create('div', className);
    this._addScales(className + '-line', container);

    scene.on(this.get('updateWhenIdle') ? 'moveend' : 'mapmove', this._update);
    this._update();

    return container;
  };
  Scale.prototype.onRemove = function onRemove (scene) {
    scene.off(this.get('updateWhenIdle') ? 'moveend' : 'mapmove', this._update);
  };
  Scale.prototype._addScales = function _addScales (className, container) {

    if (this.get('metric')) {
      this._mScale = create('div', className, container);
    }
    if (this.get('imperial')) {
      this._iScale = create('div', className, container);
    }
  };
  Scale.prototype._update = function _update () {
    var scene = this._scene;

    var y = this._scene.getSize().height / 2;

    var p1 = scene.containerToLngLat({ x: 0, y: y });
    var p2 = scene.containerToLngLat({ x: this.get('maxWidth'), y: y });
    var maxMeters = scene.crs.distance(lngLat_2(p1.lng, p1.lat), lngLat_2(p2.lng, p2.lat));
    this._updateScales(maxMeters);
  };
  Scale.prototype._updateScales = function _updateScales (maxMeters) {
    if (this.get('metric') && maxMeters) {
      this._updateMetric(maxMeters);
    }
    if (this.get('imperial') && maxMeters) {
      this._updateImperial(maxMeters);
    }
  };
  Scale.prototype._updateMetric = function _updateMetric (maxMeters) {
    var meters = this._getRoundNum(maxMeters),
      label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
    this._updateScale(this._mScale, label, meters / maxMeters);
  };
  Scale.prototype._updateImperial = function _updateImperial (maxMeters) {
    var maxFeet = maxMeters * 3.2808399;
    var maxMiles,
      miles,
      feet;

    if (maxFeet > 5280) {
      maxMiles = maxFeet / 5280;
      miles = this._getRoundNum(maxMiles);
      this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

    } else {
      feet = this._getRoundNum(maxFeet);
      this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
    }
  };
  Scale.prototype._updateScale = function _updateScale (scale, text, ratio) {
    scale.style.width = Math.round(this.get('maxWidth') * ratio) + 'px';
    scale.innerHTML = text;
  };
  Scale.prototype._getRoundNum = function _getRoundNum (num) {
    var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
    var d = num / pow10;

    d = d >= 10 ? 10 :
      d >= 5 ? 5 :
        d >= 3 ? 3 :
          d >= 2 ? 2 : 1;

    return pow10 * d;
  };

  return Scale;
}(Control$1));

var Attribution = /*@__PURE__*/(function (Control) {
  function Attribution(cfg) {
    Control.call(this, Object.assign({}, {position: 'bottomright',
      prefix: '<a href="https://antv.alipay.com/zh-cn/l7/1.x/index.html" title="地理空间数据可视化引擎">AntV L7</a>'},
      cfg));
    this._attributions = {};
  }

  if ( Control ) Attribution.__proto__ = Control;
  Attribution.prototype = Object.create( Control && Control.prototype );
  Attribution.prototype.constructor = Attribution;
  Attribution.prototype.onAdd = function onAdd (scene) {
    this._container = create('div', 'l7-control-attribution');
    var layers = scene.getLayers();
    for (var i in layers) {
      if (layers[i].get('attribution')) {
        this.addAttribution(layers[i].get('attribution'));
      }
    }

    this._update();

    return this._container;
  };

  Attribution.prototype.setPrefix = function setPrefix (prefix) {
    this.set('prefix', prefix);
    this._update();
    return this;
  };
  Attribution.prototype.addAttribution = function addAttribution (text) {
    if (!text) { return this; }

    if (!this._attributions[text]) {
      this._attributions[text] = 0;
    }
    this._attributions[text]++;

    this._update();

    return this;
  };

  Attribution.prototype.removeAttribution = function removeAttribution (text) {
    if (!text) { return this; }

    if (this._attributions[text]) {
      this._attributions[text]--;
      this._update();
    }

    return this;
  };
  Attribution.prototype._update = function _update () {
    if (!this._scene) { return; }

    var attribs = [];

    for (var i in this._attributions) {
      if (this._attributions[i]) {
        attribs.push(i);
      }
    }
    var prefixAndAttribs = [];
    if (this.get('prefix')) {
      prefixAndAttribs.push(this.get('prefix'));
    }
    if (attribs.length) {
      prefixAndAttribs.push(attribs.join(', '));
    }
    this._container.innerHTML = prefixAndAttribs.join(' | ');
  };

  return Attribution;
}(Control$1));

var Layers = /*@__PURE__*/(function (Control) {
  function Layers(cfg) {
    Control.call(this, Object.assign({}, {collapsed: true,
      position: 'topright',
      autoZIndex: true,
      hideSingleBase: false,
      sortLayers: false},
      cfg));
    this._layerControlInputs = [];
    this._layers = [];
    this._lastZIndex = 0;
    this._handlingClick = false;
    var baseLayers = this.get('baseLayers');
    var overlays = this.get('overlayers');
    for (var i in baseLayers) {
      this._addLayer(baseLayers[i], i);
    }

    for (var i$1 in overlays) {
      this._addLayer(overlays[i$1], i$1, true);
    }
    actor.bindAll([ '_checkDisabledLayers', '_onLayerChange', 'collapse', 'extend', 'expand', '_onInputClick' ], this);
  }

  if ( Control ) Layers.__proto__ = Control;
  Layers.prototype = Object.create( Control && Control.prototype );
  Layers.prototype.constructor = Layers;

  Layers.prototype.onAdd = function onAdd (scene) {
    this._initLayout();
    this._update();
    this._scene = scene;
    scene.on('zoomend', this._checkDisabledLayers, this);

    for (var i = 0; i < this._layers.length; i++) {
      this._layers[i].layer.on('remove', this._onLayerChange);
      this._layers[i].layer.on('add', this._onLayerChange);
    }

    return this._container;
  };
  Layers.prototype.addTo = function addTo (scene) {
    Control.prototype.addTo.call(this, scene);
  };

  Layers.prototype.addVisualLayer = function addVisualLayer (layer, name) {
    this._addLayer(layer, name, true);
    return (this._scene) ? this._update() : this;
  };

  Layers.prototype._initLayout = function _initLayout () {
    var className = 'l7-control-layers',
      container = this._container = create('div', className),
      collapsed = this.get('collapsed');

    // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
    container.setAttribute('aria-haspopup', true);


    var form = this._form = create('form', className + '-list');

    if (collapsed) {
      this._scene.on('click', this.collapse);
      container.addEventListener('mouseenter', this.expand);
      container.addEventListener('mouseleave', this.collapse);

    }

    var link = this._layersLink = create('a', className + '-toggle', container);
    link.href = '#';
    link.title = 'Layers';
    if (!collapsed) {
      this.expand();
    }

    this._baseLayersList = create('div', className + '-base', form);
    this._separator = create('div', className + '-separator', form);
    this._overlaysList = create('div', className + '-overlays', form);

    container.appendChild(form);
  };

  Layers.prototype._update = function _update () {
    if (!this._container) { return this; }

    empty(this._baseLayersList);
    empty(this._overlaysList);

    this._layerControlInputs = [];
    var baseLayersPresent,
      overlaysPresent,
      i,
      obj,
      baseLayersCount = 0;

    for (i = 0; i < this._layers.length; i++) {
      obj = this._layers[i];
      this._addItem(obj);
      overlaysPresent = overlaysPresent || obj.overlay;
      baseLayersPresent = baseLayersPresent || !obj.overlay;
      baseLayersCount += !obj.overlay ? 1 : 0;
    }

    // Hide base layers section if there's only one layer.
    if (this.get('hideSingleBase')) {
      baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
      this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
    }

    this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

    return this;
  };

  Layers.prototype.expand = function expand () {
    addClass(this._container, 'l7-control-layers-expanded');
    this._form.style.height = null;
    var acceptableHeight = this._scene.getSize().height - (this._container.offsetTop + 50);
    if (acceptableHeight < this._form.clientHeight) {
      addClass(this._form, 'l7-control-layers-scrollbar');
      this._form.style.height = acceptableHeight + 'px';
    } else {
      removeClass(this._form, 'l7-control-layers-scrollbar');
    }
    this._checkDisabledLayers();
    return this;
  };

  Layers.prototype.collapse = function collapse () {
    removeClass(this._container, 'l7-control-layers-expanded');
    return this;
  };

  Layers.prototype._checkDisabledLayers = function _checkDisabledLayers () {
    var inputs = this._layerControlInputs;
    var input,
      layer;
    var zoom = this._scene.getZoom();

    for (var i = inputs.length - 1; i >= 0; i--) {
      input = inputs[i];
      layer = this._scene.getLayer(input.layerId);
      input.disabled = (layer.get('minZoom') !== undefined && zoom < layer.get('minZoom')) ||
        (zoom < layer.get('maxZoom') !== undefined && zoom > layer.get('maxZoom'));

    }
  };

  Layers.prototype._addLayer = function _addLayer (layer, name, overlay) {
    var this$1 = this;

    if (this._scene) {
      layer.on('add', this._onLayerChange);
      layer.on('remove', this._onLayerChange);
    }
    this._layers.push({
      layer: layer,
      name: name,
      overlay: overlay
    });

    if (this.get('sortLayers')) {
      this._layers.sort(function (a, b) {
        return this$1.get('sortFunction')(a.layer, b.layer, a.name, b.name);
      });
    }

    if (this.get('autoZIndex') && layer.setZIndex) {
      this._lastZIndex++;
      layer.setZIndex(this._lastZIndex);
    }

    this._expandIfNotCollapsed();
  };

  Layers.prototype._expandIfNotCollapsed = function _expandIfNotCollapsed () {
    if (this._scene && !this.get('collapsed')) {
      this.expand();
    }
    return this;
  };

  Layers.prototype._onLayerChange = function _onLayerChange (e) {
    if (!this._handlingClick) {
      this._update();
    }

    var obj = this._scene.getLayer(e.target.layerId);

    var type = obj.overlay ?
      (e.type === 'add' ? 'overlayadd' : 'overlayremove') :
      (e.type === 'add' ? 'baselayerchange' : null);

    if (type) {
      this._map.fire(type, obj);
    }
  };

  Layers.prototype._createRadioElement = function _createRadioElement (name, checked) {

    var radioHtml = '<input type="radio" class="l7-control-layers-selector" name="' +
      name + '"' + (checked ? ' checked="checked"' : '') + '/>';

    var radioFragment = document.createElement('div');
    radioFragment.innerHTML = radioHtml;

    return radioFragment.firstChild;
  };

  Layers.prototype._addItem = function _addItem (obj) {
    var label = document.createElement('label'),
      checked = !!this._scene.getLayer(obj.layer.layerId);
    var input;

    if (obj.overlay) {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.className = 'l7-control-layers-selector';
      input.defaultChecked = checked;
    } else {
      input = this._createRadioElement('l7-base-layers', checked);
    }
    this._layerControlInputs.push(input);
    input.layerId = obj.layer.layerId;
    input.addEventListener('click', this._onInputClick);

    var name = document.createElement('span');
    name.innerHTML = ' ' + obj.name;

    var holder = document.createElement('div');

    label.appendChild(holder);
    holder.appendChild(input);
    holder.appendChild(name);

    var container = obj.overlay ? this._overlaysList : this._baseLayersList;
    container.appendChild(label);

    this._checkDisabledLayers();
    return label;

  };
  Layers.prototype._onInputClick = function _onInputClick () {
    var inputs = this._layerControlInputs;
    var input,
      layer;
    var addedLayers = [],
      removedLayers = [];
    this._handlingClick = true;
    for (var i = inputs.length - 1; i >= 0; i--) {
      input = inputs[i];
      layer = this._scene.getLayer(input.layerId);

      if (input.checked) {
        addedLayers.push(layer);
      } else if (!input.checked) {
        removedLayers.push(layer);
      }
    }
    for (var i$1 = 0; i$1 < removedLayers.length; i$1++) {
      removedLayers[i$1].hide();
    }
    for (var i$2 = 0; i$2 < addedLayers.length; i$2++) {
      addedLayers[i$2].show();
    }

    this._handlingClick = false;

    this._refocusOnMap();

  };

  return Layers;
}(Control$1));



var Control$2 = /*#__PURE__*/Object.freeze({
Base: Control$1,
Zoom: Zoom,
Scale: Scale,
Attribution: Attribution,
Layers: Layers
});

var EventNames = [ 'mouseout', 'mouseover', 'mousemove', 'mousedown', 'mouseleave', 'mouseleave', 'mouseleave', 'touchstart', 'touchmove', 'touchend', 'mouseup', 'rightclick', 'click', 'dblclick' ];
var Scene$1 = /*@__PURE__*/(function (Base) {
  function Scene(cfg) {
    Base.call(this, cfg);
    this._initMap();
    this.crs = crsEpsg3857_1;
    this.fontAtlasManager = new FontAtlasManager();
    this._layers = [];
    this.animateCount = 0;
  }

  if ( Base ) Scene.__proto__ = Base;
  Scene.prototype = Object.create( Base && Base.prototype );
  Scene.prototype.constructor = Scene;

  Scene.prototype.getDefaultCfg = function getDefaultCfg () {
    return actor.Global.scene;
  };

  Scene.prototype._initEngine = function _initEngine (mapContainer) {
    this._engine = new Engine(mapContainer, this);
    this.addImage();// 初始化图标加载器
    this.registerMapEvent(); // 和高德地图同步状态
    // this._engine.run();
    compileBuiltinModules();
  };
  Scene.prototype._initContoller = function _initContoller () {
    var controlCtr = new Control({ scene: this });
    this.set('controlController', controlCtr);
    if (this.get('zoomControl')) {
      var zoomControl = new Zoom().addTo(this);
      this.set('zoomControl', zoomControl);

    }
    if (this.get('scaleControl')) {
      var scaleControl = new Scale().addTo(this);
      this.set('scaleControl', scaleControl);
    }
    if (this.get('attributionControl')) {
      var attributionControl = new Attribution().addTo(this);
      this.set('attributionControl', attributionControl);
    }
  };
  // 为pickup场景添加 object 对象
  Scene.prototype.addPickMesh = function addPickMesh (object) {
    this._engine._picking.add(object);
  };
  Scene.prototype._initMap = function _initMap () {
    var this$1 = this;

    this.mapContainer = this.get('id');
    this.mapType = this.get('mapType') || 'amap';
    var MapProvider = actor.getMap(this.mapType);
    var Map = new MapProvider(this._attrs);
    Map.mixMap(this);
    this._container = Map.container;
    Map.on('mapLoad', function () {
      this$1.map = Map.map;
      this$1._markerContainier = Map.l7_marker_Container;
      this$1._initEngine(Map.renderDom);
      Map.asyncCamera(this$1._engine);
      this$1.initLayer();
      this$1._registEvents();
      var hash = this$1.get('hash');
      if (hash) {
        var Ctor = getInteraction('hash');
        var interaction = new Ctor({ layer: this$1 });
        interaction._onHashChange();
      }
      this$1.style = new Style(this$1, {});
      this$1._initContoller();
      this$1.emit('loaded');
    });
  };
  Scene.prototype.initLayer = function initLayer () {
    var this$1 = this;

    var loop = function ( key ) {
      Scene.prototype[key] = function (cfg) {
        var layer = new LAYER_MAP[key](this$1, cfg);
        this$1._layers.push(layer);
        return layer;
      };
    };

    for (var key in LAYER_MAP) loop( key );

  };
  // 添加 Tile Source
  Scene.prototype.addTileSource = function addTileSource (id, Sourcecfg) {
    this.style.addSource(id, Sourcecfg);
  };
  Scene.prototype.getTileSource = function getTileSource (id) {
    return this.style.getSource(id);
  };
  Scene.prototype.on = function on (type, hander) {
    if (this.map) { this.map.on(type, hander); }
    Base.prototype.on.call(this, type, hander);
  };
  Scene.prototype.off = function off (type, hander) {
    if (this.map) { this.map.off(type, hander); }
    Base.prototype.off.call(this, type, hander);
  };
  Scene.prototype.addImage = function addImage () {
    var this$1 = this;

    this.image = new LoadImage();
    this.image.on('imageLoaded', function () {
      this$1._engine.update();
    });
  };
  Scene.prototype._initEvent = function _initEvent () {

  };
  Scene.prototype.getLayers = function getLayers () {
    return this._layers;
  };
  Scene.prototype.getLayer = function getLayer (id) {
    var res = false;
    this._layers.forEach(function (layer) {
      if (layer.layerId === id) {
        res = layer;
        return;
      }
    });
    return res;
  };
  Scene.prototype._addLayer = function _addLayer () {

  };
  Scene.prototype.getContainer = function getContainer () {
    return this._container;
  };
  Scene.prototype.getMarkerContainer = function getMarkerContainer () {
    return this._markerContainier;
  };
  Scene.prototype.map2Png = function map2Png () {
    this.scene._engine.update();
    var vis = this.scene._engine._renderer.domElement.toDataURL();
    var map = this.scene.map.getContainer().getElementsByClassName('amap-layer')[0].toDataURL();
    return [ map, vis ];

  };
  Scene.prototype._registEvents = function _registEvents () {
    var this$1 = this;

    this._eventHander = function (e) {
      if (e.target.nodeName !== 'CANVAS') { return; }
      this$1._engine._picking.pickdata(e);
    };
    EventNames.forEach(function (event) {
      this$1._container.addEventListener(event, this$1._eventHander, true);
    });
  };
  Scene.prototype._unRegistEvents = function _unRegistEvents () {
    var this$1 = this;

    EventNames.forEach(function (event) {
      this$1._container.removeEventListener(event, this$1._eventHander, true);
    });
  };

  Scene.prototype.removeLayer = function removeLayer (layer) {
    var layerIndex = this._layers.indexOf(layer);
    if (layerIndex > -1) {
      this._layers.splice(layerIndex, 1);
    }
    layer.destroy();
    layer = null;
    this._engine.update();
  };
  Scene.prototype.startAnimate = function startAnimate () {
    if (this.animateCount === 0) {
      this.unRegsterMapEvent();
      this._engine.run();
    }
    this.animateCount++;
  };

  Scene.prototype.stopAnimate = function stopAnimate () {
    if (this.animateCount === 1) {
      this._engine.stop();
      this.registerMapEvent();
    }
    this.animateCount++;
  };
  // 地图状态变化时更新可视化渲染
  Scene.prototype.registerMapEvent = function registerMapEvent () {
    var this$1 = this;

    this._updateRender = function () { return this$1._engine.update(); };
    // this.map.on('mousemove', this._updateRender);
    this.map.on('mapmove', this._updateRender);
    this.map.on('camerachange', this._updateRender);
    window.addEventListener('onresize', this._updateRender);
  };

  Scene.prototype.unRegsterMapEvent = function unRegsterMapEvent () {
    // this.map.off('mousemove', this._updateRender);
    this.map.off('mapmove', this._updateRender);
    this.map.off('camerachange', this._updateRender);
    window.removeEventListener('onresize', this._updateRender);
  };
  // control

  Scene.prototype.addControl = function addControl (ctr) {
    this.get('controlController').addControl(ctr);
    return this;
  };

  Scene.prototype.removeControl = function removeControl (ctr) {
    this.get('controlController').removeControl(ctr);
  };
  Scene.prototype.render = function render () {
    this._engine.update();
  };
  Scene.prototype.destroy = function destroy () {
    Base.prototype.destroy.call(this);
    this._layers.forEach(function (layer) {
      layer.destroy();
    });
    this._layers.length = 0;
    this.image = null;
    this.fontAtlasManager = null;
    this.style.destroy();
    this.style = null;
    this._engine.destroy();
    this._engine = null;
    this.map.destroy();
    this.unRegsterMapEvent();
    this._unRegistEvents();


  };

  return Scene;
}(actor.Base));

var anchorTranslate = {
  center: 'translate(-50%,-50%)',
  top: 'translate(-50%,0)',
  'top-left': 'translate(0,0)',
  'top-right': 'translate(-100%,0)',
  bottom: 'translate(-50%,-100%)',
  'bottom-left': 'translate(0,-100%)',
  'bottom-right': 'translate(-100%,-100%)',
  left: 'translate(0,-50%)',
  right: 'translate(-100%,-50%)'
};
function applyAnchorClass(element, anchor, prefix) {
  var classList = element.classList;
  for (var key in anchorTranslate) {
    classList.remove(("l7-" + prefix + "-anchor-" + key));
  }
  classList.add(("l7-" + prefix + "-anchor-" + anchor));
}

var Popup = /*@__PURE__*/(function (Base) {
  function Popup(cfg) {
    Base.call(this, Object.assign({}, {closeButton: true,
      closeOnClick: true,
      maxWidth: '240px',
      anchor: 'bottom'},
      cfg));
    this.timeout = 0;
    actor.bindAll([ '_update', '_onClickClose', 'remove' ], this);
  }

  if ( Base ) Popup.__proto__ = Base;
  Popup.prototype = Object.create( Base && Base.prototype );
  Popup.prototype.constructor = Popup;
  Popup.prototype.addTo = function addTo (scene) {
    var this$1 = this;

    this._scene = scene;
    this._scene.on('camerachange', this._update);
    this._update();
    if (this.get('closeOnClick')) {
      this.timeout = setTimeout(function () { // TODO 事件冲突
        this$1._scene && this$1._scene.on('click', this$1._onClickClose);
      }, 30);
    }
    return this;
  };
  Popup.prototype.setLnglat = function setLnglat (lngLat) {
    this.lngLat = lngLat;
    if (this._scene) {
      this._scene.on('camerachange', this._update);
    }
    this._update(lngLat);
    return this;
  };

  Popup.prototype._update = function _update () {
    var this$1 = this;

    var hasPosition = this.lngLat;
    if (!this._scene || !hasPosition || !this._content) { return; }
    if (!this._container) {
      this._container = this.creatDom('div', 'l7-popup', this._scene.getMarkerContainer().parentNode);

      this._tip = this.creatDom('div', 'l7-popup-tip', this._container);
      this._container.appendChild(this._content);
      if (this.get('className')) {
        this.get('className').split(' ').forEach(function (name) { return this$1._container.classList.add(name); });
      }
      this._container.addEventListener('mousedown', function (e) {
        e.stopPropagation();
      });
    }
    if (this.get('maxWidth') && this._container.style.maxWidth !== this.get('maxWidth')) {
      this._container.style.maxWidth = this.get('maxWidth');
    }

    this._updatePosition();
    setTransform(this._container, ("" + (anchorTranslate[this.get('anchor')])));
    applyAnchorClass(this._container, this.get('anchor'), 'popup');
  };

  Popup.prototype._updatePosition = function _updatePosition () {
    if (!this._scene) { return; }
    var pos = this._scene.lngLatToContainer(this.lngLat);
    this._container.style.left = pos.x + 'px';
    this._container.style.top = pos.y + 'px';
  };

  Popup.prototype.setHTML = function setHTML (html) {
    var frag = window.document.createDocumentFragment();
    var temp = window.document.createElement('body');
    var child;
    temp.innerHTML = html;
    while (true) {  // eslint-disable-line
      child = temp.firstChild;
      if (!child) { break; }
      frag.appendChild(child);
    }

    return this.setDOMContent(frag);
  };
  Popup.prototype.setText = function setText (text) {
    return this.setDOMContent(window.document.createTextNode(text));
  };
  Popup.prototype.setMaxWidth = function setMaxWidth (maxWidth) {
    this.set('maxWidth', maxWidth);
    this._update();
    return this;
  };
  Popup.prototype.setDOMContent = function setDOMContent (htmlNode) {
    this._createContent();
    this._content.appendChild(htmlNode);
    this._update();
    return this;
  };
  Popup.prototype._createContent = function _createContent () {
    if (this._content) {
      remove(this._content);
    }
    this._content = create('div', 'l7-popup-content', this._container);
    if (this.get('closeButton')) {
      this._closeButton = create('button', 'l7-popup-close-button', this._content);
      this._closeButton.type = 'button';
      this._closeButton.setAttribute('aria-label', 'Close popup');
      this._closeButton.innerHTML = '&#215;';
      this._closeButton.addEventListener('click', this._onClickClose);
    }
  };
  Popup.prototype._onClickClose = function _onClickClose () {
    this.remove();
  };
  Popup.prototype.creatDom = function creatDom (tagName, className, container) {
    var el = window.document.createElement(tagName);
    if (className !== undefined) { el.className = className; }
    if (container) { container.appendChild(el); }
    return el;
  };
  Popup.prototype.removeDom = function removeDom (node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  };
  // 移除popup
  Popup.prototype.remove = function remove () {
    if (this._content) {
      this.removeDom(this._content);
    }

    if (this._container) {
      this.removeDom(this._container);
      delete this._container;
    }
    if (this._scene) {
      this._scene.off('camerachange', this._update);
      this._scene.off('click', this._onClickClose);
      delete this._scene;
    }
    clearTimeout(this.timeout);
    this.emit('close');
    return this;
  };
  Popup.prototype.isOpen = function isOpen () {
    return !!this._scene;
  };

  return Popup;
}(actor.Base));

var Marker = /*@__PURE__*/(function (Base) {
  function Marker(cfg) {
    Base.call(this, Object.assign({}, {element: '', // DOM element
      anchor: 'bottom',
      offset: [ 0, 0 ],
      color: '#2f54eb',
      draggable: false},
      cfg));
    actor.bindAll([
      '_update',
      '_onMove',
      '_onUp',
      '_addDragHandler',
      '_onMapClick'
    ], this);
    this._init();
  }

  if ( Base ) Marker.__proto__ = Base;
  Marker.prototype = Object.create( Base && Base.prototype );
  Marker.prototype.constructor = Marker;
  Marker.prototype._init = function _init () {
    var this$1 = this;

    var element = this.get('element');
    if (!element) {
      this._defaultMarker = true;
      element = create('div');
      this.set('element', element);
      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttributeNS(null, 'display', 'block');
      svg.setAttributeNS(null, 'height', '48px');
      svg.setAttributeNS(null, 'width', '48px');
      svg.setAttributeNS(null, 'viewBox', '0 0 1024 1024');

      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttributeNS(null, 'd', 'M512 490.666667C453.12 490.666667 405.333333 442.88 405.333333 384 405.333333 325.12 453.12 277.333333 512 277.333333 570.88 277.333333 618.666667 325.12 618.666667 384 618.666667 442.88 570.88 490.666667 512 490.666667M512 85.333333C346.88 85.333333 213.333333 218.88 213.333333 384 213.333333 608 512 938.666667 512 938.666667 512 938.666667 810.666667 608 810.666667 384 810.666667 218.88 677.12 85.333333 512 85.333333Z');
      path.setAttributeNS(null, 'fill', this.get('color'));
      svg.appendChild(path);
      element.appendChild(svg);

    }
    addClass(element, 'l7-marker');
    element.addEventListener('click', function (e) {
      this$1._onMapClick(e);
    });
    applyAnchorClass(element, this.get('anchor'), 'marker');

    this._popup = null;

  };
  Marker.prototype.addTo = function addTo (scene) {
    this.remove();
    this._scene = scene;
    this._scene.getMarkerContainer().appendChild(this.get('element'));
    this._scene.on('camerachange', this._update);
    this.setDraggable(this.get('draggable'));
    this._update();
    return this;
  };

  Marker.prototype.remove = function remove$1 () {
    if (this._scene) {
      this._scene.off('click', this._onMapClick);
      this._scene.off('move', this._update);
      this._scene.off('moveend', this._update);
      this._scene.off('mousedown', this._addDragHandler);
      this._scene.off('touchstart', this._addDragHandler);
      this._scene.off('mouseup', this._onUp);
      this._scene.off('touchend', this._onUp);
      delete this._scene;
    }
    remove(this.get('element'));
    if (this._popup) { this._popup.remove(); }
    return this;
  };
  Marker.prototype.setLnglat = function setLnglat (lngLat) {
    this._lngLat = lngLat;
    if (this._popup) { this._popup.setLnglat(this._lngLat); }
    return this;
  };
  Marker.prototype.getLnglat = function getLnglat () {
    return this._lngLat;
  };

  Marker.prototype.getElement = function getElement () {
    return this.get('element');
  };

  Marker.prototype.setPopup = function setPopup (popup) {
    this._popup = popup;
    if (this._lngLat) { this._popup.setLnglat(this._lngLat); }
    return this;
  };

  Marker.prototype.togglePopup = function togglePopup () {
    var popup = this._popup;
    if (!popup) { return this; }
    else if (popup.isOpen()) { popup.remove(); }
    else { popup.addTo(this._scene); }
    return this;
  };

  Marker.prototype.getPopup = function getPopup () {
    return this._popup;
  };

  Marker.prototype.getOffset = function getOffset () {

  };

  Marker.prototype.setDraggable = function setDraggable () {

  };

  Marker.prototype.isDraggable = function isDraggable () {
    return this._draggable;
  };
  Marker.prototype._update = function _update () {
    if (!this._scene) { return; }
    this._updatePosition();
    setTransform(this.get('element'), ("" + (anchorTranslate[ this.get('anchor')])));

  };
  Marker.prototype._onMapClick = function _onMapClick () {
    // this._scene.emit('click'); // 触发map点击事件，关闭其他popup
    var element = this.get('element');

    if (this._popup && element) {
      this.togglePopup();
    }
  };
  Marker.prototype._updatePosition = function _updatePosition () {
    if (!this._scene) { return; }
    var pos = this._pos = this._scene.lngLatToContainer(this._lngLat);
    this.get('element').style.left = pos.x + 'px';
    this.get('element').style.top = pos.y + 'px';

  };
  Marker.prototype._bubbleUp = function _bubbleUp () {
    var this$1 = this;

    var eventsName = [
      'mouseout',
      'mouseover',
      'mousemove',
      'mousedown',
      'mouseleave',
      'mouseup',
      'rightclick',
      'click',
      'dblclick',
      'wheel'
    ];
    var element = this.get('element');
    eventsName.forEach(function (event) {
      element.addEventListener(event, function (e) {
        this$1._scene.emit(event, e);
      });
    });
  };

  Marker.prototype._addDragHandler = function _addDragHandler () {

  };
  Marker.prototype._onUp = function _onUp () {

  };

  return Marker;
}(actor.Base));

var version = actor.Global.version;
var exported = {
  version: version,
  Scene: Scene$1,
  Source: actor.Source,
  TileSource: TileSource,
  registerParser: actor.registerParser,
  registerTransform: actor.registerTransform,
  registerLayer: registerLayer,
  registerInteraction: registerInteraction,
  getInteraction: getInteraction,
  Popup: Popup,
  Marker: Marker,
  Control: Control$2
};

return exported;

});

return L7;

}));
//# sourceMappingURL=L7.js.map
});

var L7$1 = unwrapExports(L7);

var Children = React.Children;

var Scene = function (_Component) {
  inherits(Scene, _Component);

  function Scene() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Scene);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Scene.__proto__ || Object.getPrototypeOf(Scene)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      mapLoaded: false,
      scene: null
    }, _this.getChildContext = function () {
      return {
        scene: _this.state.scene,
        L7: L7$1
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Scene, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.createInstance();
    }
  }, {
    key: 'createInstance',
    value: function createInstance() {
      var _this2 = this;

      console.log('L7 version', L7$1.version);
      var mapView = this.props.mapView;

      this.scene = new L7$1.Scene(_extends({
        id: 'map',
        mapStyle: 'dark', // 样式URL
        center: [120.19382669582967, 30.258134],
        pitch: 0,
        zoom: 3,
        rotation: 0,
        attributionControl: false,
        scaleControl: false,
        zoomControl: false
      }, mapView));
      this.scene.on('loaded', function () {
        var _props$style = _this2.props.style,
            style = _props$style === undefined ? {} : _props$style;
        // 覆盖高德地图默认地图背景颜色

        if (style.background) {
          _this2.mapWrapper.style.background = style.background;
        }
        console.log();
        window.scene = _this2.scene;
        _this2.setState({
          mapLoaded: true,
          scene: _this2.scene
        });
      });
    }
  }, {
    key: 'renderChildren',
    value: function renderChildren() {
      var _this3 = this;

      return Children.map(this.props.children, function (child) {
        if (child) {
          return React.cloneElement(child, {
            scene: _this3.scene
          });
        }
        return child;
      });
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var scene = this.state.scene;

      if (!scene) {
        return null;
      }
      var mapView = this.props.mapView;

      var nextMapView = nextProps.mapView;
      var center = scene.getCenter();
      var zoom = scene.getZoom();
      var rotation = scene.getRotation();
      var pitch = scene.getPitch();
      var mapStyle = scene.get('mapStyle');
      this.controlUpdate(nextProps.mapView);
      var didZoomUpdate = this._needUpdate(mapView.zoom, nextMapView.zoom, zoom);
      var didCenterUpdate = mapView.center !== nextMapView.center && ((nextMapView.center && nextMapView.center[0]) !== center.lng || (nextMapView.center && nextMapView.center) !== center.lat);
      var didStyleUpdate = this._needUpdate(mapView.mapStyle, nextMapView.mapStyle, mapStyle);
      var didBearingUpdate = this._needUpdate(mapView.rotation, nextMapView.rotation, rotation);
      var didPitchUpdate = this._needUpdate(mapView.pitch, nextMapView.pitch, pitch);
      didStyleUpdate && scene.setMapStyle(nextMapView.mapStyle);
      didBearingUpdate && scene.setRotation(nextMapView.rotation);
      didCenterUpdate && scene.setCenter(nextMapView.center);
      didPitchUpdate && scene.setPitch(nextMapView.pitch);
      didZoomUpdate && scene.setZoom(nextMapView.zoom);

      // update control
    }
  }, {
    key: 'controlUpdate',
    value: function controlUpdate(nextProps) {
      var scene = this.state.scene;

      var controls = ['zoomControl', 'scaleControl', 'attributionControl'];
      controls.forEach(function (control) {
        var isShow = nextProps[control];
        if (!isShow && scene.get(control) && scene.get(control).isShow) {
          // 存在 不可见
          scene.get(control).hide();
        }
        if (isShow && scene.get(control) && !scene.get(control).isShow) {
          scene.get(control).show();
        }
        if (isShow && !scene.get(control)) {
          // 需要添加组件
          var option = Scene.controlOption[control];
          var ctr = new L7$1.Control[option.name]({
            position: option.position
          }).addTo(scene);
          scene.set(control, ctr);
        }
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.scene.destroy();
    }
  }, {
    key: '_needUpdate',
    value: function _needUpdate(preValue, nextValue, sceneValue) {
      return preValue !== nextValue && nextValue !== sceneValue;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props = this.props,
          _props$style2 = _props.style,
          style = _props$style2 === undefined ? {} : _props$style2,
          className = _props.className;

      return React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          {
            id: 'map',
            style: _extends({
              width: '100%',
              margin: '0',
              height: '100%',
              position: 'absolute'
            }, style),
            className: className,
            ref: function ref(div) {
              _this4.mapWrapper = div;
            }
          },
          this.state.mapLoaded ? null : this.props.loading || null
        ),
        React.createElement(
          'div',
          null,
          this.state.mapLoaded ? this.renderChildren() : null
        )
      );
    }
  }]);
  return Scene;
}(Component);

Scene.MapViewOption = {
  center: PropTypes.array,
  zoom: PropTypes.number,
  mapStyle: PropTypes.string,
  pitch: PropTypes.number,
  rotation: PropTypes.number

};
Scene.propTypes = {
  children: PropTypes.array,
  loading: PropTypes.bool,
  mapView: PropTypes.object,
  style: PropTypes.object,
  className: PropTypes.string
};
Scene.childContextTypes = {
  scene: PropTypes.object,
  L7: PropTypes.object
};
Scene.controlOption = {
  zoomControl: {
    name: 'Zoom',
    position: 'topleft'
  },
  scaleControl: {
    name: 'Scale',
    position: 'bottomleft'
  },
  attributionControl: {
    name: 'Attribution',
    position: 'bottomright'
  }
};

var toStr = Object.prototype.toString;

var isArguments = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr$1 = Object.prototype.toString;
	var isArgs = isArguments; // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr$1.call(object) === '[object Function]';
		var isArguments$$1 = isArgs(object);
		var isString = isObject && toStr$1.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments$$1) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments$$1 && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
var implementation = keysShim;

var slice = Array.prototype.slice;


var origKeys = Object.keys;
var keysShim$1 = origKeys ? function keys(o) { return origKeys(o); } : implementation;

var originalKeys = Object.keys;

keysShim$1.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArguments(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim$1;
	}
	return Object.keys || keysShim$1;
};

var _objectKeys_1_1_1_objectKeys = keysShim$1;

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr$2 = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr$2.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr$2.call(value) !== '[object Array]' &&
		toStr$2.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

var _isArguments_1_0_4_isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.is */

var NumberIsNaN = function (value) {
	return value !== value;
};

var _objectIs_1_0_1_objectIs = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	} else if (a === b) {
		return true;
	} else if (NumberIsNaN(a) && NumberIsNaN(b)) {
		return true;
	}
	return false;
};

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice$1 = Array.prototype.slice;
var toStr$3 = Object.prototype.toString;
var funcType = '[object Function]';

var implementation$1 = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr$3.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice$1.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice$1.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice$1.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

var _functionBind_1_1_1_functionBind = Function.prototype.bind || implementation$1;

var src = _functionBind_1_1_1_functionBind.call(Function.call, Object.prototype.hasOwnProperty);

var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr$4 = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var _isRegex_1_0_4_isRegex = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag$1) {
		return toStr$4.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && src(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr$5 = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr$5.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty$1 = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = _objectKeys_1_1_1_objectKeys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

var _defineProperties_1_1_3_defineProperties = defineProperties;

var toObject = Object;
var TypeErr = TypeError;

var implementation$2 = function flags() {
	if (this != null && this !== toObject(this)) {
		throw new TypeErr('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
};

var supportsDescriptors$1 = _defineProperties_1_1_3_defineProperties.supportsDescriptors;
var gOPD$1 = Object.getOwnPropertyDescriptor;
var TypeErr$1 = TypeError;

var polyfill = function getPolyfill() {
	if (!supportsDescriptors$1) {
		throw new TypeErr$1('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	if (/a/mig.flags === 'gim') {
		var descriptor = gOPD$1(RegExp.prototype, 'flags');
		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
			return descriptor.get;
		}
	}
	return implementation$2;
};

var supportsDescriptors$2 = _defineProperties_1_1_3_defineProperties.supportsDescriptors;

var gOPD$2 = Object.getOwnPropertyDescriptor;
var defineProperty$2 = Object.defineProperty;
var TypeErr$2 = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

var shim = function shimFlags() {
	if (!supportsDescriptors$2 || !getProto) {
		throw new TypeErr$2('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	var polyfill$$1 = polyfill();
	var proto = getProto(regex);
	var descriptor = gOPD$2(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill$$1) {
		defineProperty$2(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill$$1
		});
	}
	return polyfill$$1;
};

var flagsBound = Function.call.bind(implementation$2);

_defineProperties_1_1_3_defineProperties(flagsBound, {
	getPolyfill: polyfill,
	implementation: implementation$2,
	shim: shim
});

var _regexp_prototype_flags_1_2_0_regexp_prototype_flags = flagsBound;

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr$6 = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag$2 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var _isDateObject_1_0_1_isDateObject = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag$2 ? tryDateObject(value) : toStr$6.call(value) === dateClass;
};

var getTime = Date.prototype.getTime;

function deepEqual(actual, expected, options) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? _objectIs_1_0_1_objectIs(actual, expected) : actual === expected) {
    return true;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
    return opts.strict ? _objectIs_1_0_1_objectIs(actual, expected) : actual == expected;
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // eslint-disable-next-line no-use-before-define
  return objEquiv(actual, expected, opts);
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }
  return true;
}

function objEquiv(a, b, opts) {
  /* eslint max-statements: [2, 50] */
  var i, key;
  if (typeof a !== typeof b) { return false; }
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) { return false; }

  if (_isArguments_1_0_4_isArguments(a) !== _isArguments_1_0_4_isArguments(b)) { return false; }

  var aIsRegex = _isRegex_1_0_4_isRegex(a);
  var bIsRegex = _isRegex_1_0_4_isRegex(b);
  if (aIsRegex !== bIsRegex) { return false; }
  if (aIsRegex || bIsRegex) {
    return a.source === b.source && _regexp_prototype_flags_1_2_0_regexp_prototype_flags(a) === _regexp_prototype_flags_1_2_0_regexp_prototype_flags(b);
  }

  if (_isDateObject_1_0_1_isDateObject(a) && _isDateObject_1_0_1_isDateObject(b)) {
    return getTime.call(a) === getTime.call(b);
  }

  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) { return false; }
  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
    if (a.length !== b.length) { return false; }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  if (typeof a !== typeof b) { return false; }

  try {
    var ka = _objectKeys_1_1_1_objectKeys(a);
    var kb = _objectKeys_1_1_1_objectKeys(b);
  } catch (e) { // happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) { return false; }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) { return false; }
  }
  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) { return false; }
  }

  return true;
}

var _deepEqual_1_1_0_deepEqual = deepEqual;

/* eslint-disable camelcase */
var Children$1 = React.Children;

var BaseLayer = function (_Component) {
  inherits(BaseLayer, _Component);

  function BaseLayer() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, BaseLayer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BaseLayer.__proto__ || Object.getPrototypeOf(BaseLayer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      layer: false
    }, _this.getChildContext = function () {
      return {
        layer: _this.layer
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(BaseLayer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.initLayer();
      this.addLayer();
    }
  }, {
    key: 'initLayer',
    value: function initLayer() {
      var scene = this.context.scene;

      if (this.layer) scene.removeLayer(this.layer);
      var _props$options = this.props.options,
          options = _props$options === undefined ? {} : _props$options;

      this.layer = scene.PolygonLayer(options);
    }
  }, {
    key: 'addLayer',
    value: function addLayer() {
      var _props = this.props,
          source = _props.source,
          color = _props.color,
          size = _props.size,
          shape = _props.shape,
          style = _props.style,
          filter = _props.filter,
          active = _props.active,
          _props$options2 = _props.options,
          options = _props$options2 === undefined ? {} : _props$options2;

      if (!source.data) {
        return;
      }
      var layer = this.layer;
      layer.source(source.data, {
        parser: source.parser,
        transforms: source.transforms
      });
      filter && layer.filter(filter.field, filter.value);
      color && layer.color(color.field, color.value);
      size.field && layer.size(size.field, size.value);
      shape && layer.shape(shape.field, shape.value);
      active instanceof Boolean && layer.acitve(active);
      active instanceof Object && layer.acitve(active);
      style && layer.style(style);
      this.layer.render();
      if (options.autoFit) {
        this.layer.fitBounds();
      }
      this.setState({ layer: this.layer });
    }
  }, {
    key: 'updateLayerOption',
    value: function updateLayerOption(nextOptions, options) {
      if (nextOptions.visible !== options.visible) {
        nextOptions.visible ? this.layer.show() : this.layer.hide();
      }
      if (nextOptions.autoFit !== options.autoFit && nextOptions.autoFit === true) {
        this.layer.fitBounds();
      }
      if (nextOptions.minZoom !== options.minZoom) {
        this.layer.set('minZoom', nextOptions.minZoom);
      }
      if (nextOptions.maxZoom !== options.maxZoom) {
        this.layer.set('maxZoom', nextOptions.maxZoom);
      }
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (!this.layer) return null;
      var _props2 = this.props,
          source = _props2.source,
          size = _props2.size,
          color = _props2.color,
          shape = _props2.shape,
          style = _props2.style,
          filter = _props2.filter,
          options = _props2.options;

      var nextSource = nextProps.source;
      var nextSize = nextProps.size;
      var nextColor = nextProps.color;
      var nextStyle = nextProps.style;
      var nextShape = nextProps.shape;
      var nextfilter = nextProps.filter;
      var nextOptions = nextProps.options;
      if (!_deepEqual_1_1_0_deepEqual(source, nextSource)) {
        this.layer.setData(nextSource.data);
      }
      if (!_deepEqual_1_1_0_deepEqual(nextOptions, options)) {
        this.updateLayerOption(nextOptions, options);
      }
      !_deepEqual_1_1_0_deepEqual(color, nextColor) && this.layer.color(nextColor.field, nextColor.value);
      !_deepEqual_1_1_0_deepEqual(size, nextSize) && this.layer.size(nextSize.field, nextSize.value);
      !_deepEqual_1_1_0_deepEqual(shape, nextShape) && this.layer.shape(nextShape.field, nextShape.value);
      !_deepEqual_1_1_0_deepEqual(style, nextStyle) && this.layer.style(nextStyle);
      if (!this.propsEqual(filter, nextfilter)) {
        this.layer.filter(nextfilter.field, nextfilter.value);
      }
      this.layer.render();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var scene = this.context.scene;

      scene.removeLayer(this.layer);
    }
  }, {
    key: 'renderChildren',
    value: function renderChildren() {
      return Children$1.map(this.props.children, function (child) {
        if (child) {
          return React.cloneElement(child);
        }
        return child;
      });
    }
  }, {
    key: 'propsEqual',
    value: function propsEqual(pre, next) {
      if (!pre || !next) {
        return _deepEqual_1_1_0_deepEqual(pre, next);
      }
      if (!pre.value || !pre.value) {
        return _deepEqual_1_1_0_deepEqual(pre, next);
      }
      if (_deepEqual_1_1_0_deepEqual(pre.value.toString(), next.value.toString()) && _deepEqual_1_1_0_deepEqual(pre.id, next.id)) {
        return true;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        null,
        this.state.layer ? this.renderChildren() : null
      );
    }
  }]);
  return BaseLayer;
}(Component);

BaseLayer.contextTypes = {
  scene: PropTypes.object
};
BaseLayer.propTypes = {
  children: PropTypes.object,
  source: PropTypes.object,
  color: PropTypes.object,
  size: PropTypes.object,
  shape: PropTypes.object,
  active: PropTypes.any,
  style: PropTypes.object,
  filter: PropTypes.object,
  options: PropTypes.object
};
BaseLayer.childContextTypes = {
  layer: PropTypes.object
};
BaseLayer.defaultProps = {
  source: {
    data: null
  },
  color: {
    field: '#4eb3d3'
  },
  size: {
    field: null
  },
  shape: {
    field: 'fill'
  },
  active: false,
  style: {
    opacity: 1.0
  }
};

/* eslint-disable camelcase */

var Polygon = function (_BaseLayer) {
  inherits(Polygon, _BaseLayer);

  function Polygon() {
    classCallCheck(this, Polygon);
    return possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).apply(this, arguments));
  }

  createClass(Polygon, [{
    key: 'initLayer',
    value: function initLayer() {
      var scene = this.context.scene;

      if (this.layer) scene.removeLayer(this.layer);
      var _props$options = this.props.options,
          options = _props$options === undefined ? {} : _props$options;

      this.layer = scene.PolygonLayer(options);
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        null,
        this.state.layer ? this.renderChildren() : null
      );
    }
  }]);
  return Polygon;
}(BaseLayer);

Polygon.defaultProps = Object.assign(BaseLayer.defaultProps, {
  source: {
    data: null
  },
  color: {
    field: '#4eb3d3'
  },
  size: {
    field: null
  },
  shape: {
    field: 'fill'
  },
  style: {
    opacity: 1.0
  }
});

var PolyLine = function (_BaseLayer) {
  inherits(PolyLine, _BaseLayer);

  function PolyLine() {
    classCallCheck(this, PolyLine);
    return possibleConstructorReturn(this, (PolyLine.__proto__ || Object.getPrototypeOf(PolyLine)).apply(this, arguments));
  }

  createClass(PolyLine, [{
    key: 'initLayer',
    value: function initLayer() {
      var scene = this.context.scene;

      if (this.layer) scene.removeLayer(this.layer);
      var _props$options = this.props.options,
          options = _props$options === undefined ? {} : _props$options;

      this.layer = scene.LineLayer(options);
    }
  }]);
  return PolyLine;
}(BaseLayer);

PolyLine.defaultProps = Object.assign(BaseLayer.defaultProps, {
  source: {
    data: null
  },
  color: {
    field: '#4eb3d3'
  },
  size: {
    field: 2
  },
  shape: {
    field: 'line'
  },
  style: {
    opacity: 1.0
  }
});

var Point = function (_BaseLayer) {
  inherits(Point, _BaseLayer);

  function Point() {
    classCallCheck(this, Point);
    return possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).apply(this, arguments));
  }

  createClass(Point, [{
    key: 'initLayer',
    value: function initLayer() {
      var scene = this.context.scene;

      if (this.layer) scene.removeLayer(this.layer);
      var _props$options = this.props.options,
          options = _props$options === undefined ? {} : _props$options;

      this.layer = scene.PointLayer(options);
    }
  }]);
  return Point;
}(BaseLayer);

Point.defaultProps = Object.assign(BaseLayer.defaultProps, {
  cfg: {
    visible: true
  },
  source: {
    data: null
  },
  color: {
    field: '#4eb3d3'
  },
  size: {
    field: 12
  },
  shape: {
    field: 'circle'
  },
  style: {
    fontWeight: 400,
    textAnchor: 'center', // 文本相对锚点的位置 center|left|right|top|bottom|top-left
    textOffset: [0, 0], // 文本相对锚点的偏移量 [水平, 垂直]
    spacing: 2, // 字符间距
    padding: [4, 4], // 文本包围盒 padding [水平，垂直]，影响碰撞检测结果，避免相邻文本靠的太近
    stroke: 'white', // 描边颜色
    strokeWidth: 2, // 描边宽度
    opacity: 1.0
  }
});

var toStr$7 = Object.prototype.toString;

var isArguments$1 = function isArguments(value) {
	var str = toStr$7.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr$7.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

var keysShim$2;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has$1 = Object.prototype.hasOwnProperty;
	var toStr$8 = Object.prototype.toString;
	var isArgs$1 = isArguments$1; // eslint-disable-line global-require
	var isEnumerable$1 = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug$1 = !isEnumerable$1.call({ toString: null }, 'toString');
	var hasProtoEnumBug$1 = isEnumerable$1.call(function () {}, 'prototype');
	var dontEnums$1 = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype$1 = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys$1 = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug$1 = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys$1['$' + k] && has$1.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype$1(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy$1 = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug$1) {
			return equalsConstructorPrototype$1(o);
		}
		try {
			return equalsConstructorPrototype$1(o);
		} catch (e) {
			return false;
		}
	};

	keysShim$2 = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr$8.call(object) === '[object Function]';
		var isArguments = isArgs$1(object);
		var isString = isObject && toStr$8.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug$1 && isFunction;
		if (isString && object.length > 0 && !has$1.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has$1.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug$1) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy$1(object);

			for (var k = 0; k < dontEnums$1.length; ++k) {
				if (!(skipConstructor && dontEnums$1[k] === 'constructor') && has$1.call(object, dontEnums$1[k])) {
					theKeys.push(dontEnums$1[k]);
				}
			}
		}
		return theKeys;
	};
}
var implementation$3 = keysShim$2;

var slice$2 = Array.prototype.slice;


var origKeys$1 = Object.keys;
var keysShim$3 = origKeys$1 ? function keys(o) { return origKeys$1(o); } : implementation$3;

var originalKeys$1 = Object.keys;

keysShim$3.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArguments$1(object)) {
					return originalKeys$1(slice$2.call(object));
				}
				return originalKeys$1(object);
			};
		}
	} else {
		Object.keys = keysShim$3;
	}
	return Object.keys || keysShim$3;
};

var objectKeys = keysShim$3;

var hasToStringTag$3 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr$9 = Object.prototype.toString;

var isStandardArguments$1 = function isArguments(value) {
	if (hasToStringTag$3 && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr$9.call(value) === '[object Arguments]';
};

var isLegacyArguments$1 = function isArguments(value) {
	if (isStandardArguments$1(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr$9.call(value) !== '[object Array]' &&
		toStr$9.call(value.callee) === '[object Function]';
};

var supportsStandardArguments$1 = (function () {
	return isStandardArguments$1(arguments);
}());

isStandardArguments$1.isLegacyArguments = isLegacyArguments$1; // for tests

var isArguments$2 = supportsStandardArguments$1 ? isStandardArguments$1 : isLegacyArguments$1;

/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.is */

var NumberIsNaN$1 = function (value) {
	return value !== value;
};

var objectIs = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	} else if (a === b) {
		return true;
	} else if (NumberIsNaN$1(a) && NumberIsNaN$1(b)) {
		return true;
	}
	return false;
};

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE$1 = 'Function.prototype.bind called on incompatible ';
var slice$3 = Array.prototype.slice;
var toStr$a = Object.prototype.toString;
var funcType$1 = '[object Function]';

var implementation$4 = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr$a.call(target) !== funcType$1) {
        throw new TypeError(ERROR_MESSAGE$1 + target);
    }
    var args = slice$3.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice$3.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice$3.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

var functionBind = Function.prototype.bind || implementation$4;

var src$1 = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

var regexExec$1 = RegExp.prototype.exec;
var gOPD$3 = Object.getOwnPropertyDescriptor;

var tryRegexExecCall$1 = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec$1.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr$b = Object.prototype.toString;
var regexClass$1 = '[object RegExp]';
var hasToStringTag$4 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var isRegex = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag$4) {
		return toStr$b.call(value) === regexClass$1;
	}

	var descriptor = gOPD$3(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && src$1(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall$1(value);
};

var hasSymbols$1 = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr$c = Object.prototype.toString;
var concat$1 = Array.prototype.concat;
var origDefineProperty$1 = Object.defineProperty;

var isFunction$1 = function (fn) {
	return typeof fn === 'function' && toStr$c.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported$1 = function () {
	var obj = {};
	try {
		origDefineProperty$1(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors$3 = origDefineProperty$1 && arePropertyDescriptorsSupported$1();

var defineProperty$3 = function (object, name, value, predicate) {
	if (name in object && (!isFunction$1(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors$3) {
		origDefineProperty$1(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties$1 = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = objectKeys(map);
	if (hasSymbols$1) {
		props = concat$1.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty$3(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties$1.supportsDescriptors = !!supportsDescriptors$3;

var defineProperties_1 = defineProperties$1;

var toObject$1 = Object;
var TypeErr$3 = TypeError;

var implementation$5 = function flags() {
	if (this != null && this !== toObject$1(this)) {
		throw new TypeErr$3('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
};

var supportsDescriptors$4 = defineProperties_1.supportsDescriptors;
var gOPD$4 = Object.getOwnPropertyDescriptor;
var TypeErr$4 = TypeError;

var polyfill$1 = function getPolyfill() {
	if (!supportsDescriptors$4) {
		throw new TypeErr$4('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	if (/a/mig.flags === 'gim') {
		var descriptor = gOPD$4(RegExp.prototype, 'flags');
		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
			return descriptor.get;
		}
	}
	return implementation$5;
};

var supportsDescriptors$5 = defineProperties_1.supportsDescriptors;

var gOPD$5 = Object.getOwnPropertyDescriptor;
var defineProperty$4 = Object.defineProperty;
var TypeErr$5 = TypeError;
var getProto$1 = Object.getPrototypeOf;
var regex$1 = /a/;

var shim$1 = function shimFlags() {
	if (!supportsDescriptors$5 || !getProto$1) {
		throw new TypeErr$5('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	var polyfill = polyfill$1();
	var proto = getProto$1(regex$1);
	var descriptor = gOPD$5(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill) {
		defineProperty$4(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill
		});
	}
	return polyfill;
};

var flagsBound$1 = Function.call.bind(implementation$5);

defineProperties_1(flagsBound$1, {
	getPolyfill: polyfill$1,
	implementation: implementation$5,
	shim: shim$1
});

var regexp_prototype_flags = flagsBound$1;

var getDay$1 = Date.prototype.getDay;
var tryDateObject$1 = function tryDateObject(value) {
	try {
		getDay$1.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr$d = Object.prototype.toString;
var dateClass$1 = '[object Date]';
var hasToStringTag$5 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var isDateObject = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag$5 ? tryDateObject$1(value) : toStr$d.call(value) === dateClass$1;
};

var getTime$1 = Date.prototype.getTime;

function deepEqual$1(actual, expected, options) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? objectIs(actual, expected) : actual === expected) {
    return true;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
    return opts.strict ? objectIs(actual, expected) : actual == expected;
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // eslint-disable-next-line no-use-before-define
  return objEquiv$1(actual, expected, opts);
}

function isUndefinedOrNull$1(value) {
  return value === null || value === undefined;
}

function isBuffer$1(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }
  return true;
}

function objEquiv$1(a, b, opts) {
  /* eslint max-statements: [2, 50] */
  var i, key;
  if (typeof a !== typeof b) { return false; }
  if (isUndefinedOrNull$1(a) || isUndefinedOrNull$1(b)) { return false; }

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) { return false; }

  if (isArguments$2(a) !== isArguments$2(b)) { return false; }

  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) { return false; }
  if (aIsRegex || bIsRegex) {
    return a.source === b.source && regexp_prototype_flags(a) === regexp_prototype_flags(b);
  }

  if (isDateObject(a) && isDateObject(b)) {
    return getTime$1.call(a) === getTime$1.call(b);
  }

  var aIsBuffer = isBuffer$1(a);
  var bIsBuffer = isBuffer$1(b);
  if (aIsBuffer !== bIsBuffer) { return false; }
  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
    if (a.length !== b.length) { return false; }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  if (typeof a !== typeof b) { return false; }

  try {
    var ka = objectKeys(a);
    var kb = objectKeys(b);
  } catch (e) { // happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) { return false; }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) { return false; }
  }
  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual$1(a[key], b[key], opts)) { return false; }
  }

  return true;
}

var deepEqual_1 = deepEqual$1;

/* eslint-disable camelcase */

var Popup = function (_Component) {
  inherits(Popup, _Component);

  function Popup() {
    classCallCheck(this, Popup);
    return possibleConstructorReturn(this, (Popup.__proto__ || Object.getPrototypeOf(Popup)).apply(this, arguments));
  }

  createClass(Popup, [{
    key: 'addPopup',
    value: function addPopup(props) {
      var _props$option = props.option,
          option = _props$option === undefined ? {} : _props$option,
          lnglat = props.lnglat,
          html = props.html,
          text = props.text;

      this.popup = new L7$1.Popup(option);
      this.popup.addTo(this.context.scene);
      if (lnglat) {
        this.popup.setLnglat(lnglat);
      }
      if (html) {
        this.popup.setHtml(html);
      }
      if (text) {
        this.popup.setText(text);
      }
      if (props.children) {
        this.renderChildren(props);
        this.popup.setDOMContent(this.el);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.el = document.createElement('div');
      this.el.className = 'react-l7-popup';
      Object.assign(this.el.style, {
        position: 'relative',
        display: 'inline-block'
      });
      this.addPopup(this.props);
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (!deepEqual_1(this.props.lnglat, nextProps.lnglat) || !deepEqual_1(this.props.html, nextProps.html) || !deepEqual_1(this.props.text, nextProps.text) || !deepEqual_1(this.props.onClose, nextProps.onClose)) {
        this.removePopup();
        this.addPopup(nextProps);
      }

      // // Otherwise update the current popup.
      if (!deepEqual_1(this.props.lnglat, nextProps.lnglat)) {
        this.popup.setLnglat(nextProps.lnglat);
      }
      if (this.props.children !== nextProps.children) {
        this.renderChildren(nextProps);
      }
    }
  }, {
    key: 'removePopup',
    value: function removePopup() {
      if (this.popup.isOpen()) {
        this.popup.off('close');
        this.popup.remove();
      }
      this.popup = null;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.popup.remove();
    }
  }, {
    key: 'renderChildren',
    value: function renderChildren(props) {
      if (this.component) {
        ReactDOM.unmountComponentAtNode(this.el);
      }
      if (props.children) {
        this.component = ReactDOM.unstable_renderSubtreeIntoContainer(this, props.children, this.el);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return Popup;
}(Component);

Popup.contextTypes = {
  layer: PropTypes.object,
  scene: PropTypes.object
};
Popup.propTypes = {
  lnglat: PropTypes.array,
  text: PropTypes.string,
  html: PropTypes.string,
  onClose: PropTypes.bool,
  children: PropTypes.element
};

var LayerEvent = function (_React$PureComponent) {
  inherits(LayerEvent, _React$PureComponent);

  function LayerEvent() {
    classCallCheck(this, LayerEvent);
    return possibleConstructorReturn(this, (LayerEvent.__proto__ || Object.getPrototypeOf(LayerEvent)).apply(this, arguments));
  }

  createClass(LayerEvent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var layer = this.context.layer;

      layer.on(this.props.type, this.props.onChange);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var layer = this.context.layer;

      layer.off(this.props.type, this.props.onChange);
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var layer = this.context.layer;

      if (this.props.type !== nextProps.type || this.props.onChange !== nextProps.onChange) {
        layer.off(this.props.type, this.props.onChange);
        layer.on(nextProps.type, nextProps.onChange);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return LayerEvent;
}(React.PureComponent);

LayerEvent.propTypes = {
  type: PropTypes.string.isRequired,
  onChange: PropTypes.func.isRequired
};
LayerEvent.contextTypes = {
  layer: PropTypes.object
};

var SceneEvent = function (_React$PureComponent) {
  inherits(SceneEvent, _React$PureComponent);

  function SceneEvent() {
    classCallCheck(this, SceneEvent);
    return possibleConstructorReturn(this, (SceneEvent.__proto__ || Object.getPrototypeOf(SceneEvent)).apply(this, arguments));
  }

  createClass(SceneEvent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var scene = this.context.scene;

      scene.on(this.props.type, this.props.onChange);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var scene = this.context.scene;

      scene.off(this.props.type, this.props.onChange);
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var scene = this.context.scene;

      if (this.props.type !== nextProps.type || this.props.onChange !== nextProps.onChange) {
        scene.off(this.props.type, this.props.onChange);
        scene.on(nextProps.type, nextProps.onChange);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return SceneEvent;
}(React.PureComponent);

SceneEvent.propTypes = {
  type: PropTypes.string.isRequired,
  onChange: PropTypes.func.isRequired
};
SceneEvent.contextTypes = {
  scene: PropTypes.object
};

// 加载图表标注资源

var LoadImage = function (_Component) {
  inherits(LoadImage, _Component);

  function LoadImage() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, LoadImage);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = LoadImage.__proto__ || Object.getPrototypeOf(LoadImage)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(LoadImage, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var option = this.props.option;

      this.context.scene.image.addImage(option.name, option.url);
    }
  }, {
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var option = nextProps.option;

      if (!deepEqual_1(option, this.props.option)) {
        this.context.scene.image.addImage(option.name, option.url);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return LoadImage;
}(Component);

LoadImage.contextTypes = {
  scene: PropTypes.object
};
LoadImage.propTypes = {
  option: PropTypes.object
};

var Control = function (_React$PureComponent) {
  inherits(Control, _React$PureComponent);

  function Control() {
    classCallCheck(this, Control);
    return possibleConstructorReturn(this, (Control.__proto__ || Object.getPrototypeOf(Control)).apply(this, arguments));
  }

  createClass(Control, [{
    key: 'createControl',
    value: function createControl(props) {
      var _context = this.context,
          L7 = _context.L7,
          scene = _context.scene;
      var option = this.props.option;

      var ctr = Control.controlOption[option.type];
      this.ctr = new L7.Control[ctr.name]({
        position: ctr.position
      }).addTo(scene);
      scene.set(props.type, this.ctr);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.createControl(this.props);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.ctr.remove();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!deepEqual_1(this.props, nextProps)) {
        this.ctr.remove();
        this.createControl(nextProps);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return Control;
}(React.PureComponent);

Control.controlOption = {
  zoom: {
    name: 'Zoom',
    position: 'topleft'
  },
  scale: {
    name: 'Scale',
    position: 'bottomleft'
  },
  attribution: {
    name: 'Attribution',
    position: 'bottomright'
  }
};
Control.propTypes = {
  option: PropTypes.object
};
Control.contextTypes = {
  scene: PropTypes.object,
  L7: PropTypes.object
};

var CustomControl = function (_React$PureComponent) {
  inherits(CustomControl, _React$PureComponent);

  function CustomControl() {
    classCallCheck(this, CustomControl);
    return possibleConstructorReturn(this, (CustomControl.__proto__ || Object.getPrototypeOf(CustomControl)).apply(this, arguments));
  }

  createClass(CustomControl, [{
    key: 'createControl',
    value: function createControl(props) {
      var _this2 = this;

      var _context = this.context,
          L7 = _context.L7,
          scene = _context.scene;
      var position = this.props.option.position;

      var control = new L7.Control.Base({
        position: position
      });
      if (props.children) {
        this.renderChildren(props);
      }
      control.onAdd = function () {
        return _this2.el;
      };
      control.addTo(scene);
      this.ctr = control;
      // scene.set(props.type, this.ctr)
    }
  }, {
    key: 'renderChildren',
    value: function renderChildren(props) {
      if (this.component) {
        ReactDOM.unmountComponentAtNode(this.el);
      }
      if (props.children) {
        this.component = ReactDOM.unstable_renderSubtreeIntoContainer(this, props.children, this.el);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.el = document.createElement('div');
      this.createControl(this.props);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.ctr.remove();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!deepEqual_1(this.props, nextProps)) {
        this.ctr.remove();
        this.createControl(nextProps);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return CustomControl;
}(React.PureComponent);

CustomControl.contextTypes = {
  scene: PropTypes.object,
  L7: PropTypes.object
};
CustomControl.propTypes = {
  option: PropTypes.object
  // children: PropTypes.element
};

export { Scene, LoadImage, Polygon, PolyLine as Line, Point, Popup, LayerEvent, SceneEvent, AMapProvider, Control, CustomControl };
//# sourceMappingURL=index.es.js.map
